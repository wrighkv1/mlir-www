<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::bufferization Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">16.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1bufferization.html">bufferization</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::bufferization Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1bufferization_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1bufferization_1_1func__ext"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization_1_1func__ext.html">func_ext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1OpFilter.html">OpFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for BufferizableOpInterface-based bufferization.  <a href="structmlir_1_1bufferization_1_1BufferizationOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1DialectAnalysisState.html">DialectAnalysisState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dialect-specific analysis state.  <a href="structmlir_1_1bufferization_1_1DialectAnalysisState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html">AnalysisState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html" title="AnalysisState provides a variety of helper functions for dealing with tensor values.">AnalysisState</a> provides a variety of helper functions for dealing with tensor values.  <a href="classmlir_1_1bufferization_1_1AnalysisState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1DstBufferizableOpInterfaceExternalModel.html">DstBufferizableOpInterfaceExternalModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferizable ops that implement the DestinationStyleOpInterface can use this external model base class.  <a href="structmlir_1_1bufferization_1_1DstBufferizableOpInterfaceExternalModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1BufferizeTypeConverter.html">BufferizeTypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper type converter class that automatically populates the relevant materializations and type conversions for bufferization.  <a href="classmlir_1_1bufferization_1_1BufferizeTypeConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1BufferPlacementAllocs.html">BufferPlacementAllocs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple analysis that detects allocation operations.  <a href="classmlir_1_1bufferization_1_1BufferPlacementAllocs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1BufferPlacementTransformationBase.html">BufferPlacementTransformationBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for all BufferPlacement transformations.  <a href="classmlir_1_1bufferization_1_1BufferPlacementTransformationBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for analysis-enabled bufferization.  <a href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1BufferizationAliasInfo.html">BufferizationAliasInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmlir_1_1bufferization_1_1BufferizationAliasInfo.html" title="The BufferizationAliasInfo class maintains a list of buffer aliases and equivalence classes to suppor...">BufferizationAliasInfo</a> class maintains a list of buffer aliases and equivalence classes to support bufferization.  <a href="classmlir_1_1bufferization_1_1BufferizationAliasInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State for analysis-enabled bufferization.  <a href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1BufferResultsToOutParamsOptions.html">BufferResultsToOutParamsOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9f555e6310adbe13cf6fd0163a345f65"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a9f555e6310adbe13cf6fd0163a345f65">AnchorMatchFn</a> = std::function&lt; bool(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;)&gt;</td></tr>
<tr class="memdesc:a9f555e6310adbe13cf6fd0163a345f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that matches anchor OpOperands for tensor::EmptyOp elimination.  <a href="namespacemlir_1_1bufferization.html#a9f555e6310adbe13cf6fd0163a345f65">More...</a><br /></td></tr>
<tr class="separator:a9f555e6310adbe13cf6fd0163a345f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad8a6459f58b1a5a6772110aac8d93d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#afad8a6459f58b1a5a6772110aac8d93d">RewriteFn</a> = std::function&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;)&gt;</td></tr>
<tr class="memdesc:afad8a6459f58b1a5a6772110aac8d93d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that rewrites matched anchors.  <a href="namespacemlir_1_1bufferization.html#afad8a6459f58b1a5a6772110aac8d93d">More...</a><br /></td></tr>
<tr class="separator:afad8a6459f58b1a5a6772110aac8d93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:afbf6d54f9e3c10b9003b66b6224b28bf"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bf">BufferRelation</a> { <a class="el" href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bfa6adf97f83acf6453d4a6a4b1070f3754">None</a>
, <a class="el" href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bfaafd102579f64c98e96d92a7424130605">Equivalent</a>
 }</td></tr>
<tr class="memdesc:afbf6d54f9e3c10b9003b66b6224b28bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify fine-grain relationship between buffers to enable more analysis.  <a href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bf">More...</a><br /></td></tr>
<tr class="separator:afbf6d54f9e3c10b9003b66b6224b28bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa24e592182e0b88ede8e85dbc3dcac5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aa24e592182e0b88ede8e85dbc3dcac5e">isFunctionArgument</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="memdesc:aa24e592182e0b88ede8e85dbc3dcac5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the given value is a <a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block.">BlockArgument</a> of a func::FuncOp.  <a href="namespacemlir_1_1bufferization.html#aa24e592182e0b88ede8e85dbc3dcac5e">More...</a><br /></td></tr>
<tr class="separator:aa24e592182e0b88ede8e85dbc3dcac5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b8affbc45eb90f938f0d94b21eac45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a84b8affbc45eb90f938f0d94b21eac45">allocateTensorForShapedValue</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> shapedValue, bool escape, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, bool <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp.html#a6ca5ef47ce8bbced1c354e95e188f2e2">copy</a>=true)</td></tr>
<tr class="memdesc:a84b8affbc45eb90f938f0d94b21eac45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an AllocTensorOp for the given shaped value (memref or tensor).  <a href="namespacemlir_1_1bufferization.html#a84b8affbc45eb90f938f0d94b21eac45">More...</a><br /></td></tr>
<tr class="separator:a84b8affbc45eb90f938f0d94b21eac45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328e7c6d8ce499626dbf57ca19e482dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a328e7c6d8ce499626dbf57ca19e482dd">allocationDoesNotEscape</a> (<a class="el" href="classmlir_1_1OpResult.html">OpResult</a> opResult)</td></tr>
<tr class="memdesc:a328e7c6d8ce499626dbf57ca19e482dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the allocation of the given op is guaranteed to not escape the containing block.  <a href="namespacemlir_1_1bufferization.html#a328e7c6d8ce499626dbf57ca19e482dd">More...</a><br /></td></tr>
<tr class="separator:a328e7c6d8ce499626dbf57ca19e482dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf241364e9dfd1def82141c75035f4b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#abf241364e9dfd1def82141c75035f4b0">getBuffer</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:abf241364e9dfd1def82141c75035f4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup the buffer for the given value.  <a href="namespacemlir_1_1bufferization.html#abf241364e9dfd1def82141c75035f4b0">More...</a><br /></td></tr>
<tr class="separator:abf241364e9dfd1def82141c75035f4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc2d902756788c32c33244776d141c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aadc2d902756788c32c33244776d141c7">getBufferType</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:aadc2d902756788c32c33244776d141c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the buffer type for a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> (tensor) after bufferization without bufferizing any IR.  <a href="namespacemlir_1_1bufferization.html#aadc2d902756788c32c33244776d141c7">More...</a><br /></td></tr>
<tr class="separator:aadc2d902756788c32c33244776d141c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de4a7671524f168224c818658f03bfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a2de4a7671524f168224c818658f03bfb">getBufferType</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, const <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> &gt; &amp;fixedTypes)</td></tr>
<tr class="memdesc:a2de4a7671524f168224c818658f03bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the buffer type for a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> (tensor) after bufferization without bufferizing any IR.  <a href="namespacemlir_1_1bufferization.html#a2de4a7671524f168224c818658f03bfb">More...</a><br /></td></tr>
<tr class="separator:a2de4a7671524f168224c818658f03bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05561ae5b9cceea1c45832340484ad6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a05561ae5b9cceea1c45832340484ad6b">replaceOpWithBufferizedValues</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values)</td></tr>
<tr class="memdesc:a05561ae5b9cceea1c45832340484ad6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace an op with replacement values.  <a href="namespacemlir_1_1bufferization.html#a05561ae5b9cceea1c45832340484ad6b">More...</a><br /></td></tr>
<tr class="separator:a05561ae5b9cceea1c45832340484ad6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91366abfb8d491ea5701260487518959"><td class="memTemplParams" colspan="2">template&lt;typename OpTy , typename... Args&gt; </td></tr>
<tr class="memitem:a91366abfb8d491ea5701260487518959"><td class="memTemplItemLeft" align="right" valign="top">OpTy&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a91366abfb8d491ea5701260487518959">replaceOpWithNewBufferizedOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a91366abfb8d491ea5701260487518959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace an op with a new op.  <a href="namespacemlir_1_1bufferization.html#a91366abfb8d491ea5701260487518959">More...</a><br /></td></tr>
<tr class="separator:a91366abfb8d491ea5701260487518959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db18d8594be09f305df7fc8cc2afedb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a6db18d8594be09f305df7fc8cc2afedb">shouldDeallocateOpResult</a> (<a class="el" href="classmlir_1_1OpResult.html">OpResult</a> opResult, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a6db18d8594be09f305df7fc8cc2afedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the buffer of given <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> should be deallocated.  <a href="namespacemlir_1_1bufferization.html#a6db18d8594be09f305df7fc8cc2afedb">More...</a><br /></td></tr>
<tr class="separator:a6db18d8594be09f305df7fc8cc2afedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dbae70b4a9558ae3509d2ac49718962"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a0dbae70b4a9558ae3509d2ac49718962">getMemRefType</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, MemRefLayoutAttrInterface layout={}, unsigned memorySpace=0)</td></tr>
<tr class="memdesc:a0dbae70b4a9558ae3509d2ac49718962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a MemRefType to which the type of the given value can be bufferized.  <a href="namespacemlir_1_1bufferization.html#a0dbae70b4a9558ae3509d2ac49718962">More...</a><br /></td></tr>
<tr class="separator:a0dbae70b4a9558ae3509d2ac49718962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99605bbd53f319ef2f0d98246054b995"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a99605bbd53f319ef2f0d98246054b995">getMemRefTypeWithFullyDynamicLayout</a> (<a class="el" href="classmlir_1_1TensorType.html">TensorType</a> tensorType, unsigned memorySpace=0)</td></tr>
<tr class="memdesc:a99605bbd53f319ef2f0d98246054b995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a MemRef type with fully dynamic layout.  <a href="namespacemlir_1_1bufferization.html#a99605bbd53f319ef2f0d98246054b995">More...</a><br /></td></tr>
<tr class="separator:a99605bbd53f319ef2f0d98246054b995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30322c8e4f431c112e5bff79de859003"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a30322c8e4f431c112e5bff79de859003">getMemRefTypeWithStaticIdentityLayout</a> (<a class="el" href="classmlir_1_1TensorType.html">TensorType</a> tensorType, unsigned memorySpace=0)</td></tr>
<tr class="memdesc:a30322c8e4f431c112e5bff79de859003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a MemRef type with a static identity layout (i.e., no layout map).  <a href="namespacemlir_1_1bufferization.html#a30322c8e4f431c112e5bff79de859003">More...</a><br /></td></tr>
<tr class="separator:a30322c8e4f431c112e5bff79de859003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ed0ccb4e307d98675ecab129feddf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a25ed0ccb4e307d98675ecab129feddf5">getOwnerOfValue</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="memdesc:a25ed0ccb4e307d98675ecab129feddf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the owner of the given value.  <a href="namespacemlir_1_1bufferization.html#a25ed0ccb4e307d98675ecab129feddf5">More...</a><br /></td></tr>
<tr class="separator:a25ed0ccb4e307d98675ecab129feddf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7726e480700dfb860214b275d6a396d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#af7726e480700dfb860214b275d6a396d">populateDynamicDimSizes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> shapedValue, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;dynamicDims)</td></tr>
<tr class="memdesc:af7726e480700dfb860214b275d6a396d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate <code>dynamicDims</code> with tensor::DimOp / memref::DimOp results for all dynamic dimensions of the given shaped value.  <a href="namespacemlir_1_1bufferization.html#af7726e480700dfb860214b275d6a396d">More...</a><br /></td></tr>
<tr class="separator:af7726e480700dfb860214b275d6a396d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf648dc804a1dcc39379e036051dbf82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#acf648dc804a1dcc39379e036051dbf82">castOrReallocMemRefValue</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, MemRefType type)</td></tr>
<tr class="memdesc:acf648dc804a1dcc39379e036051dbf82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to cast the given ranked MemRef-typed value to the given ranked MemRef type.  <a href="namespacemlir_1_1bufferization.html#acf648dc804a1dcc39379e036051dbf82">More...</a><br /></td></tr>
<tr class="separator:acf648dc804a1dcc39379e036051dbf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f68223b1811698fd85780df73c4fde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a64f68223b1811698fd85780df73c4fde">foldToMemrefToTensorPair</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, ToMemrefOp toMemref)</td></tr>
<tr class="memdesc:a64f68223b1811698fd85780df73c4fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to fold to_memref(to_tensor(x)).  <a href="namespacemlir_1_1bufferization.html#a64f68223b1811698fd85780df73c4fde">More...</a><br /></td></tr>
<tr class="separator:a64f68223b1811698fd85780df73c4fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2d5a6d2e5ab89ec76a879d71e32a36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a2b2d5a6d2e5ab89ec76a879d71e32a36">registerTransformDialectExtension</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a2b2d5a6d2e5ab89ec76a879d71e32a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6223871e93de2dbc611e8e54c5e4fb3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a6223871e93de2dbc611e8e54c5e4fb3b">populateBufferizeMaterializationLegality</a> (<a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:a6223871e93de2dbc611e8e54c5e4fb3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks ops used by bufferization for type conversion materializations as "legal" in the given <a class="el" href="classmlir_1_1ConversionTarget.html" title="This class describes a specific conversion target.">ConversionTarget</a>.  <a href="namespacemlir_1_1bufferization.html#a6223871e93de2dbc611e8e54c5e4fb3b">More...</a><br /></td></tr>
<tr class="separator:a6223871e93de2dbc611e8e54c5e4fb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22345dcd836dbc3216a89bbd4ce26821"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a22345dcd836dbc3216a89bbd4ce26821">populateEliminateBufferizeMaterializationsPatterns</a> (<a class="el" href="classmlir_1_1bufferization_1_1BufferizeTypeConverter.html">BufferizeTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a22345dcd836dbc3216a89bbd4ce26821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns to eliminate bufferize materializations.  <a href="namespacemlir_1_1bufferization.html#a22345dcd836dbc3216a89bbd4ce26821">More...</a><br /></td></tr>
<tr class="separator:a22345dcd836dbc3216a89bbd4ce26821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0834ca306715f47090a48424de0a7129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a0834ca306715f47090a48424de0a7129">bufferizeOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, bool copyBeforeWrite=true, const <a class="el" href="classmlir_1_1bufferization_1_1OpFilter.html">OpFilter</a> *opFilter=nullptr)</td></tr>
<tr class="memdesc:a0834ca306715f47090a48424de0a7129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferize <code>op</code> and its nested ops that implement <code>BufferizableOpInterface</code>.  <a href="namespacemlir_1_1bufferization.html#a0834ca306715f47090a48424de0a7129">More...</a><br /></td></tr>
<tr class="separator:a0834ca306715f47090a48424de0a7129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36c97b27b691ad7fcee01d70ca143a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ac36c97b27b691ad7fcee01d70ca143a9">getPartialBufferizationOptions</a> ()</td></tr>
<tr class="separator:ac36c97b27b691ad7fcee01d70ca143a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa111ae7f728e7e3a776a2a67a177fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; memref::GlobalOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aaaa111ae7f728e7e3a776a2a67a177fb">getGlobalFor</a> (arith::ConstantOp constantOp, uint64_t alignment)</td></tr>
<tr class="separator:aaaa111ae7f728e7e3a776a2a67a177fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a195b54b8caf2857a41371be6348f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a31a195b54b8caf2857a41371be6348f0">analyzeOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;state)</td></tr>
<tr class="memdesc:a31a195b54b8caf2857a41371be6348f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze <code>op</code> and its nested ops.  <a href="namespacemlir_1_1bufferization.html#a31a195b54b8caf2857a41371be6348f0">More...</a><br /></td></tr>
<tr class="separator:a31a195b54b8caf2857a41371be6348f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fea54bba0c4c111425bdad3167e836"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a44fea54bba0c4c111425bdad3167e836">runOneShotBufferize</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a44fea54bba0c4c111425bdad3167e836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run One-Shot Bufferize on the given op: Analysis + Bufferization.  <a href="namespacemlir_1_1bufferization.html#a44fea54bba0c4c111425bdad3167e836">More...</a><br /></td></tr>
<tr class="separator:a44fea54bba0c4c111425bdad3167e836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c5406e7ae251a2920f3a7276ea9049"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ac2c5406e7ae251a2920f3a7276ea9049">analyzeModuleOp</a> (ModuleOp moduleOp, <a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;state)</td></tr>
<tr class="memdesc:ac2c5406e7ae251a2920f3a7276ea9049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze <code>moduleOp</code> and its nested ops.  <a href="namespacemlir_1_1bufferization.html#ac2c5406e7ae251a2920f3a7276ea9049">More...</a><br /></td></tr>
<tr class="separator:ac2c5406e7ae251a2920f3a7276ea9049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4e91f92d15be5a5979160e1048c381"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aaa4e91f92d15be5a5979160e1048c381">bufferizeModuleOp</a> (ModuleOp moduleOp, const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:aaa4e91f92d15be5a5979160e1048c381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferize <code>op</code> and its nested ops that implement <code>BufferizableOpInterface</code>.  <a href="namespacemlir_1_1bufferization.html#aaa4e91f92d15be5a5979160e1048c381">More...</a><br /></td></tr>
<tr class="separator:aaa4e91f92d15be5a5979160e1048c381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01516f6d5024ab7f61f78049b938595e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a01516f6d5024ab7f61f78049b938595e">runOneShotModuleBufferize</a> (ModuleOp moduleOp, const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">bufferization::OneShotBufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a01516f6d5024ab7f61f78049b938595e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run One-Shot Module Bufferization on the given module.  <a href="namespacemlir_1_1bufferization.html#a01516f6d5024ab7f61f78049b938595e">More...</a><br /></td></tr>
<tr class="separator:a01516f6d5024ab7f61f78049b938595e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbadbbffeae2eddfac65c53b2f1cadba"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#adbadbbffeae2eddfac65c53b2f1cadba">createBufferDeallocationPass</a> ()</td></tr>
<tr class="memdesc:adbadbbffeae2eddfac65c53b2f1cadba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the BufferDeallocation pass to free all allocated buffers.  <a href="namespacemlir_1_1bufferization.html#adbadbbffeae2eddfac65c53b2f1cadba">More...</a><br /></td></tr>
<tr class="separator:adbadbbffeae2eddfac65c53b2f1cadba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9fe9c9234e2d22a86553a393f074d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a8e9fe9c9234e2d22a86553a393f074d8">deallocateBuffers</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a8e9fe9c9234e2d22a86553a393f074d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run buffer deallocation.  <a href="namespacemlir_1_1bufferization.html#a8e9fe9c9234e2d22a86553a393f074d8">More...</a><br /></td></tr>
<tr class="separator:a8e9fe9c9234e2d22a86553a393f074d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b99b019001e22f13cbb9adaf483febe"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a4b99b019001e22f13cbb9adaf483febe">createBufferHoistingPass</a> ()</td></tr>
<tr class="memdesc:a4b99b019001e22f13cbb9adaf483febe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that moves allocations upwards to reduce the number of required copies that are inserted during the BufferDeallocation pass.  <a href="namespacemlir_1_1bufferization.html#a4b99b019001e22f13cbb9adaf483febe">More...</a><br /></td></tr>
<tr class="separator:a4b99b019001e22f13cbb9adaf483febe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f24bfd4dabfbaa35cb099c0cc78480"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a94f24bfd4dabfbaa35cb099c0cc78480">createBufferLoopHoistingPass</a> ()</td></tr>
<tr class="memdesc:a94f24bfd4dabfbaa35cb099c0cc78480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that moves allocations upwards out of loops.  <a href="namespacemlir_1_1bufferization.html#a94f24bfd4dabfbaa35cb099c0cc78480">More...</a><br /></td></tr>
<tr class="separator:a94f24bfd4dabfbaa35cb099c0cc78480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98dcdd4f694419492c0a0b6adfc3c811"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a98dcdd4f694419492c0a0b6adfc3c811">createBufferResultsToOutParamsPass</a> (const <a class="el" href="structmlir_1_1bufferization_1_1BufferResultsToOutParamsOptions.html">BufferResultsToOutParamsOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>={})</td></tr>
<tr class="memdesc:a98dcdd4f694419492c0a0b6adfc3c811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that converts memref function results to out-params.  <a href="namespacemlir_1_1bufferization.html#a98dcdd4f694419492c0a0b6adfc3c811">More...</a><br /></td></tr>
<tr class="separator:a98dcdd4f694419492c0a0b6adfc3c811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81eaa45c7ad5180067f4cffcf43e4b41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a81eaa45c7ad5180067f4cffcf43e4b41">promoteBufferResultsToOutParams</a> (ModuleOp module, const <a class="el" href="structmlir_1_1bufferization_1_1BufferResultsToOutParamsOptions.html">BufferResultsToOutParamsOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a81eaa45c7ad5180067f4cffcf43e4b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace buffers that are returned from a function with an out parameter.  <a href="namespacemlir_1_1bufferization.html#a81eaa45c7ad5180067f4cffcf43e4b41">More...</a><br /></td></tr>
<tr class="separator:a81eaa45c7ad5180067f4cffcf43e4b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef2e0a39b0ed448dd072072ac76c68e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a1ef2e0a39b0ed448dd072072ac76c68e">createDropEquivalentBufferResultsPass</a> ()</td></tr>
<tr class="memdesc:a1ef2e0a39b0ed448dd072072ac76c68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that drops memref function results that are equivalent to a function argument.  <a href="namespacemlir_1_1bufferization.html#a1ef2e0a39b0ed448dd072072ac76c68e">More...</a><br /></td></tr>
<tr class="separator:a1ef2e0a39b0ed448dd072072ac76c68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1a94d4d5cc33f606dc0309a1d0b8db"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aea1a94d4d5cc33f606dc0309a1d0b8db">createEmptyTensorToAllocTensorPass</a> ()</td></tr>
<tr class="memdesc:aea1a94d4d5cc33f606dc0309a1d0b8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass that rewrites tensor.empty to bufferization.alloc_tensor.  <a href="namespacemlir_1_1bufferization.html#aea1a94d4d5cc33f606dc0309a1d0b8db">More...</a><br /></td></tr>
<tr class="separator:aea1a94d4d5cc33f606dc0309a1d0b8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae342871cac8184abb98eb585dc44bf7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ae342871cac8184abb98eb585dc44bf7e">dropEquivalentBufferResults</a> (ModuleOp module)</td></tr>
<tr class="memdesc:ae342871cac8184abb98eb585dc44bf7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop all memref function results that are equivalent to a function argument.  <a href="namespacemlir_1_1bufferization.html#ae342871cac8184abb98eb585dc44bf7e">More...</a><br /></td></tr>
<tr class="separator:ae342871cac8184abb98eb585dc44bf7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851c8abcfd5da0332cb96347484e750e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a851c8abcfd5da0332cb96347484e750e">createFinalizingBufferizePass</a> ()</td></tr>
<tr class="memdesc:a851c8abcfd5da0332cb96347484e750e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that finalizes a partial bufferization by removing remaining bufferization.to_tensor and bufferization.to_memref operations.  <a href="namespacemlir_1_1bufferization.html#a851c8abcfd5da0332cb96347484e750e">More...</a><br /></td></tr>
<tr class="separator:a851c8abcfd5da0332cb96347484e750e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a438c09e875e0ca7b69ac35bd415812"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a8a438c09e875e0ca7b69ac35bd415812">createOneShotBufferizePass</a> ()</td></tr>
<tr class="memdesc:a8a438c09e875e0ca7b69ac35bd415812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass that bufferizes all ops that implement BufferizableOpInterface with One-Shot Bufferize.  <a href="namespacemlir_1_1bufferization.html#a8a438c09e875e0ca7b69ac35bd415812">More...</a><br /></td></tr>
<tr class="separator:a8a438c09e875e0ca7b69ac35bd415812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6db8eb7bfe512d8fdd2a3bcc14767b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a0e6db8eb7bfe512d8fdd2a3bcc14767b">createOneShotBufferizePass</a> (const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a0e6db8eb7bfe512d8fdd2a3bcc14767b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass that bufferizes all ops that implement BufferizableOpInterface with One-Shot Bufferize and the specified bufferization options.  <a href="namespacemlir_1_1bufferization.html#a0e6db8eb7bfe512d8fdd2a3bcc14767b">More...</a><br /></td></tr>
<tr class="separator:a0e6db8eb7bfe512d8fdd2a3bcc14767b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd135f127fc250fb96fd3817f98ab9d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aadd135f127fc250fb96fd3817f98ab9d">createPromoteBuffersToStackPass</a> (unsigned maxAllocSizeInBytes=1024, unsigned maxRankOfAllocatedMemRef=1)</td></tr>
<tr class="memdesc:aadd135f127fc250fb96fd3817f98ab9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that promotes heap-based allocations to stack-based ones.  <a href="namespacemlir_1_1bufferization.html#aadd135f127fc250fb96fd3817f98ab9d">More...</a><br /></td></tr>
<tr class="separator:aadd135f127fc250fb96fd3817f98ab9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a9fdbeb428d3911ee0fbfbc3854283"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a62a9fdbeb428d3911ee0fbfbc3854283">createPromoteBuffersToStackPass</a> (std::function&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>)&gt; isSmallAlloc)</td></tr>
<tr class="memdesc:a62a9fdbeb428d3911ee0fbfbc3854283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that promotes heap-based allocations to stack-based ones.  <a href="namespacemlir_1_1bufferization.html#a62a9fdbeb428d3911ee0fbfbc3854283">More...</a><br /></td></tr>
<tr class="separator:a62a9fdbeb428d3911ee0fbfbc3854283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d40b6466dba71592273b41aa9abd340"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a9d40b6466dba71592273b41aa9abd340">createEmptyTensorEliminationPass</a> ()</td></tr>
<tr class="memdesc:a9d40b6466dba71592273b41aa9abd340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass that tries to eliminate tensor.empty ops that are anchored on insert_slice ops.  <a href="namespacemlir_1_1bufferization.html#a9d40b6466dba71592273b41aa9abd340">More...</a><br /></td></tr>
<tr class="separator:a9d40b6466dba71592273b41aa9abd340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2bfa7b904999fa85ab33b9c7ad28e0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aeb2bfa7b904999fa85ab33b9c7ad28e0">createBufferizationBufferizePass</a> ()</td></tr>
<tr class="memdesc:aeb2bfa7b904999fa85ab33b9c7ad28e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass that bufferizes ops from the bufferization dialect.  <a href="namespacemlir_1_1bufferization.html#aeb2bfa7b904999fa85ab33b9c7ad28e0">More...</a><br /></td></tr>
<tr class="separator:aeb2bfa7b904999fa85ab33b9c7ad28e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce232cd9976131084415016178a7c5d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a2ce232cd9976131084415016178a7c5d">createTensorCopyInsertionPass</a> ()</td></tr>
<tr class="memdesc:a2ce232cd9976131084415016178a7c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass that resolves out-of-place tensor OpOperands with copies.  <a href="namespacemlir_1_1bufferization.html#a2ce232cd9976131084415016178a7c5d">More...</a><br /></td></tr>
<tr class="separator:a2ce232cd9976131084415016178a7c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09180af744e9d705a95d19ab262cdd5c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a09180af744e9d705a95d19ab262cdd5c">createTensorCopyInsertionPass</a> (const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="separator:a09180af744e9d705a95d19ab262cdd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aabacf83eaecd5d832fcb2337eab274"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a6aabacf83eaecd5d832fcb2337eab274">registerAllocationOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a6aabacf83eaecd5d832fcb2337eab274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register external models for AllocationOpInterface.  <a href="namespacemlir_1_1bufferization.html#a6aabacf83eaecd5d832fcb2337eab274">More...</a><br /></td></tr>
<tr class="separator:a6aabacf83eaecd5d832fcb2337eab274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9448ba020d4c7bb4c3c74891e11c8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a2d9448ba020d4c7bb4c3c74891e11c8b">eliminateEmptyTensors</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html">bufferization::AnalysisState</a> &amp;state, <a class="el" href="namespacemlir_1_1bufferization.html#a9f555e6310adbe13cf6fd0163a345f65">AnchorMatchFn</a> anchorMatchFunc, <a class="el" href="namespacemlir_1_1bufferization.html#afad8a6459f58b1a5a6772110aac8d93d">RewriteFn</a> rewriteFunc)</td></tr>
<tr class="memdesc:a2d9448ba020d4c7bb4c3c74891e11c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to eliminate tensor::EmptyOps inside <code>op</code>.  <a href="namespacemlir_1_1bufferization.html#a2d9448ba020d4c7bb4c3c74891e11c8b">More...</a><br /></td></tr>
<tr class="separator:a2d9448ba020d4c7bb4c3c74891e11c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b81d2a47e5180ba79b3b7ca6574a43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a21b81d2a47e5180ba79b3b7ca6574a43">insertSliceAnchoredEmptyTensorEliminationStep</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html">bufferization::AnalysisState</a> &amp;state)</td></tr>
<tr class="memdesc:a21b81d2a47e5180ba79b3b7ca6574a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to eliminate tensor::EmptyOps inside <code>op</code> that are anchored on an InsertSliceOp, i.e., if it is eventually inserted into another tensor (and some other conditions are met).  <a href="namespacemlir_1_1bufferization.html#a21b81d2a47e5180ba79b3b7ca6574a43">More...</a><br /></td></tr>
<tr class="separator:a21b81d2a47e5180ba79b3b7ca6574a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9484c0412ad971ba0aba5e434d6ab67b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a9484c0412ad971ba0aba5e434d6ab67b">insertTensorCopies</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a9484c0412ad971ba0aba5e434d6ab67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve RaW and other conflicts by inserting bufferization.alloc_tensor ops.  <a href="namespacemlir_1_1bufferization.html#a9484c0412ad971ba0aba5e434d6ab67b">More...</a><br /></td></tr>
<tr class="separator:a9484c0412ad971ba0aba5e434d6ab67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa163b2955215e8f16e7105f5caa3cb27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aa163b2955215e8f16e7105f5caa3cb27">insertTensorCopies</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html">AnalysisState</a> &amp;state)</td></tr>
<tr class="memdesc:aa163b2955215e8f16e7105f5caa3cb27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve RaW and other conflicts by inserting bufferization.alloc_tensor ops.  <a href="namespacemlir_1_1bufferization.html#aa163b2955215e8f16e7105f5caa3cb27">More...</a><br /></td></tr>
<tr class="separator:aa163b2955215e8f16e7105f5caa3cb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41285ff4926c59c44f84d013df399b83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a41285ff4926c59c44f84d013df399b83">populateEmptyTensorToAllocTensorPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a41285ff4926c59c44f84d013df399b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns to lower tensor.empty ops to bufferization.alloc_tensor ops.  <a href="namespacemlir_1_1bufferization.html#a41285ff4926c59c44f84d013df399b83">More...</a><br /></td></tr>
<tr class="separator:a41285ff4926c59c44f84d013df399b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a9f555e6310adbe13cf6fd0163a345f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f555e6310adbe13cf6fd0163a345f65">&#9670;&nbsp;</a></span>AnchorMatchFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1bufferization.html#a9f555e6310adbe13cf6fd0163a345f65">mlir::bufferization::AnchorMatchFn</a> = typedef std::function&lt;bool(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that matches anchor OpOperands for tensor::EmptyOp elimination. </p>
<p>If an <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> is matched, the function should populate the SmallVector with all values that are needed during <code>RewriteFn</code> to produce the replacement value. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Bufferization_2Transforms_2Transforms_8h_source.html#l00024">24</a> of file <a class="el" href="mlir_2Dialect_2Bufferization_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="afad8a6459f58b1a5a6772110aac8d93d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad8a6459f58b1a5a6772110aac8d93d">&#9670;&nbsp;</a></span>RewriteFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1bufferization.html#afad8a6459f58b1a5a6772110aac8d93d">mlir::bufferization::RewriteFn</a> = typedef std::function&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that rewrites matched anchors. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Bufferization_2Transforms_2Transforms_8h_source.html#l00027">27</a> of file <a class="el" href="mlir_2Dialect_2Bufferization_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="afbf6d54f9e3c10b9003b66b6224b28bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf6d54f9e3c10b9003b66b6224b28bf">&#9670;&nbsp;</a></span>BufferRelation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bf">mlir::bufferization::BufferRelation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specify fine-grain relationship between buffers to enable more analysis. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afbf6d54f9e3c10b9003b66b6224b28bfa6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afbf6d54f9e3c10b9003b66b6224b28bfaafd102579f64c98e96d92a7424130605"></a>Equivalent&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8h_source.html#l00311">311</a> of file <a class="el" href="BufferizableOpInterface_8h_source.html">BufferizableOpInterface.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a84b8affbc45eb90f938f0d94b21eac45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b8affbc45eb90f938f0d94b21eac45">&#9670;&nbsp;</a></span>allocateTensorForShapedValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::bufferization::allocateTensorForShapedValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>shapedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>escape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an AllocTensorOp for the given shaped value (memref or tensor). </p>
<p>Create an AllocTensorOp for the given shaped value.</p>
<p>If <code>copy</code> is set, the shaped value is copied. Otherwise, a tensor with undefined contents is allocated. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00067">67</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00280">mlir::Type::cast()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::cast()</a>, <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00071">copy()</a>, <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="Matchers_8h_source.html#l00230">mlir::detail::enumerate()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Builders_8cpp_source.html#l00251">mlir::Builder::getBoolArrayAttr()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00618">getBufferType()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Builders_8cpp_source.html#l00212">mlir::Builder::getIntegerAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00072">mlir::Builder::getIntegerType()</a>, <a class="el" href="Value_8h_source.html#l00114">mlir::Value::getType()</a>, <a class="el" href="IR_2Types_8h_source.html#l00260">mlir::Type::isa()</a>, <a class="el" href="Value_8h_source.html#l00090">mlir::Value::isa()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00132">populateDynamicDimSizes()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00395">mlir::Operation::setAttr()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00068">mlir::succeeded()</a>.</p>

</div>
</div>
<a id="a328e7c6d8ce499626dbf57ca19e482dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328e7c6d8ce499626dbf57ca19e482dd">&#9670;&nbsp;</a></span>allocationDoesNotEscape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::bufferization::allocationDoesNotEscape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a>&#160;</td>
          <td class="paramname"><em>opResult</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if the allocation of the given op is guaranteed to not escape the containing block. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00048">48</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00375">mlir::Operation::getAttrOfType()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8h_source.html#l00454">mlir::OpResult::getResultNumber()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00385">mlir::Operation::hasAttr()</a>.</p>

</div>
</div>
<a id="ac2c5406e7ae251a2920f3a7276ea9049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c5406e7ae251a2920f3a7276ea9049">&#9670;&nbsp;</a></span>analyzeModuleOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::analyzeModuleOp </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>moduleOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze <code>moduleOp</code> and its nested ops. </p>
<p>Bufferization decisions are stored in <code>state</code>. </p>

<p class="definition">Definition at line <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00357">357</a> of file <a class="el" href="OneShotModuleBufferize_8cpp_source.html">OneShotModuleBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="FuncBufferizableOpInterfaceImpl_8h_source.html#l00064">mlir::bufferization::func_ext::FuncAnalysisState::analyzedFuncOps</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l01134">analyzeOp()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00247">equivalenceAnalysis()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="OneShotAnalysis_8h_source.html#l00142">mlir::bufferization::OneShotAnalysisState::getAliasInfo()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00081">getFuncAnalysisState()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00279">getFuncOpsOrderedByCalls()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00456">mlir::bufferization::AnalysisState::getOptions()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00022">mlir::bufferization::func_ext::FuncAnalysisState::startFunctionAnalysis()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorCopyInsertion_8cpp_source.html#l00099">insertTensorCopies()</a>.</p>

</div>
</div>
<a id="a31a195b54b8caf2857a41371be6348f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a195b54b8caf2857a41371be6348f0">&#9670;&nbsp;</a></span>analyzeOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::analyzeOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze <code>op</code> and its nested ops. </p>
<p>Bufferization decisions are stored in <code>state</code>. </p>

<p class="definition">Definition at line <a class="el" href="OneShotAnalysis_8cpp_source.html#l01134">1134</a> of file <a class="el" href="OneShotAnalysis_8cpp_source.html">OneShotAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="OneShotAnalysis_8cpp_source.html#l01053">annotateOpsWithBufferizationMarkers()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l01088">assertDestinationPassingStyle()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l01014">checkAliasInfoConsistency()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00980">equivalenceAnalysis()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00262">mlir::bufferization::OneShotAnalysisState::gatherUndefinedTensorUses()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00233">mlir::bufferization::OneShotAnalysisState::gatherYieldedTensors()</a>, <a class="el" href="OneShotAnalysis_8h_source.html#l00142">mlir::bufferization::OneShotAnalysisState::getAliasInfo()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00456">mlir::bufferization::AnalysisState::getOptions()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00426">mlir::bufferization::AnalysisState::hasDialectState()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00910">inPlaceAnalysis()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00574">mlir::Operation::walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00357">analyzeModuleOp()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00910">inPlaceAnalysis()</a>, and <a class="el" href="TensorCopyInsertion_8cpp_source.html#l00099">insertTensorCopies()</a>.</p>

</div>
</div>
<a id="aaa4e91f92d15be5a5979160e1048c381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4e91f92d15be5a5979160e1048c381">&#9670;&nbsp;</a></span>bufferizeModuleOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::bufferizeModuleOp </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>moduleOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bufferize <code>op</code> and its nested ops that implement <code>BufferizableOpInterface</code>. </p>
<p>Note: This function does not run One-Shot Analysis. No buffer copies are inserted unless <code>options.copyBeforeWrite</code> is set, in which case buffers are copied before every write. </p>

<p class="definition">Definition at line <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00403">403</a> of file <a class="el" href="OneShotModuleBufferize_8cpp_source.html">OneShotModuleBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00398">bufferizeOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00335">foldMemRefCasts()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00279">getFuncOpsOrderedByCalls()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00226">removeBufferizationAttributes()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00439">runOneShotModuleBufferize()</a>.</p>

</div>
</div>
<a id="a0834ca306715f47090a48424de0a7129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0834ca306715f47090a48424de0a7129">&#9670;&nbsp;</a></span>bufferizeOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::bufferizeOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copyBeforeWrite</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1bufferization_1_1OpFilter.html">OpFilter</a> *&#160;</td>
          <td class="paramname"><em>opFilter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bufferize <code>op</code> and its nested ops that implement <code>BufferizableOpInterface</code>. </p>
<p>If <code>copyBeforeWrite</code>, buffers are duplicated and copied before any tensor use that bufferizes to a memory write.</p>
<p>Note: In the general case, it unsafe to run with <code>copyBeforeWrite = false</code> because read-after-write conflicts may materialize during bufferization. <code>copyBeforeWrite = false</code> is safe only if the input IR is guaranteed to <em>not</em> require any out-of-place bufferization.</p>
<p>Note: This function bufferizes ops without utilizing analysis results. It can be used to implement partial bufferization passes. </p>
<p>Check the result of bufferization. Return an error if an op was not bufferized, unless partial bufferization is allowed.</p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00398">398</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00225">mlir::Operation::emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00088">foldToMemrefToTensorPair()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00147">mlir::Operation::getContext()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00050">mlir::Operation::getName()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00623">mlir::Operation::getUses()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00320">hasTensorSemantics()</a>, <a class="el" href="TensorCopyInsertion_8cpp_source.html#l00099">insertTensorCopies()</a>, <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00158">mlir::isMemoryEffectFree()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00236">mlir::bufferization::OpFilter::isOpAllowed()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca22e80e4e88a340d28d3f27ee3d9d7163">mlir::PostOrder</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00574">mlir::Operation::walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00403">bufferizeModuleOp()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l01183">runOneShotBufferize()</a>, and <a class="el" href="DenseBufferizationPass_8cpp_source.html#l00041">mlir::sparse_tensor::BufferizeDenseOpsPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="acf648dc804a1dcc39379e036051dbf82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf648dc804a1dcc39379e036051dbf82">&#9670;&nbsp;</a></span>castOrReallocMemRefValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::bufferization::castOrReallocMemRefValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to cast the given ranked MemRef-typed value to the given ranked MemRef type. </p>
<p>Insert a reallocation + copy if it cannot be statically guaranteed that a direct cast would be valid.</p>
<p>E.g., when casting from a ranked MemRef type with dynamic layout to a ranked MemRef type with static layout, it is not statically known whether the cast will succeed or not. Such <code>memref.cast</code> ops may fail at runtime. This function never generates such casts and conservatively inserts a copy.</p>
<p>This function returns <code><a class="el" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4" title="Utility function to generate a LogicalResult.">failure()</a></code> in case of unsupported casts. E.g., casts with differing element types or memory spaces. </p>

<p class="definition">Definition at line <a class="el" href="BufferizationOps_8cpp_source.html#l00027">27</a> of file <a class="el" href="BufferizationOps_8cpp_source.html">BufferizationOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00071">copy()</a>, <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8h_source.html#l00472">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00778">mlir::getStridesAndOffset()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00160">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00051">mlir::bufferization::BufferizeTypeConverter::BufferizeTypeConverter()</a>, and <a class="el" href="BufferizationOps_8cpp_source.html#l00088">foldToMemrefToTensorPair()</a>.</p>

</div>
</div>
<a id="adbadbbffeae2eddfac65c53b2f1cadba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbadbbffeae2eddfac65c53b2f1cadba">&#9670;&nbsp;</a></span>createBufferDeallocationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createBufferDeallocationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the BufferDeallocation pass to free all allocated buffers. </p>

<p class="definition">Definition at line <a class="el" href="BufferDeallocation_8cpp_source.html#l00711">711</a> of file <a class="el" href="BufferDeallocation_8cpp_source.html">BufferDeallocation.cpp</a>.</p>

</div>
</div>
<a id="a4b99b019001e22f13cbb9adaf483febe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b99b019001e22f13cbb9adaf483febe">&#9670;&nbsp;</a></span>createBufferHoistingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createBufferHoistingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that moves allocations upwards to reduce the number of required copies that are inserted during the BufferDeallocation pass. </p>

<p class="definition">Definition at line <a class="el" href="BufferOptimizations_8cpp_source.html#l00435">435</a> of file <a class="el" href="BufferOptimizations_8cpp_source.html">BufferOptimizations.cpp</a>.</p>

</div>
</div>
<a id="aeb2bfa7b904999fa85ab33b9c7ad28e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2bfa7b904999fa85ab33b9c7ad28e0">&#9670;&nbsp;</a></span>createBufferizationBufferizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createBufferizationBufferizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass that bufferizes ops from the bufferization dialect. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00295">295</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

</div>
</div>
<a id="a94f24bfd4dabfbaa35cb099c0cc78480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f24bfd4dabfbaa35cb099c0cc78480">&#9670;&nbsp;</a></span>createBufferLoopHoistingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createBufferLoopHoistingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that moves allocations upwards out of loops. </p>
<p>This avoids reallocations inside of loops. </p>

<p class="definition">Definition at line <a class="el" href="BufferOptimizations_8cpp_source.html#l00439">439</a> of file <a class="el" href="BufferOptimizations_8cpp_source.html">BufferOptimizations.cpp</a>.</p>

</div>
</div>
<a id="a98dcdd4f694419492c0a0b6adfc3c811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98dcdd4f694419492c0a0b6adfc3c811">&#9670;&nbsp;</a></span>createBufferResultsToOutParamsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createBufferResultsToOutParamsPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferResultsToOutParamsOptions.html">BufferResultsToOutParamsOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that converts memref function results to out-params. </p>

<p class="definition">Definition at line <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00221">221</a> of file <a class="el" href="BufferResultsToOutParams_8cpp_source.html">BufferResultsToOutParams.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

</div>
</div>
<a id="a1ef2e0a39b0ed448dd072072ac76c68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef2e0a39b0ed448dd072072ac76c68e">&#9670;&nbsp;</a></span>createDropEquivalentBufferResultsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createDropEquivalentBufferResultsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that drops memref function results that are equivalent to a function argument. </p>

<p class="definition">Definition at line <a class="el" href="DropEquivalentBufferResults_8cpp_source.html#l00157">157</a> of file <a class="el" href="DropEquivalentBufferResults_8cpp_source.html">DropEquivalentBufferResults.cpp</a>.</p>

</div>
</div>
<a id="a9d40b6466dba71592273b41aa9abd340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d40b6466dba71592273b41aa9abd340">&#9670;&nbsp;</a></span>createEmptyTensorEliminationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createEmptyTensorEliminationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass that tries to eliminate tensor.empty ops that are anchored on insert_slice ops. </p>

<p class="definition">Definition at line <a class="el" href="EmptyTensorElimination_8cpp_source.html#l00256">256</a> of file <a class="el" href="EmptyTensorElimination_8cpp_source.html">EmptyTensorElimination.cpp</a>.</p>

</div>
</div>
<a id="aea1a94d4d5cc33f606dc0309a1d0b8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1a94d4d5cc33f606dc0309a1d0b8db">&#9670;&nbsp;</a></span>createEmptyTensorToAllocTensorPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createEmptyTensorToAllocTensorPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass that rewrites tensor.empty to bufferization.alloc_tensor. </p>

<p class="definition">Definition at line <a class="el" href="EmptyTensorToAllocTensor_8cpp_source.html#l00068">68</a> of file <a class="el" href="EmptyTensorToAllocTensor_8cpp_source.html">EmptyTensorToAllocTensor.cpp</a>.</p>

</div>
</div>
<a id="a851c8abcfd5da0332cb96347484e750e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851c8abcfd5da0332cb96347484e750e">&#9670;&nbsp;</a></span>createFinalizingBufferizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::bufferization::createFinalizingBufferizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that finalizes a partial bufferization by removing remaining bufferization.to_tensor and bufferization.to_memref operations. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00309">309</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00052">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="a8a438c09e875e0ca7b69ac35bd415812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a438c09e875e0ca7b69ac35bd415812">&#9670;&nbsp;</a></span>createOneShotBufferizePass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createOneShotBufferizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass that bufferizes all ops that implement BufferizableOpInterface with One-Shot Bufferize. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00299">299</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

</div>
</div>
<a id="a0e6db8eb7bfe512d8fdd2a3bcc14767b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6db8eb7bfe512d8fdd2a3bcc14767b">&#9670;&nbsp;</a></span>createOneShotBufferizePass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createOneShotBufferizePass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass that bufferizes all ops that implement BufferizableOpInterface with One-Shot Bufferize and the specified bufferization options. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00303">303</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

</div>
</div>
<a id="a62a9fdbeb428d3911ee0fbfbc3854283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a9fdbeb428d3911ee0fbfbc3854283">&#9670;&nbsp;</a></span>createPromoteBuffersToStackPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createPromoteBuffersToStackPass </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;&#160;</td>
          <td class="paramname"><em>isSmallAlloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that promotes heap-based allocations to stack-based ones. </p>
<p>Only buffers smaller with <code>isSmallAlloc(alloc) == true</code> are promoted. </p>

<p class="definition">Definition at line <a class="el" href="BufferOptimizations_8cpp_source.html#l00449">449</a> of file <a class="el" href="BufferOptimizations_8cpp_source.html">BufferOptimizations.cpp</a>.</p>

</div>
</div>
<a id="aadd135f127fc250fb96fd3817f98ab9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd135f127fc250fb96fd3817f98ab9d">&#9670;&nbsp;</a></span>createPromoteBuffersToStackPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createPromoteBuffersToStackPass </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxAllocSizeInBytes</em> = <code>1024</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxRankOfAllocatedMemRef</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that promotes heap-based allocations to stack-based ones. </p>
<p>Only buffers smaller than the provided size are promoted. Dynamic shaped buffers are promoted up to the given rank. </p>

<p class="definition">Definition at line <a class="el" href="BufferOptimizations_8cpp_source.html#l00443">443</a> of file <a class="el" href="BufferOptimizations_8cpp_source.html">BufferOptimizations.cpp</a>.</p>

</div>
</div>
<a id="a2ce232cd9976131084415016178a7c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce232cd9976131084415016178a7c5d">&#9670;&nbsp;</a></span>createTensorCopyInsertionPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createTensorCopyInsertionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass that resolves out-of-place tensor OpOperands with copies. </p>

<p class="definition">Definition at line <a class="el" href="TensorCopyInsertion_8cpp_source.html#l00198">198</a> of file <a class="el" href="TensorCopyInsertion_8cpp_source.html">TensorCopyInsertion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00052">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="a09180af744e9d705a95d19ab262cdd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09180af744e9d705a95d19ab262cdd5c">&#9670;&nbsp;</a></span>createTensorCopyInsertionPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createTensorCopyInsertionPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TensorCopyInsertion_8cpp_source.html#l00202">202</a> of file <a class="el" href="TensorCopyInsertion_8cpp_source.html">TensorCopyInsertion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

</div>
</div>
<a id="a8e9fe9c9234e2d22a86553a393f074d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9fe9c9234e2d22a86553a393f074d8">&#9670;&nbsp;</a></span>deallocateBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::deallocateBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run buffer deallocation. </p>

<p class="definition">Definition at line <a class="el" href="BufferDeallocation_8cpp_source.html#l00664">664</a> of file <a class="el" href="BufferDeallocation_8cpp_source.html">BufferDeallocation.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00051">mlir::WalkResult::advance()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00225">mlir::Operation::emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Visitors_8h_source.html#l00050">mlir::WalkResult::interrupt()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, <a class="el" href="BufferDeallocation_8cpp_source.html#l00090">validateSupportedControlFlow()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00574">mlir::Operation::walk()</a>, and <a class="el" href="Visitors_8h_source.html#l00055">mlir::WalkResult::wasInterrupted()</a>.</p>

</div>
</div>
<a id="ae342871cac8184abb98eb585dc44bf7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae342871cac8184abb98eb585dc44bf7e">&#9670;&nbsp;</a></span>dropEquivalentBufferResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::dropEquivalentBufferResults </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop all memref function results that are equivalent to a function argument. </p>

<p class="definition">Definition at line <a class="el" href="DropEquivalentBufferResults_8cpp_source.html#l00070">70</a> of file <a class="el" href="DropEquivalentBufferResults_8cpp_source.html">DropEquivalentBufferResults.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00051">mlir::WalkResult::advance()</a>, <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="Matchers_8h_source.html#l00230">mlir::detail::enumerate()</a>, <a class="el" href="DropEquivalentBufferResults_8cpp_source.html#l00048">getAssumedUniqueReturnOp()</a>, <a class="el" href="DropEquivalentBufferResults_8cpp_source.html#l00061">getCalledFunction()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8h_source.html#l00114">mlir::Value::getType()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00261">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="Builders_8h_source.html#l00350">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="Visitors_8h_source.html#l00052">mlir::WalkResult::skip()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="a2d9448ba020d4c7bb4c3c74891e11c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9448ba020d4c7bb4c3c74891e11c8b">&#9670;&nbsp;</a></span>eliminateEmptyTensors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::eliminateEmptyTensors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html">bufferization::AnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1bufferization.html#a9f555e6310adbe13cf6fd0163a345f65">AnchorMatchFn</a>&#160;</td>
          <td class="paramname"><em>anchorMatchFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1bufferization.html#afad8a6459f58b1a5a6772110aac8d93d">RewriteFn</a>&#160;</td>
          <td class="paramname"><em>rewriteFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to eliminate tensor::EmptyOps inside <code>op</code>. </p>
<ul>
<li><code>rewriteFunc</code> generates the replacement for the tensor::EmptyOp.</li>
<li><p class="startli">Only tensor::EmptyOps that are anchored on a matching <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> as per <code>anchorMatchFunc</code> are considered. "Anchored" means that there is a path on the reverse SSA use-def chain, starting from the <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> and always following the aliasing <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a>, that eventually ends at a single tensor::EmptyOp.</p>
<p class="startli">A tensor::EmptyOp is replaced with the result of <code>rewriteFunc</code> if it is anchored on a matching <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a>. "Anchored" means that there is a path on the reverse SSA use-def chain, starting from the <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> and always following the aliasing <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a>, that eventually ends at a single tensor::EmptyOp. </p>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="EmptyTensorElimination_8cpp_source.html#l00107">107</a> of file <a class="el" href="EmptyTensorElimination_8cpp_source.html">EmptyTensorElimination.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00051">mlir::WalkResult::advance()</a>, <a class="el" href="EmptyTensorElimination_8cpp_source.html#l00063">findValidInsertionPoint()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8cpp_source.html#l00026">mlir::Value::getLoc()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00300">mlir::Operation::getOpOperands()</a>, <a class="el" href="Value_8h_source.html#l00114">mlir::Value::getType()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00261">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="Builders_8h_source.html#l00350">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="Visitors_8h_source.html#l00052">mlir::WalkResult::skip()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00574">mlir::Operation::walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="EmptyTensorElimination_8cpp_source.html#l00191">insertSliceAnchoredEmptyTensorEliminationStep()</a>.</p>

</div>
</div>
<a id="a64f68223b1811698fd85780df73c4fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f68223b1811698fd85780df73c4fde">&#9670;&nbsp;</a></span>foldToMemrefToTensorPair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::foldToMemrefToTensorPair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ToMemrefOp&#160;</td>
          <td class="paramname"><em>toMemref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to fold to_memref(to_tensor(x)). </p>
<p>If x's type and the result type of the to_memref op are different, a memref.cast is needed. </p>

<p class="definition">Definition at line <a class="el" href="BufferizationOps_8cpp_source.html#l00088">88</a> of file <a class="el" href="BufferizationOps_8cpp_source.html">BufferizationOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="BufferizationOps_8cpp_source.html#l00027">castOrReallocMemRefValue()</a>, <a class="el" href="IR_2Types_8h_source.html#l00270">mlir::Type::dyn_cast()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00261">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00451">mlir::RewriterBase::replaceOpWithNewOp()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00398">bufferizeOp()</a>.</p>

</div>
</div>
<a id="abf241364e9dfd1def82141c75035f4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf241364e9dfd1def82141c75035f4b0">&#9670;&nbsp;</a></span>getBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::bufferization::getBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup the buffer for the given value. </p>
<p>If the value was not bufferized yet, wrap it in a ToMemrefOp. Otherwise, it is the result of a ToTensorOp, from which the memref operand is returned. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00560">560</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00551">ensureToMemrefOpIsValid()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00618">getBufferType()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00309">setInsertionPointAfter()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00160">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00259">mlir::bufferization::func_ext::CallOpInterface::bufferize()</a>.</p>

</div>
</div>
<a id="aadc2d902756788c32c33244776d141c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc2d902756788c32c33244776d141c7">&#9670;&nbsp;</a></span>getBufferType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> &gt; mlir::bufferization::getBufferType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the buffer type for a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> (tensor) after bufferization without bufferizing any IR. </p>
<p>Return the buffer type for a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> (tensor) after bufferization.</p>
<p>Note: It should be sufficient to call <code><a class="el" href="namespacemlir_1_1bufferization.html#abf241364e9dfd1def82141c75035f4b0" title="Lookup the buffer for the given value.">getBuffer()</a>-&gt;getType()</code> in most cases. However, when a buffer type should be predicted without modifying any IR, this function can be used.</p>
<p>This function is a wrapper around BufferizableOpInterface::getBufferType. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00618">618</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00160">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00067">allocateTensorForShapedValue()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00583">mlir::bufferization::detail::defaultGetBufferType()</a>, and <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00560">getBuffer()</a>.</p>

</div>
</div>
<a id="a2de4a7671524f168224c818658f03bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de4a7671524f168224c818658f03bfb">&#9670;&nbsp;</a></span>getBufferType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> &gt; AllocTensorOp::getBufferType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fixedTypes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the buffer type for a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> (tensor) after bufferization without bufferizing any IR. </p>
<p>Return the buffer type for a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> (tensor) after bufferization.</p>
<p>If at any point during the type computation, the type of a value in <code>fixedTypes</code> in required, the mapped type is used.</p>
<p>Note: It should be sufficient to call <code><a class="el" href="namespacemlir_1_1bufferization.html#abf241364e9dfd1def82141c75035f4b0" title="Lookup the buffer for the given value.">getBuffer()</a>-&gt;getType()</code> in most cases. However, when a buffer type should be predicted without modifying any IR, this function can be used.</p>
<p>This function is a wrapper around BufferizableOpInterface::getBufferType. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00624">624</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00225">mlir::Operation::emitError()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00731">getMemRefType()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00042">getOwnerOfValue()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00160">value</a>.</p>

</div>
</div>
<a id="aaaa111ae7f728e7e3a776a2a67a177fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa111ae7f728e7e3a776a2a67a177fb">&#9670;&nbsp;</a></span>getGlobalFor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; memref::GlobalOp &gt; mlir::bufferization::getGlobalFor </td>
          <td>(</td>
          <td class="paramtype">arith::ConstantOp&#160;</td>
          <td class="paramname"><em>constantOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BufferUtils_8cpp_source.html#l00149">149</a> of file <a class="el" href="BufferUtils_8cpp_source.html">BufferUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02943">mlir::TypeConverter::convertType()</a>, <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Builders_8cpp_source.html#l00070">mlir::Builder::getI64Type()</a>, <a class="el" href="IR_2Region_8h_source.html#l00172">mlir::Region::getOps()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00486">mlir::Operation::getRegion()</a>, <a class="el" href="Builders_8cpp_source.html#l00243">mlir::Builder::getStringAttr()</a>, and <a class="el" href="SymbolTable_8cpp_source.html#l00170">mlir::SymbolTable::insert()</a>.</p>

</div>
</div>
<a id="a0dbae70b4a9558ae3509d2ac49718962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dbae70b4a9558ae3509d2ac49718962">&#9670;&nbsp;</a></span>getMemRefType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> mlir::bufferization::getMemRefType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefLayoutAttrInterface&#160;</td>
          <td class="paramname"><em>layout</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a MemRefType to which the type of the given value can be bufferized. </p>
<p>If possible, op bufferization implementations should not use this function and instead infer precise memref types for tensor results by themselves.</p>
<p>Unless a layout map was specified, <code>options.unknownTypeConverterFn</code> determines what kind of layout map will be used. For best composability (without copies), the fully dynamic layout map is used by default.</p>
<p>Note: Canonicalization patterns could clean up layout maps and infer more precise layout maps after bufferization. However, many possible canonicalizations are currently not implemented. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00731">731</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00160">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00583">mlir::bufferization::detail::defaultGetBufferType()</a>, and <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00624">getBufferType()</a>.</p>

</div>
</div>
<a id="a99605bbd53f319ef2f0d98246054b995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99605bbd53f319ef2f0d98246054b995">&#9670;&nbsp;</a></span>getMemRefTypeWithFullyDynamicLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> mlir::bufferization::getMemRefTypeWithFullyDynamicLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TensorType.html">TensorType</a>&#160;</td>
          <td class="paramname"><em>tensorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a MemRef type with fully dynamic layout. </p>
<p>If the given tensor type is unranked, return an unranked MemRef type. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00758">758</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00280">mlir::Type::cast()</a>, <a class="el" href="IR_2Types_8h_source.html#l00270">mlir::Type::dyn_cast()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00019">mlir::Type::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00392">mlir::bufferization::func_ext::FuncOpInterface::bufferize()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00261">defaultUnknownTypeConverter()</a>, and <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00064">mlir::bufferization::func_ext::getBufferizedFunctionArgType()</a>.</p>

</div>
</div>
<a id="a30322c8e4f431c112e5bff79de859003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30322c8e4f431c112e5bff79de859003">&#9670;&nbsp;</a></span>getMemRefTypeWithStaticIdentityLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> mlir::bufferization::getMemRefTypeWithStaticIdentityLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TensorType.html">TensorType</a>&#160;</td>
          <td class="paramname"><em>tensorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a MemRef type with a static identity layout (i.e., no layout map). </p>
<p>If the given tensor type is unranked, return an unranked MemRef type. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00783">783</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00280">mlir::Type::cast()</a>, <a class="el" href="IR_2Types_8h_source.html#l00270">mlir::Type::dyn_cast()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00019">mlir::Type::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00392">mlir::bufferization::func_ext::FuncOpInterface::bufferize()</a>, <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00028">getBufferizationOptions()</a>, <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00064">mlir::bufferization::func_ext::getBufferizedFunctionArgType()</a>, and <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00505">getPartialBufferizationOptions()</a>.</p>

</div>
</div>
<a id="a25ed0ccb4e307d98675ecab129feddf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ed0ccb4e307d98675ecab129feddf5">&#9670;&nbsp;</a></span>getOwnerOfValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * mlir::bufferization::getOwnerOfValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the owner of the given value. </p>
<p>In case of a <a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block.">BlockArgument</a> that is the owner of the block. In case of an <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> that is the defining op. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00042">42</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="InterfaceSupport_8h_source.html#l00160">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00583">mlir::bufferization::detail::defaultGetBufferType()</a>, and <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00624">getBufferType()</a>.</p>

</div>
</div>
<a id="ac36c97b27b691ad7fcee01d70ca143a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac36c97b27b691ad7fcee01d70ca143a9">&#9670;&nbsp;</a></span>getPartialBufferizationOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> mlir::bufferization::getPartialBufferizationOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00505">505</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00783">getMemRefTypeWithStaticIdentityLayout()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00160">value</a>.</p>

</div>
</div>
<a id="a21b81d2a47e5180ba79b3b7ca6574a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b81d2a47e5180ba79b3b7ca6574a43">&#9670;&nbsp;</a></span>insertSliceAnchoredEmptyTensorEliminationStep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::insertSliceAnchoredEmptyTensorEliminationStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html">bufferization::AnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to eliminate tensor::EmptyOps inside <code>op</code> that are anchored on an InsertSliceOp, i.e., if it is eventually inserted into another tensor (and some other conditions are met). </p>
<p>Try to eliminate tensor::EmptyOps inside <code>op</code>.</p>
<p>An tensor::EmptyOp can be eliminated if it is eventually inserted into another tensor (and some other conditions are met).</p>
<p>E.g.: %0 = tensor.empty() %1 = linalg.fill(cst, %0) {inplace = [true]} %2 = tensor.insert_slice %1 into t[10][20][1]</p>
<p>tensor::EmptyOp elimination will try to fill t inplace instead of filling a new allocation %0 and inserting it into t. This is done by replacing the tensor::EmptyOp with:</p>
<p>%0 = tensor.extract_slice t[10][20][1]</p>
<p>The analysis looks for matching ExtractSliceOp/InsertSliceOp pairs and lets those bufferize inplace in the absence of other conflicts.</p>
<p>Starting from an InsertSliceOp, an tensor::EmptyOp at the end of the insert source's reverse use-def chain is eliminated if:</p><ul>
<li>On the reverse use-def chain path from the InsertSliceOp to the tensor::EmptyOp, all ops were decided to bufferize inplace and the buffer relation is "equivalent" (TODO: can be relaxed if needed).</li>
<li>The reverse use-def chain has exactly one end, which is the tensor::EmptyOp. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="EmptyTensorElimination_8cpp_source.html#l00191">191</a> of file <a class="el" href="EmptyTensorElimination_8cpp_source.html">EmptyTensorElimination.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="EmptyTensorElimination_8cpp_source.html#l00107">eliminateEmptyTensors()</a>, <a class="el" href="UseDefLists_8h_source.html#l00040">mlir::detail::IROperandBase::getOwner()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00324">mlir::Operation::getResult()</a>.</p>

</div>
</div>
<a id="aa163b2955215e8f16e7105f5caa3cb27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa163b2955215e8f16e7105f5caa3cb27">&#9670;&nbsp;</a></span>insertTensorCopies() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::insertTensorCopies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html">AnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve RaW and other conflicts by inserting bufferization.alloc_tensor ops. </p>
<p>After applying this transform, the IR can be bufferized without inserting additional buffer allocations. </p>

<p class="definition">Definition at line <a class="el" href="TensorCopyInsertion_8cpp_source.html#l00123">123</a> of file <a class="el" href="TensorCopyInsertion_8cpp_source.html">TensorCopyInsertion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00051">mlir::WalkResult::advance()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="Builders_8cpp_source.html#l00251">mlir::Builder::getBoolArrayAttr()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00147">mlir::Operation::getContext()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00456">mlir::bufferization::AnalysisState::getOptions()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00385">mlir::Operation::hasAttr()</a>, <a class="el" href="Visitors_8h_source.html#l00050">mlir::WalkResult::interrupt()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00395">mlir::Operation::setAttr()</a>, <a class="el" href="Builders_8h_source.html#l00350">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="Visitors_8h_source.html#l00052">mlir::WalkResult::skip()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00574">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="a9484c0412ad971ba0aba5e434d6ab67b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9484c0412ad971ba0aba5e434d6ab67b">&#9670;&nbsp;</a></span>insertTensorCopies() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::insertTensorCopies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve RaW and other conflicts by inserting bufferization.alloc_tensor ops. </p>
<p>After applying this transform, the IR can be bufferized without inserting additional buffer allocations. </p>

<p class="definition">Definition at line <a class="el" href="TensorCopyInsertion_8cpp_source.html#l00099">99</a> of file <a class="el" href="TensorCopyInsertion_8cpp_source.html">TensorCopyInsertion.cpp</a>.</p>

<p class="reference">References <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00357">analyzeModuleOp()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l01134">analyzeOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, <a class="el" href="TensorCopyInsertion_8cpp_source.html#l00045">resolveUsesInRepetitiveRegions()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00398">bufferizeOp()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l01183">runOneShotBufferize()</a>, and <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00439">runOneShotModuleBufferize()</a>.</p>

</div>
</div>
<a id="aa24e592182e0b88ede8e85dbc3dcac5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa24e592182e0b88ede8e85dbc3dcac5e">&#9670;&nbsp;</a></span>isFunctionArgument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::bufferization::isFunctionArgument </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if the given value is a <a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block.">BlockArgument</a> of a func::FuncOp. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00724">724</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="InterfaceSupport_8h_source.html#l00160">value</a>.</p>

</div>
</div>
<a id="a6223871e93de2dbc611e8e54c5e4fb3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6223871e93de2dbc611e8e54c5e4fb3b">&#9670;&nbsp;</a></span>populateBufferizeMaterializationLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::populateBufferizeMaterializationLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks ops used by bufferization for type conversion materializations as "legal" in the given <a class="el" href="classmlir_1_1ConversionTarget.html" title="This class describes a specific conversion target.">ConversionTarget</a>. </p>
<p>This function should be called by all bufferization passes using <a class="el" href="classmlir_1_1bufferization_1_1BufferizeTypeConverter.html" title="A helper type converter class that automatically populates the relevant materializations and type con...">BufferizeTypeConverter</a> so that materializations work properly. One exception is bufferization passes doing "full" conversions, where it can be desirable for even the materializations to remain illegal so that they are eliminated, such as via the patterns in populateEliminateBufferizeMaterializationsPatterns. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00091">91</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00701">mlir::ConversionTarget::addLegalOp()</a>.</p>

</div>
</div>
<a id="af7726e480700dfb860214b275d6a396d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7726e480700dfb860214b275d6a396d">&#9670;&nbsp;</a></span>populateDynamicDimSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::populateDynamicDimSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>shapedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dynamicDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate <code>dynamicDims</code> with tensor::DimOp / memref::DimOp results for all dynamic dimensions of the given shaped value. </p>

<p class="definition">Definition at line <a class="el" href="BufferizationOps_8cpp_source.html#l00132">132</a> of file <a class="el" href="BufferizationOps_8cpp_source.html">BufferizationOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00280">mlir::Type::cast()</a>, <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, and <a class="el" href="Value_8h_source.html#l00114">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00067">allocateTensorForShapedValue()</a>.</p>

</div>
</div>
<a id="a22345dcd836dbc3216a89bbd4ce26821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22345dcd836dbc3216a89bbd4ce26821">&#9670;&nbsp;</a></span>populateEliminateBufferizeMaterializationsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::populateEliminateBufferizeMaterializationsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1BufferizeTypeConverter.html">BufferizeTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns to eliminate bufferize materializations. </p>
<p>In particular, these are the tensor_load/buffer_cast ops. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00128">128</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01587">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01563">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a41285ff4926c59c44f84d013df399b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41285ff4926c59c44f84d013df399b83">&#9670;&nbsp;</a></span>populateEmptyTensorToAllocTensorPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::populateEmptyTensorToAllocTensorPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns to lower tensor.empty ops to bufferization.alloc_tensor ops. </p>

<p class="definition">Definition at line <a class="el" href="EmptyTensorToAllocTensor_8cpp_source.html#l00054">54</a> of file <a class="el" href="EmptyTensorToAllocTensor_8cpp_source.html">EmptyTensorToAllocTensor.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01563">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01666">mlir::RewritePatternSet::insert()</a>.</p>

</div>
</div>
<a id="a81eaa45c7ad5180067f4cffcf43e4b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81eaa45c7ad5180067f4cffcf43e4b41">&#9670;&nbsp;</a></span>promoteBufferResultsToOutParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::promoteBufferResultsToOutParams </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferResultsToOutParamsOptions.html">BufferResultsToOutParamsOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace buffers that are returned from a function with an out parameter. </p>
<p>Also update all call sites. </p>

<p class="definition">Definition at line <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00184">184</a> of file <a class="el" href="BufferResultsToOutParams_8cpp_source.html">BufferResultsToOutParams.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00123">updateCalls()</a>, <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00048">updateFuncOp()</a>, and <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00100">updateReturnOps()</a>.</p>

</div>
</div>
<a id="a6aabacf83eaecd5d832fcb2337eab274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aabacf83eaecd5d832fcb2337eab274">&#9670;&nbsp;</a></span>registerAllocationOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::registerAllocationOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register external models for AllocationOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="BufferDeallocation_8cpp_source.html#l00700">700</a> of file <a class="el" href="BufferDeallocation_8cpp_source.html">BufferDeallocation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00179">mlir::DialectRegistry::addExtension()</a>.</p>

</div>
</div>
<a id="a2b2d5a6d2e5ab89ec76a879d71e32a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2d5a6d2e5ab89ec76a879d71e32a36">&#9670;&nbsp;</a></span>registerTransformDialectExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::registerTransformDialectExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BufferizationTransformOps_8cpp_source.html#l00102">102</a> of file <a class="el" href="BufferizationTransformOps_8cpp_source.html">BufferizationTransformOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00185">mlir::DialectRegistry::addExtensions()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllDialects_8h_source.html#l00075">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a05561ae5b9cceea1c45832340484ad6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05561ae5b9cceea1c45832340484ad6b">&#9670;&nbsp;</a></span>replaceOpWithBufferizedValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::replaceOpWithBufferizedValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace an op with replacement values. </p>
<p>The op is deleted. Tensor OpResults must be replaced with memref values. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00648">648</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="Value_8cpp_source.html#l00026">mlir::Value::getLoc()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00321">mlir::Operation::getNumResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00337">mlir::Operation::getOpResults()</a>, <a class="el" href="Value_8h_source.html#l00114">mlir::Value::getType()</a>, <a class="el" href="IR_2Types_8h_source.html#l00260">mlir::Type::isa()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00261">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="Builders_8h_source.html#l00364">mlir::OpBuilder::setInsertionPointAfter()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00259">mlir::bufferization::func_ext::CallOpInterface::bufferize()</a>, and <a class="el" href="BufferizableOpInterface_8h_source.html#l00523">replaceOpWithNewBufferizedOp()</a>.</p>

</div>
</div>
<a id="a91366abfb8d491ea5701260487518959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91366abfb8d491ea5701260487518959">&#9670;&nbsp;</a></span>replaceOpWithNewBufferizedOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpTy mlir::bufferization::replaceOpWithNewBufferizedOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace an op with a new op. </p>
<p>The new op must have the same number of results as the replaced op. The new op may not return any tensor values. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8h_source.html#l00523">523</a> of file <a class="el" href="BufferizableOpInterface_8h_source.html">BufferizableOpInterface.h</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00154">mlir::Operation::getLoc()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00332">mlir::Operation::getResults()</a>, and <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00648">replaceOpWithBufferizedValues()</a>.</p>

</div>
</div>
<a id="a44fea54bba0c4c111425bdad3167e836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44fea54bba0c4c111425bdad3167e836">&#9670;&nbsp;</a></span>runOneShotBufferize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::runOneShotBufferize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run One-Shot Bufferize on the given op: Analysis + Bufferization. </p>

<p class="definition">Definition at line <a class="el" href="OneShotAnalysis_8cpp_source.html#l01183">1183</a> of file <a class="el" href="OneShotAnalysis_8cpp_source.html">OneShotAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00398">bufferizeOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="TensorCopyInsertion_8cpp_source.html#l00099">insertTensorCopies()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="a01516f6d5024ab7f61f78049b938595e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01516f6d5024ab7f61f78049b938595e">&#9670;&nbsp;</a></span>runOneShotModuleBufferize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::runOneShotModuleBufferize </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>moduleOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">bufferization::OneShotBufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run One-Shot Module Bufferization on the given module. </p>
<p>Performs a simple function call analysis to determine which function arguments are inplaceable. Then analyzes and bufferizes FuncOps one-by-one with One-Shot Bufferize. </p>

<p class="definition">Definition at line <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00439">439</a> of file <a class="el" href="OneShotModuleBufferize_8cpp_source.html">OneShotModuleBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00403">bufferizeModuleOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="TensorCopyInsertion_8cpp_source.html#l00099">insertTensorCopies()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="a6db18d8594be09f305df7fc8cc2afedb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db18d8594be09f305df7fc8cc2afedb">&#9670;&nbsp;</a></span>shouldDeallocateOpResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::bufferization::shouldDeallocateOpResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a>&#160;</td>
          <td class="paramname"><em>opResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if the buffer of given <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> should be deallocated. </p>
<p>This function should be called during <code>BufferizableOpInterface::bufferize</code> implementations that allocate a new buffer for the given <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a>. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00209">209</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Attributes_8h_source.html#l00137">mlir::Attribute::cast()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00371">mlir::Operation::getAttr()</a>, <a class="el" href="Value_8h_source.html#l00451">mlir::OpResult::getOwner()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00385">mlir::Operation::hasAttr()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00507">mlir::bufferization::AnalysisState::isTensorYielded()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 17 2022 20:37:49 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
