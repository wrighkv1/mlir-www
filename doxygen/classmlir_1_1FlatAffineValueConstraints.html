<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::FlatAffineValueConstraints Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">16.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classmlir_1_1FlatAffineValueConstraints-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::FlatAffineValueConstraints Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html" title="FlatAffineValueConstraints represents an extension of IntegerPolyhedron where each non-local variable...">FlatAffineValueConstraints</a> represents an extension of IntegerPolyhedron where each non-local variable can have an SSA <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> attached to it.  
 <a href="classmlir_1_1FlatAffineValueConstraints.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="AffineStructures_8h_source.html">mlir/Dialect/Affine/Analysis/AffineStructures.h</a>&quot;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for mlir::FlatAffineValueConstraints:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classmlir_1_1FlatAffineValueConstraints__inherit__graph.png" border="0" usemap="#amlir_1_1FlatAffineValueConstraints_inherit__map" alt="Inheritance graph"/></div>
<map name="amlir_1_1FlatAffineValueConstraints_inherit__map" id="amlir_1_1FlatAffineValueConstraints_inherit__map">
<area shape="rect" title="FlatAffineValueConstraints represents an extension of IntegerPolyhedron where each non&#45;local variable..." alt="" coords="5,184,235,211"/>
<area shape="rect" href="classmlir_1_1FlatAffineRelation.html" title="A FlatAffineRelation represents a set of ordered pairs (domain &#45;&gt; range) where &quot;domain&quot; and &quot;range&quot; a..." alt="" coords="33,259,207,285"/>
<area shape="rect" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html" title="An IntegerPolyhedron represents the set of points from a PresburgerSpace that satisfy a list of affin..." alt="" coords="30,95,210,136"/>
<area shape="rect" href="classmlir_1_1presburger_1_1IntegerRelation.html" title="An IntegerRelation represents the set of points from a PresburgerSpace that satisfy a list of affine ..." alt="" coords="30,5,210,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for mlir::FlatAffineValueConstraints:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classmlir_1_1FlatAffineValueConstraints__coll__graph.png" border="0" usemap="#amlir_1_1FlatAffineValueConstraints_coll__map" alt="Collaboration graph"/></div>
<map name="amlir_1_1FlatAffineValueConstraints_coll__map" id="amlir_1_1FlatAffineValueConstraints_coll__map">
<area shape="rect" title="FlatAffineValueConstraints represents an extension of IntegerPolyhedron where each non&#45;local variable..." alt="" coords="1208,95,1437,121"/>
<area shape="rect" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html" title="An IntegerPolyhedron represents the set of points from a PresburgerSpace that satisfy a list of affin..." alt="" coords="932,50,1112,91"/>
<area shape="rect" href="classmlir_1_1presburger_1_1IntegerRelation.html" title="An IntegerRelation represents the set of points from a PresburgerSpace that satisfy a list of affine ..." alt="" coords="551,50,731,91"/>
<area shape="rect" href="classmlir_1_1presburger_1_1Matrix.html" title="This is a class to represent a resizable matrix." alt="" coords="235,5,411,32"/>
<area shape="rect" href="classmlir_1_1presburger_1_1PresburgerSpace.html" title="PresburgerSpace is the space of all possible values of a tuple of integer valued variables/variables." alt="" coords="221,119,425,161"/>
<area shape="rect" title=" " alt="" coords="5,92,87,119"/>
<area shape="rect" href="classllvm_1_1SmallVector.html" title=" " alt="" coords="943,116,1101,172"/>
<area shape="rect" href="classllvm_1_1SmallVector.html" title=" " alt="" coords="567,123,715,165"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaec51cfb6129c7a10dbf24740897cf1b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#aaec51cfb6129c7a10dbf24740897cf1b">FlatAffineValueConstraints</a> (unsigned numReservedInequalities, unsigned numReservedEqualities, unsigned numReservedCols, unsigned numDims, unsigned numSymbols, unsigned numLocals, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt; valArgs={})</td></tr>
<tr class="memdesc:aaec51cfb6129c7a10dbf24740897cf1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a constraint system reserving memory for the specified number of constraints and variables.  <a href="classmlir_1_1FlatAffineValueConstraints.html#aaec51cfb6129c7a10dbf24740897cf1b">More...</a><br /></td></tr>
<tr class="separator:aaec51cfb6129c7a10dbf24740897cf1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba51af6e35a94b11d73b5215a35ff7a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a8ba51af6e35a94b11d73b5215a35ff7a">FlatAffineValueConstraints</a> (unsigned numDims=0, unsigned numSymbols=0, unsigned numLocals=0, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt; valArgs={})</td></tr>
<tr class="memdesc:a8ba51af6e35a94b11d73b5215a35ff7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a constraint system with the specified number of dimensions and symbols.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a8ba51af6e35a94b11d73b5215a35ff7a">More...</a><br /></td></tr>
<tr class="separator:a8ba51af6e35a94b11d73b5215a35ff7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a72f6f50a3c14fb9b64ff67fd3dfdc1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a1a72f6f50a3c14fb9b64ff67fd3dfdc1">FlatAffineValueConstraints</a> (const <a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#ac39dd991a3d29265b2f1d70390091139">IntegerPolyhedron</a> &amp;fac, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt; valArgs={})</td></tr>
<tr class="separator:a1a72f6f50a3c14fb9b64ff67fd3dfdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af048f5fb19968688b331c7bb0f8d9a4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#af048f5fb19968688b331c7bb0f8d9a4d">FlatAffineValueConstraints</a> (const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> &amp;avm)</td></tr>
<tr class="memdesc:af048f5fb19968688b331c7bb0f8d9a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a flat affine constraint system from an <a class="el" href="classmlir_1_1AffineValueMap.html" title="An AffineValueMap is an affine map plus its ML value operands and results for analysis purposes.">AffineValueMap</a> or a list of these.  <a href="classmlir_1_1FlatAffineValueConstraints.html#af048f5fb19968688b331c7bb0f8d9a4d">More...</a><br /></td></tr>
<tr class="separator:af048f5fb19968688b331c7bb0f8d9a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1b9f72ea71c10baebb8e93d716c1df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#adb1b9f72ea71c10baebb8e93d716c1df">FlatAffineValueConstraints</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> * &gt; avmRef)</td></tr>
<tr class="separator:adb1b9f72ea71c10baebb8e93d716c1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa812729dd90454f1c10517520dde9a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a3fa812729dd90454f1c10517520dde9a">FlatAffineValueConstraints</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set)</td></tr>
<tr class="memdesc:a3fa812729dd90454f1c10517520dde9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an affine constraint system from an <a class="el" href="classmlir_1_1IntegerSet.html" title="An integer set representing a conjunction of one or more affine equalities and inequalities.">IntegerSet</a>.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a3fa812729dd90454f1c10517520dde9a">More...</a><br /></td></tr>
<tr class="separator:a3fa812729dd90454f1c10517520dde9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf63cb6df8a2b726569a10c067639ee8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#acf63cb6df8a2b726569a10c067639ee8">FlatAffineValueConstraints</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> * &gt; avmRef, <a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set)</td></tr>
<tr class="separator:acf63cb6df8a2b726569a10c067639ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6234845a4fa3eb9444e56cab0fe5b0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a02a605e2b5fca97f0ea2af1f24a24703">Kind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ac6234845a4fa3eb9444e56cab0fe5b0e">getKind</a> () const override</td></tr>
<tr class="memdesc:ac6234845a4fa3eb9444e56cab0fe5b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the kind of this FlatAffineConstraints.  <a href="classmlir_1_1FlatAffineValueConstraints.html#ac6234845a4fa3eb9444e56cab0fe5b0e">More...</a><br /></td></tr>
<tr class="separator:ac6234845a4fa3eb9444e56cab0fe5b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf03e7c9ae234b714e008160e7d3fba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#aadf03e7c9ae234b714e008160e7d3fba">reset</a> (unsigned numReservedInequalities, unsigned numReservedEqualities, unsigned numReservedCols, unsigned numDims, unsigned numSymbols, unsigned numLocals=0)</td></tr>
<tr class="memdesc:aadf03e7c9ae234b714e008160e7d3fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears any existing data and reserves memory for the specified constraints.  <a href="classmlir_1_1FlatAffineValueConstraints.html#aadf03e7c9ae234b714e008160e7d3fba">More...</a><br /></td></tr>
<tr class="separator:aadf03e7c9ae234b714e008160e7d3fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96f71bbc66b10ee4e5286483b7b141f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ad96f71bbc66b10ee4e5286483b7b141f">reset</a> (unsigned numDims=0, unsigned numSymbols=0, unsigned numLocals=0)</td></tr>
<tr class="separator:ad96f71bbc66b10ee4e5286483b7b141f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e00fa2f257f1bd2c8ab11369207198"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a58e00fa2f257f1bd2c8ab11369207198">reset</a> (unsigned numReservedInequalities, unsigned numReservedEqualities, unsigned numReservedCols, unsigned numDims, unsigned numSymbols, unsigned numLocals, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; valArgs)</td></tr>
<tr class="separator:a58e00fa2f257f1bd2c8ab11369207198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a94ce5a825b81e5767fef38db2329a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ae3a94ce5a825b81e5767fef38db2329a">reset</a> (unsigned numDims, unsigned numSymbols, unsigned numLocals, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; valArgs)</td></tr>
<tr class="separator:ae3a94ce5a825b81e5767fef38db2329a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592860df144ae17907bccf79792e3f90"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a592860df144ae17907bccf79792e3f90">clone</a> () const</td></tr>
<tr class="memdesc:a592860df144ae17907bccf79792e3f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones this object.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a592860df144ae17907bccf79792e3f90">More...</a><br /></td></tr>
<tr class="separator:a592860df144ae17907bccf79792e3f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85192d2ad28e90993950ec5c2598a3e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a85192d2ad28e90993950ec5c2598a3e7">addAffineForOpDomain</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a85192d2ad28e90993950ec5c2598a3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraints (lower and upper bounds) for the specified 'affine.for' operation's <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> using IR information stored in its bound maps.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a85192d2ad28e90993950ec5c2598a3e7">More...</a><br /></td></tr>
<tr class="separator:a85192d2ad28e90993950ec5c2598a3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4287995c9f074be38e7e1d76b39d93f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a4287995c9f074be38e7e1d76b39d93f8">addDomainFromSliceMaps</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; lbMaps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; ubMaps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands)</td></tr>
<tr class="memdesc:a4287995c9f074be38e7e1d76b39d93f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraints (lower and upper bounds) for each loop in the loop nest described by the bound maps <code>lbMaps</code> and <code>ubMaps</code> of a computation slice.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a4287995c9f074be38e7e1d76b39d93f8">More...</a><br /></td></tr>
<tr class="separator:a4287995c9f074be38e7e1d76b39d93f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b74b3973d5329fe7ec99a7d2f8ed31f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a1b74b3973d5329fe7ec99a7d2f8ed31f">addAffineIfOpDomain</a> (AffineIfOp ifOp)</td></tr>
<tr class="memdesc:a1b74b3973d5329fe7ec99a7d2f8ed31f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraints imposed by the <code>affine.if</code> operation.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a1b74b3973d5329fe7ec99a7d2f8ed31f">More...</a><br /></td></tr>
<tr class="separator:a1b74b3973d5329fe7ec99a7d2f8ed31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1549c4022326443281b2af784da2ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a2a1549c4022326443281b2af784da2ba">addBound</a> (<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabc">BoundType</a> type, unsigned pos, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> boundMap, bool isClosedBound)</td></tr>
<tr class="memdesc:a2a1549c4022326443281b2af784da2ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a bound for the variable at the specified position with constraints being drawn from the specified bound map.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a2a1549c4022326443281b2af784da2ba">More...</a><br /></td></tr>
<tr class="separator:a2a1549c4022326443281b2af784da2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c982da57d4288f8cbe655848ecd204c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a9c982da57d4288f8cbe655848ecd204c">addBound</a> (<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabc">BoundType</a> type, unsigned pos, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> boundMap)</td></tr>
<tr class="memdesc:a9c982da57d4288f8cbe655848ecd204c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a bound for the variable at the specified position with constraints being drawn from the specified bound map.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a9c982da57d4288f8cbe655848ecd204c">More...</a><br /></td></tr>
<tr class="separator:a9c982da57d4288f8cbe655848ecd204c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0266a236d1adc4c4a08e4d68b741e38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ae0266a236d1adc4c4a08e4d68b741e38">addBound</a> (<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabc">BoundType</a> type, unsigned pos, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> boundMap, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands)</td></tr>
<tr class="memdesc:ae0266a236d1adc4c4a08e4d68b741e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a bound for the variable at the specified position with constraints being drawn from the specified bound map and operands.  <a href="classmlir_1_1FlatAffineValueConstraints.html#ae0266a236d1adc4c4a08e4d68b741e38">More...</a><br /></td></tr>
<tr class="separator:ae0266a236d1adc4c4a08e4d68b741e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210341fc77fde46aedce6d2609f26738"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a210341fc77fde46aedce6d2609f26738">addBound</a> (<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabc">BoundType</a> type, <a class="el" href="classmlir_1_1Value.html">Value</a> val, int64_t <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="memdesc:a210341fc77fde46aedce6d2609f26738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant bound for the variable associated with the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a210341fc77fde46aedce6d2609f26738">More...</a><br /></td></tr>
<tr class="separator:a210341fc77fde46aedce6d2609f26738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714f817973fece68d8223bf3d8d598de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a714f817973fece68d8223bf3d8d598de">getAsIntegerSet</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context) const</td></tr>
<tr class="memdesc:a714f817973fece68d8223bf3d8d598de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint system as an integer set.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a714f817973fece68d8223bf3d8d598de">More...</a><br /></td></tr>
<tr class="separator:a714f817973fece68d8223bf3d8d598de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c6d8417b9fec1a599ca72343a82b15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ac3c6d8417b9fec1a599ca72343a82b15">getSliceBounds</a> (unsigned offset, unsigned num, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; *lbMaps, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; *ubMaps, bool getClosedUB=false)</td></tr>
<tr class="memdesc:ac3c6d8417b9fec1a599ca72343a82b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the lower and upper bounds of the first <code>num</code> dimensional variables (starting at <code>offset</code>) as an affine map of the remaining variables (dimensional and symbolic).  <a href="classmlir_1_1FlatAffineValueConstraints.html#ac3c6d8417b9fec1a599ca72343a82b15">More...</a><br /></td></tr>
<tr class="separator:ac3c6d8417b9fec1a599ca72343a82b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e83c0b271e4aff69e15b7bd96a1c4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ae5e83c0b271e4aff69e15b7bd96a1c4b">composeMatchingMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> other)</td></tr>
<tr class="memdesc:ae5e83c0b271e4aff69e15b7bd96a1c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes an affine map whose dimensions and symbols match one to one with the dimensions and symbols of this FlatAffineConstraints.  <a href="classmlir_1_1FlatAffineValueConstraints.html#ae5e83c0b271e4aff69e15b7bd96a1c4b">More...</a><br /></td></tr>
<tr class="separator:ae5e83c0b271e4aff69e15b7bd96a1c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77763faa50eb0b78f95f0c195fe4bc49"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a77763faa50eb0b78f95f0c195fe4bc49">getLowerAndUpperBound</a> (unsigned pos, unsigned offset, unsigned num, unsigned symStartPos, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; localExprs, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context) const</td></tr>
<tr class="memdesc:a77763faa50eb0b78f95f0c195fe4bc49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the lower and upper bound of the <code>offset</code> + <code>pos</code>th variable treating [0, offset) U [offset + num, symStartPos) as dimensions and [symStartPos, getNumDimAndSymbolVars) as symbols, and <code>pos</code> lies in [0, num).  <a href="classmlir_1_1FlatAffineValueConstraints.html#a77763faa50eb0b78f95f0c195fe4bc49">More...</a><br /></td></tr>
<tr class="separator:a77763faa50eb0b78f95f0c195fe4bc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0dbadcb953c32567a17ab1b662505e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ac0dbadcb953c32567a17ab1b662505e0">getIneqAsAffineValueMap</a> (unsigned pos, unsigned ineqPos, <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> &amp;vmap, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context) const</td></tr>
<tr class="memdesc:ac0dbadcb953c32567a17ab1b662505e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bound for the variable at <code>pos</code> from the inequality at <code>ineqPos</code> as a 1-d affine value map (affine map + operands).  <a href="classmlir_1_1FlatAffineValueConstraints.html#ac0dbadcb953c32567a17ab1b662505e0">More...</a><br /></td></tr>
<tr class="separator:ac0dbadcb953c32567a17ab1b662505e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38a7dd065a6c286b7ac84f0d1712c23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ad38a7dd065a6c286b7ac84f0d1712c23">addSliceBounds</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a2662045a8d845c7cf9aa9516af6ea914">values</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; lbMaps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; ubMaps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands)</td></tr>
<tr class="memdesc:ad38a7dd065a6c286b7ac84f0d1712c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds slice lower bounds represented by lower bounds in <code>lbMaps</code> and upper bounds in <code>ubMaps</code> to each variable in the constraint system which has a value in <code>values</code>.  <a href="classmlir_1_1FlatAffineValueConstraints.html#ad38a7dd065a6c286b7ac84f0d1712c23">More...</a><br /></td></tr>
<tr class="separator:ad38a7dd065a6c286b7ac84f0d1712c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71e730c49c436786b39ba3a4eb98c14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#aa71e730c49c436786b39ba3a4eb98c14">findVar</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val, unsigned *pos) const</td></tr>
<tr class="memdesc:aa71e730c49c436786b39ba3a4eb98c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up the position of the variable with the specified <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="classmlir_1_1FlatAffineValueConstraints.html#aa71e730c49c436786b39ba3a4eb98c14">More...</a><br /></td></tr>
<tr class="separator:aa71e730c49c436786b39ba3a4eb98c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77883ce535bd59441c6cd5e919b6b221"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a77883ce535bd59441c6cd5e919b6b221">containsVar</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> mayBeVar) const</td></tr>
<tr class="memdesc:a77883ce535bd59441c6cd5e919b6b221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if an variable with the specified <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> exists, false otherwise.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a77883ce535bd59441c6cd5e919b6b221">More...</a><br /></td></tr>
<tr class="separator:a77883ce535bd59441c6cd5e919b6b221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089f2a8429b04365f4f869c4423ba890"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a089f2a8429b04365f4f869c4423ba890">swapVar</a> (unsigned posA, unsigned posB) override</td></tr>
<tr class="memdesc:a089f2a8429b04365f4f869c4423ba890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the posA^th variable with the posB^th variable.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a089f2a8429b04365f4f869c4423ba890">More...</a><br /></td></tr>
<tr class="separator:a089f2a8429b04365f4f869c4423ba890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc57d88ce75e704217336a290374419"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#accc57d88ce75e704217336a290374419">insertDimVar</a> (unsigned pos, unsigned num=1)</td></tr>
<tr class="memdesc:accc57d88ce75e704217336a290374419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert variables of the specified kind at position <code>pos</code>.  <a href="classmlir_1_1FlatAffineValueConstraints.html#accc57d88ce75e704217336a290374419">More...</a><br /></td></tr>
<tr class="separator:accc57d88ce75e704217336a290374419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1566b2ad81b3cb258dad9e604604cf63"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a1566b2ad81b3cb258dad9e604604cf63">insertSymbolVar</a> (unsigned pos, unsigned num=1)</td></tr>
<tr class="separator:a1566b2ad81b3cb258dad9e604604cf63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437ba7c788fa234e76dda9ec1f0bda19"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a437ba7c788fa234e76dda9ec1f0bda19">insertLocalVar</a> (unsigned pos, unsigned num=1)</td></tr>
<tr class="separator:a437ba7c788fa234e76dda9ec1f0bda19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d82ee30050dfae50aeb804194331f0a"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a4d82ee30050dfae50aeb804194331f0a">insertDimVar</a> (unsigned pos, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> vals)</td></tr>
<tr class="separator:a4d82ee30050dfae50aeb804194331f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419d692ad1e68deafa03ca4bbef64bbf"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a419d692ad1e68deafa03ca4bbef64bbf">insertSymbolVar</a> (unsigned pos, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> vals)</td></tr>
<tr class="separator:a419d692ad1e68deafa03ca4bbef64bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35cef22df821ed6026694fec9e0d9243"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a35cef22df821ed6026694fec9e0d9243">insertVar</a> (<a class="el" href="namespacemlir_1_1presburger.html#a0fa2eacf0a4f6b3656064ea54f8d3c35">presburger::VarKind</a> kind, unsigned pos, unsigned num=1) override</td></tr>
<tr class="memdesc:a35cef22df821ed6026694fec9e0d9243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert <code>num</code> variables of the specified kind at position <code>pos</code>.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a35cef22df821ed6026694fec9e0d9243">More...</a><br /></td></tr>
<tr class="separator:a35cef22df821ed6026694fec9e0d9243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe613f7abac640e7d9cf2804458915f0"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#abe613f7abac640e7d9cf2804458915f0">insertVar</a> (<a class="el" href="namespacemlir_1_1presburger.html#a0fa2eacf0a4f6b3656064ea54f8d3c35">presburger::VarKind</a> kind, unsigned pos, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> vals)</td></tr>
<tr class="separator:abe613f7abac640e7d9cf2804458915f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a7838df1d1496136d23dac312240c4"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a99a7838df1d1496136d23dac312240c4">appendDimVar</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> vals)</td></tr>
<tr class="memdesc:a99a7838df1d1496136d23dac312240c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append variables of the specified kind after the last variable of that kind.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a99a7838df1d1496136d23dac312240c4">More...</a><br /></td></tr>
<tr class="separator:a99a7838df1d1496136d23dac312240c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1e7bace4b883c1aaf15bd8a811aad2"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#aec1e7bace4b883c1aaf15bd8a811aad2">appendSymbolVar</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> vals)</td></tr>
<tr class="separator:aec1e7bace4b883c1aaf15bd8a811aad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77ebdda919f83bf948fd79b2f7dfd14"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ad77ebdda919f83bf948fd79b2f7dfd14">appendDimVar</a> (unsigned num=1)</td></tr>
<tr class="separator:ad77ebdda919f83bf948fd79b2f7dfd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3df3ed0dbc2abf7eed4e6249cbfbac"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#afb3df3ed0dbc2abf7eed4e6249cbfbac">appendSymbolVar</a> (unsigned num=1)</td></tr>
<tr class="separator:afb3df3ed0dbc2abf7eed4e6249cbfbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046b0ec09fb973fb08a0365ce4f6cc8a"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a046b0ec09fb973fb08a0365ce4f6cc8a">appendLocalVar</a> (unsigned num=1)</td></tr>
<tr class="separator:a046b0ec09fb973fb08a0365ce4f6cc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e3159a9bc6a0113f7957899cb2b636"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a99e3159a9bc6a0113f7957899cb2b636">removeVarRange</a> (<a class="el" href="namespacemlir_1_1presburger.html#a0fa2eacf0a4f6b3656064ea54f8d3c35">presburger::VarKind</a> kind, unsigned varStart, unsigned varLimit) override</td></tr>
<tr class="memdesc:a99e3159a9bc6a0113f7957899cb2b636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes variables in the column range [varStart, varLimit), and copies any remaining valid data into place, updates member variables, and resizes arrays as needed.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a99e3159a9bc6a0113f7957899cb2b636">More...</a><br /></td></tr>
<tr class="separator:a99e3159a9bc6a0113f7957899cb2b636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1150883739ccac33efedf30dd36decfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a1150883739ccac33efedf30dd36decfb">addInductionVarOrTerminalSymbol</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a1150883739ccac33efedf30dd36decfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the specified values as a dim or symbol var depending on its nature, if it already doesn't exist in the system.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a1150883739ccac33efedf30dd36decfb">More...</a><br /></td></tr>
<tr class="separator:a1150883739ccac33efedf30dd36decfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1918c91299c463de63c843ee1f7628"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a5f1918c91299c463de63c843ee1f7628">computeAlignedMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands) const</td></tr>
<tr class="memdesc:a5f1918c91299c463de63c843ee1f7628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Align <code>map</code> with this constraint system based on <code>operands</code>.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a5f1918c91299c463de63c843ee1f7628">More...</a><br /></td></tr>
<tr class="separator:a5f1918c91299c463de63c843ee1f7628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4dd23a785eb9a02c7f2ba43fa1aa7db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ad4dd23a785eb9a02c7f2ba43fa1aa7db">composeMap</a> (const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *vMap)</td></tr>
<tr class="memdesc:ad4dd23a785eb9a02c7f2ba43fa1aa7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes the affine value map with this FlatAffineValueConstrains, adding the results of the map as dimensions at the front [0, vMap-&gt;getNumResults()) and with the dimensions set to the equalities specified by the value map.  <a href="classmlir_1_1FlatAffineValueConstraints.html#ad4dd23a785eb9a02c7f2ba43fa1aa7db">More...</a><br /></td></tr>
<tr class="separator:ad4dd23a785eb9a02c7f2ba43fa1aa7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79575e2c2693576f2c5a4accf0dcdab6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a79575e2c2693576f2c5a4accf0dcdab6">projectOut</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a79575e2c2693576f2c5a4accf0dcdab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects out the variable that is associate with <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a79575e2c2693576f2c5a4accf0dcdab6">More...</a><br /></td></tr>
<tr class="separator:a79575e2c2693576f2c5a4accf0dcdab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b004fb4978436d8c8cd8976803468c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a38b004fb4978436d8c8cd8976803468c">convertLoopIVSymbolsToDims</a> ()</td></tr>
<tr class="memdesc:a38b004fb4978436d8c8cd8976803468c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes all symbol variables which are loop IVs to dim variables.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a38b004fb4978436d8c8cd8976803468c">More...</a><br /></td></tr>
<tr class="separator:a38b004fb4978436d8c8cd8976803468c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c35f1d2d81adf4ba06b84df578cd78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#af0c35f1d2d81adf4ba06b84df578cd78">unionBoundingBox</a> (const <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;other)</td></tr>
<tr class="memdesc:af0c35f1d2d81adf4ba06b84df578cd78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the constraints to be the smallest bounding (enclosing) box that contains the points of <code>this</code> set and that of <code>other</code>, with the symbols being treated specially.  <a href="classmlir_1_1FlatAffineValueConstraints.html#af0c35f1d2d81adf4ba06b84df578cd78">More...</a><br /></td></tr>
<tr class="separator:af0c35f1d2d81adf4ba06b84df578cd78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89053c897c2310e74204a899901deb5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a89053c897c2310e74204a899901deb5f">mergeAndAlignVarsWithOther</a> (unsigned offset, <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *other)</td></tr>
<tr class="memdesc:a89053c897c2310e74204a899901deb5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge and align the variables of <code>this</code> and <code>other</code> starting at <code>offset</code>, so that both constraint systems get the union of the contained variables that is dimension-wise and symbol-wise unique; both constraint systems are updated so that they have the union of all variables, with <code>this</code>'s original variables appearing first followed by any of <code>other</code>'s variables that didn't appear in <code>this</code>.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a89053c897c2310e74204a899901deb5f">More...</a><br /></td></tr>
<tr class="separator:a89053c897c2310e74204a899901deb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31609659b8eb41c2880ee4c1a648bf5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ab31609659b8eb41c2880ee4c1a648bf5">areVarsAlignedWithOther</a> (const <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;other)</td></tr>
<tr class="memdesc:ab31609659b8eb41c2880ee4c1a648bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this constraint system and <code>other</code> are in the same space, i.e., if they are associated with the same set of variables, appearing in the same order.  <a href="classmlir_1_1FlatAffineValueConstraints.html#ab31609659b8eb41c2880ee4c1a648bf5">More...</a><br /></td></tr>
<tr class="separator:ab31609659b8eb41c2880ee4c1a648bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003266c0f9665b8b6dabd3df392cb6c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a003266c0f9665b8b6dabd3df392cb6c1">clearAndCopyFrom</a> (const <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> &amp;other) override</td></tr>
<tr class="memdesc:a003266c0f9665b8b6dabd3df392cb6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of this <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html" title="FlatAffineValueConstraints represents an extension of IntegerPolyhedron where each non-local variable...">FlatAffineValueConstraints</a> with <code>other</code>.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a003266c0f9665b8b6dabd3df392cb6c1">More...</a><br /></td></tr>
<tr class="separator:a003266c0f9665b8b6dabd3df392cb6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3896e7ab007a7bd1e8d1fb1fb098bdea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a3896e7ab007a7bd1e8d1fb1fb098bdea">getValue</a> (unsigned pos) const</td></tr>
<tr class="memdesc:a3896e7ab007a7bd1e8d1fb1fb098bdea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> associated with the pos^th variable.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a3896e7ab007a7bd1e8d1fb1fb098bdea">More...</a><br /></td></tr>
<tr class="separator:a3896e7ab007a7bd1e8d1fb1fb098bdea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e39afc73e0776e068eb7331bcb349c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a5e39afc73e0776e068eb7331bcb349c7">hasValue</a> (unsigned pos) const</td></tr>
<tr class="memdesc:a5e39afc73e0776e068eb7331bcb349c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the pos^th variable has an associated <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a5e39afc73e0776e068eb7331bcb349c7">More...</a><br /></td></tr>
<tr class="separator:a5e39afc73e0776e068eb7331bcb349c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321a6a4ea45324a6c969a5b5062ec932"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a321a6a4ea45324a6c969a5b5062ec932">hasValues</a> () const</td></tr>
<tr class="memdesc:a321a6a4ea45324a6c969a5b5062ec932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if at least one variable has an associated <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a321a6a4ea45324a6c969a5b5062ec932">More...</a><br /></td></tr>
<tr class="separator:a321a6a4ea45324a6c969a5b5062ec932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ccc790e216f3bbf7416308c04045094"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a9ccc790e216f3bbf7416308c04045094">getValues</a> (unsigned start, unsigned end, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *<a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a2662045a8d845c7cf9aa9516af6ea914">values</a>) const</td></tr>
<tr class="memdesc:a9ccc790e216f3bbf7416308c04045094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Values associated with variables in range [start, end).  <a href="classmlir_1_1FlatAffineValueConstraints.html#a9ccc790e216f3bbf7416308c04045094">More...</a><br /></td></tr>
<tr class="separator:a9ccc790e216f3bbf7416308c04045094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5177b199aa494103835274f72907a8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#af5177b199aa494103835274f72907a8b">getAllValues</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *<a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a2662045a8d845c7cf9aa9516af6ea914">values</a>) const</td></tr>
<tr class="separator:af5177b199aa494103835274f72907a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7998d8323c934c13a86769ca8fad877"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ad7998d8323c934c13a86769ca8fad877">getMaybeValues</a> () const</td></tr>
<tr class="separator:ad7998d8323c934c13a86769ca8fad877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789eb319f31cdec1440144ad77d891a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a789eb319f31cdec1440144ad77d891a3">getMaybeValues</a> (<a class="el" href="namespacemlir_1_1presburger.html#a0fa2eacf0a4f6b3656064ea54f8d3c35">presburger::VarKind</a> kind) const</td></tr>
<tr class="separator:a789eb319f31cdec1440144ad77d891a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eccad1d331cf5cfb78bf1f08fda7224"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a5eccad1d331cf5cfb78bf1f08fda7224">setValue</a> (unsigned pos, <a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a5eccad1d331cf5cfb78bf1f08fda7224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> associated with the pos^th variable.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a5eccad1d331cf5cfb78bf1f08fda7224">More...</a><br /></td></tr>
<tr class="separator:a5eccad1d331cf5cfb78bf1f08fda7224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320c65d604a6089bb16894e4a9ee33bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a320c65d604a6089bb16894e4a9ee33bf">setValues</a> (unsigned start, unsigned end, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a2662045a8d845c7cf9aa9516af6ea914">values</a>)</td></tr>
<tr class="memdesc:a320c65d604a6089bb16894e4a9ee33bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Values associated with the variables in the range [start, end).  <a href="classmlir_1_1FlatAffineValueConstraints.html#a320c65d604a6089bb16894e4a9ee33bf">More...</a><br /></td></tr>
<tr class="separator:a320c65d604a6089bb16894e4a9ee33bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa93b30b85ee67b7d42c3f60b452f24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a9aa93b30b85ee67b7d42c3f60b452f24">mergeSymbolVars</a> (<a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;other)</td></tr>
<tr class="memdesc:a9aa93b30b85ee67b7d42c3f60b452f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge and align symbols of <code>this</code> and <code>other</code> such that both get union of of symbols that are unique.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a9aa93b30b85ee67b7d42c3f60b452f24">More...</a><br /></td></tr>
<tr class="separator:a9aa93b30b85ee67b7d42c3f60b452f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html">mlir::presburger::IntegerPolyhedron</a></td></tr>
<tr class="memitem:ac39dd991a3d29265b2f1d70390091139 inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#ac39dd991a3d29265b2f1d70390091139">IntegerPolyhedron</a> (unsigned numReservedInequalities, unsigned numReservedEqualities, unsigned numReservedCols, const <a class="el" href="classmlir_1_1presburger_1_1PresburgerSpace.html">PresburgerSpace</a> &amp;<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a80fe301a2d8c1e77d84894aaaae00db8">space</a>)</td></tr>
<tr class="memdesc:ac39dd991a3d29265b2f1d70390091139 inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a set reserving memory for the specified number of constraints and variables.  <a href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#ac39dd991a3d29265b2f1d70390091139">More...</a><br /></td></tr>
<tr class="separator:ac39dd991a3d29265b2f1d70390091139 inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc78cf32669bb6400f29c987a787f478 inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#abc78cf32669bb6400f29c987a787f478">IntegerPolyhedron</a> (const <a class="el" href="classmlir_1_1presburger_1_1PresburgerSpace.html">PresburgerSpace</a> &amp;<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a80fe301a2d8c1e77d84894aaaae00db8">space</a>)</td></tr>
<tr class="memdesc:abc78cf32669bb6400f29c987a787f478 inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a relation with the specified number of dimensions and symbols.  <a href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#abc78cf32669bb6400f29c987a787f478">More...</a><br /></td></tr>
<tr class="separator:abc78cf32669bb6400f29c987a787f478 inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef5b6d931e61b594831a79719e3437c inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#a3ef5b6d931e61b594831a79719e3437c">IntegerPolyhedron</a> (const <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> &amp;rel)</td></tr>
<tr class="memdesc:a3ef5b6d931e61b594831a79719e3437c inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a set from an <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html" title="An IntegerRelation represents the set of points from a PresburgerSpace that satisfy a list of affine ...">IntegerRelation</a>.  <a href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#a3ef5b6d931e61b594831a79719e3437c">More...</a><br /></td></tr>
<tr class="separator:a3ef5b6d931e61b594831a79719e3437c inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1050bfa1186fec35e6765866ddb5e16a inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#a1050bfa1186fec35e6765866ddb5e16a">IntegerPolyhedron</a> (<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> &amp;&amp;rel)</td></tr>
<tr class="memdesc:a1050bfa1186fec35e6765866ddb5e16a inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a set from an <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html" title="An IntegerRelation represents the set of points from a PresburgerSpace that satisfy a list of affine ...">IntegerRelation</a>, but instead of creating a copy, use move constructor.  <a href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#a1050bfa1186fec35e6765866ddb5e16a">More...</a><br /></td></tr>
<tr class="separator:a1050bfa1186fec35e6765866ddb5e16a inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae519080bf303b244bde7d9d3b57ee13c inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html">IntegerPolyhedron</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#ae519080bf303b244bde7d9d3b57ee13c">clone</a> () const</td></tr>
<tr class="separator:ae519080bf303b244bde7d9d3b57ee13c inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b01114bf978ce3b3d2320fe5988ecea inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html">IntegerPolyhedron</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#a6b01114bf978ce3b3d2320fe5988ecea">intersect</a> (const <a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html">IntegerPolyhedron</a> &amp;other) const</td></tr>
<tr class="memdesc:a6b01114bf978ce3b3d2320fe5988ecea inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the intersection of the two relations.  <a href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#a6b01114bf978ce3b3d2320fe5988ecea">More...</a><br /></td></tr>
<tr class="separator:a6b01114bf978ce3b3d2320fe5988ecea inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab4a6a7a25a4e63ed9f3f806639dd9c inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1PresburgerSet.html">PresburgerSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#abab4a6a7a25a4e63ed9f3f806639dd9c">subtract</a> (const <a class="el" href="classmlir_1_1presburger_1_1PresburgerSet.html">PresburgerSet</a> &amp;other) const</td></tr>
<tr class="memdesc:abab4a6a7a25a4e63ed9f3f806639dd9c inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the set difference of this set and the given set, i.e., return <code>this \ set</code>.  <a href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#abab4a6a7a25a4e63ed9f3f806639dd9c">More...</a><br /></td></tr>
<tr class="separator:abab4a6a7a25a4e63ed9f3f806639dd9c inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1presburger_1_1IntegerRelation')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">mlir::presburger::IntegerRelation</a></td></tr>
<tr class="memitem:a720bc08a94b0b8e26ffffedebf24fc1c inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a720bc08a94b0b8e26ffffedebf24fc1c">IntegerRelation</a> (unsigned numReservedInequalities, unsigned numReservedEqualities, unsigned numReservedCols, const <a class="el" href="classmlir_1_1presburger_1_1PresburgerSpace.html">PresburgerSpace</a> &amp;<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a80fe301a2d8c1e77d84894aaaae00db8">space</a>)</td></tr>
<tr class="memdesc:a720bc08a94b0b8e26ffffedebf24fc1c inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a relation reserving memory for the specified number of constraints and variables.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a720bc08a94b0b8e26ffffedebf24fc1c">More...</a><br /></td></tr>
<tr class="separator:a720bc08a94b0b8e26ffffedebf24fc1c inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf1aa5c32a8def0e57d15969aa912b0 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#abdf1aa5c32a8def0e57d15969aa912b0">IntegerRelation</a> (const <a class="el" href="classmlir_1_1presburger_1_1PresburgerSpace.html">PresburgerSpace</a> &amp;<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a80fe301a2d8c1e77d84894aaaae00db8">space</a>)</td></tr>
<tr class="memdesc:abdf1aa5c32a8def0e57d15969aa912b0 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a relation with the specified number of dimensions and symbols.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#abdf1aa5c32a8def0e57d15969aa912b0">More...</a><br /></td></tr>
<tr class="separator:abdf1aa5c32a8def0e57d15969aa912b0 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25ac9112420b4edf3e954ba3e338b19 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ae25ac9112420b4edf3e954ba3e338b19">~IntegerRelation</a> ()=default</td></tr>
<tr class="separator:ae25ac9112420b4edf3e954ba3e338b19 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0403155cdedc9be79ce9bb2ffecc24d inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#af0403155cdedc9be79ce9bb2ffecc24d">clone</a> () const</td></tr>
<tr class="separator:af0403155cdedc9be79ce9bb2ffecc24d inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f51851031d9519a61befb0ed874f74 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlir_1_1presburger_1_1PresburgerSpace.html">PresburgerSpace</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#af1f51851031d9519a61befb0ed874f74">getSpace</a> () const</td></tr>
<tr class="memdesc:af1f51851031d9519a61befb0ed874f74 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying space.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#af1f51851031d9519a61befb0ed874f74">More...</a><br /></td></tr>
<tr class="separator:af1f51851031d9519a61befb0ed874f74 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0d5ff691663b7bf576fde402a19656 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a8a0d5ff691663b7bf576fde402a19656">setSpace</a> (const <a class="el" href="classmlir_1_1presburger_1_1PresburgerSpace.html">PresburgerSpace</a> &amp;oSpace)</td></tr>
<tr class="memdesc:a8a0d5ff691663b7bf576fde402a19656 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the space to <code>oSpace</code>, which should have the same number of ids as the current space.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a8a0d5ff691663b7bf576fde402a19656">More...</a><br /></td></tr>
<tr class="separator:a8a0d5ff691663b7bf576fde402a19656 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f829556dc793d11b44eb69448f2e5f inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ac1f829556dc793d11b44eb69448f2e5f">setSpaceExceptLocals</a> (const <a class="el" href="classmlir_1_1presburger_1_1PresburgerSpace.html">PresburgerSpace</a> &amp;oSpace)</td></tr>
<tr class="memdesc:ac1f829556dc793d11b44eb69448f2e5f inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the space to <code>oSpace</code>, which should not have any local ids.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#ac1f829556dc793d11b44eb69448f2e5f">More...</a><br /></td></tr>
<tr class="separator:ac1f829556dc793d11b44eb69448f2e5f inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171247eae0b907aa93572dbf3a95c2cb inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1PresburgerSpace.html">PresburgerSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a171247eae0b907aa93572dbf3a95c2cb">getSpaceWithoutLocals</a> () const</td></tr>
<tr class="memdesc:a171247eae0b907aa93572dbf3a95c2cb inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the space without locals.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a171247eae0b907aa93572dbf3a95c2cb">More...</a><br /></td></tr>
<tr class="separator:a171247eae0b907aa93572dbf3a95c2cb inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9025608bad072a18f4db2f1fa1b32786 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a9025608bad072a18f4db2f1fa1b32786">append</a> (const <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> &amp;other)</td></tr>
<tr class="memdesc:a9025608bad072a18f4db2f1fa1b32786 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends constraints from <code>other</code> into <code>this</code>.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a9025608bad072a18f4db2f1fa1b32786">More...</a><br /></td></tr>
<tr class="separator:a9025608bad072a18f4db2f1fa1b32786 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa9f3b109d62586e5a968f80a2a6c1a inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a7fa9f3b109d62586e5a968f80a2a6c1a">intersect</a> (<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> other) const</td></tr>
<tr class="memdesc:a7fa9f3b109d62586e5a968f80a2a6c1a inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the intersection of the two relations.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a7fa9f3b109d62586e5a968f80a2a6c1a">More...</a><br /></td></tr>
<tr class="separator:a7fa9f3b109d62586e5a968f80a2a6c1a inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ebeb474504c3a8dc714b1fc655c1f3 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a99ebeb474504c3a8dc714b1fc655c1f3">isEqual</a> (const <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> &amp;other) const</td></tr>
<tr class="memdesc:a99ebeb474504c3a8dc714b1fc655c1f3 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether <code>this</code> and <code>other</code> are equal.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a99ebeb474504c3a8dc714b1fc655c1f3">More...</a><br /></td></tr>
<tr class="separator:a99ebeb474504c3a8dc714b1fc655c1f3 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef11443a1bca6b41093edf742ebb53ab inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#aef11443a1bca6b41093edf742ebb53ab">isSubsetOf</a> (const <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> &amp;other) const</td></tr>
<tr class="memdesc:aef11443a1bca6b41093edf742ebb53ab inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether this is a subset of the given <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html" title="An IntegerRelation represents the set of points from a PresburgerSpace that satisfy a list of affine ...">IntegerRelation</a>.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#aef11443a1bca6b41093edf742ebb53ab">More...</a><br /></td></tr>
<tr class="separator:aef11443a1bca6b41093edf742ebb53ab inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bad0859ca87c4fa518d3b64527784b6 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1MPInt.html">MPInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a0bad0859ca87c4fa518d3b64527784b6">atEq</a> (unsigned i, unsigned <a class="el" href="unionj.html">j</a>) const</td></tr>
<tr class="memdesc:a0bad0859ca87c4fa518d3b64527784b6 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value at the specified equality row and column.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a0bad0859ca87c4fa518d3b64527784b6">More...</a><br /></td></tr>
<tr class="separator:a0bad0859ca87c4fa518d3b64527784b6 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140ac96eaa337359d4208f97f79fe556 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a140ac96eaa337359d4208f97f79fe556">atEq64</a> (unsigned i, unsigned <a class="el" href="unionj.html">j</a>) const</td></tr>
<tr class="memdesc:a140ac96eaa337359d4208f97f79fe556 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same, but casts to int64_t.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a140ac96eaa337359d4208f97f79fe556">More...</a><br /></td></tr>
<tr class="separator:a140ac96eaa337359d4208f97f79fe556 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb90070615c4d1dc4c7665189802bb0 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1MPInt.html">MPInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a1eb90070615c4d1dc4c7665189802bb0">atEq</a> (unsigned i, unsigned <a class="el" href="unionj.html">j</a>)</td></tr>
<tr class="separator:a1eb90070615c4d1dc4c7665189802bb0 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec312f23e0e717df307748f47c371c0 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1MPInt.html">MPInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a8ec312f23e0e717df307748f47c371c0">atIneq</a> (unsigned i, unsigned <a class="el" href="unionj.html">j</a>) const</td></tr>
<tr class="memdesc:a8ec312f23e0e717df307748f47c371c0 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value at the specified inequality row and column.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a8ec312f23e0e717df307748f47c371c0">More...</a><br /></td></tr>
<tr class="separator:a8ec312f23e0e717df307748f47c371c0 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb83687fca2844566e23139f6b3dbee5 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#afb83687fca2844566e23139f6b3dbee5">atIneq64</a> (unsigned i, unsigned <a class="el" href="unionj.html">j</a>) const</td></tr>
<tr class="memdesc:afb83687fca2844566e23139f6b3dbee5 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same, but casts to int64_t.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#afb83687fca2844566e23139f6b3dbee5">More...</a><br /></td></tr>
<tr class="separator:afb83687fca2844566e23139f6b3dbee5 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f98a34ad06e11f979d46cbf8b083d53 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1MPInt.html">MPInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a6f98a34ad06e11f979d46cbf8b083d53">atIneq</a> (unsigned i, unsigned <a class="el" href="unionj.html">j</a>)</td></tr>
<tr class="separator:a6f98a34ad06e11f979d46cbf8b083d53 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1256e59f9472125b55ecf1af2b7c3d1 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ae1256e59f9472125b55ecf1af2b7c3d1">getNumConstraints</a> () const</td></tr>
<tr class="separator:ae1256e59f9472125b55ecf1af2b7c3d1 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791a606311258cf4bf0b422c359697ca inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a791a606311258cf4bf0b422c359697ca">getNumDomainVars</a> () const</td></tr>
<tr class="separator:a791a606311258cf4bf0b422c359697ca inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0418f31698d61bd9605a96bbe7a68fd inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#aa0418f31698d61bd9605a96bbe7a68fd">getNumRangeVars</a> () const</td></tr>
<tr class="separator:aa0418f31698d61bd9605a96bbe7a68fd inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc248919aa5b008259ca13941997221 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a3dc248919aa5b008259ca13941997221">getNumSymbolVars</a> () const</td></tr>
<tr class="separator:a3dc248919aa5b008259ca13941997221 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04ee03d2932329223c8853d690a4dfc inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#aa04ee03d2932329223c8853d690a4dfc">getNumLocalVars</a> () const</td></tr>
<tr class="separator:aa04ee03d2932329223c8853d690a4dfc inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa53d93beb1fdb59d59f8cad786fce75 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#afa53d93beb1fdb59d59f8cad786fce75">getNumDimVars</a> () const</td></tr>
<tr class="separator:afa53d93beb1fdb59d59f8cad786fce75 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3e70e280681ad6c66b768fb8848b48 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#aad3e70e280681ad6c66b768fb8848b48">getNumDimAndSymbolVars</a> () const</td></tr>
<tr class="separator:aad3e70e280681ad6c66b768fb8848b48 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb3f1ee0620b3dd79651c42d22ea457 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a8fb3f1ee0620b3dd79651c42d22ea457">getNumVars</a> () const</td></tr>
<tr class="separator:a8fb3f1ee0620b3dd79651c42d22ea457 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abddc32ead0b239d7759bf9383bdbf114 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#abddc32ead0b239d7759bf9383bdbf114">getNumCols</a> () const</td></tr>
<tr class="memdesc:abddc32ead0b239d7759bf9383bdbf114 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in the constraint system.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#abddc32ead0b239d7759bf9383bdbf114">More...</a><br /></td></tr>
<tr class="separator:abddc32ead0b239d7759bf9383bdbf114 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af740f656b16fb2c3484898e46cb85785 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#af740f656b16fb2c3484898e46cb85785">getNumEqualities</a> () const</td></tr>
<tr class="separator:af740f656b16fb2c3484898e46cb85785 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae878c389a2b7a93f7609c0818630efa4 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ae878c389a2b7a93f7609c0818630efa4">getNumInequalities</a> () const</td></tr>
<tr class="separator:ae878c389a2b7a93f7609c0818630efa4 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228f32becb1c08c0b89bbec7ccf55ac4 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a228f32becb1c08c0b89bbec7ccf55ac4">getNumReservedEqualities</a> () const</td></tr>
<tr class="separator:a228f32becb1c08c0b89bbec7ccf55ac4 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07d483e98eff17961ab5e094eae7169 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#aa07d483e98eff17961ab5e094eae7169">getNumReservedInequalities</a> () const</td></tr>
<tr class="separator:aa07d483e98eff17961ab5e094eae7169 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136a0703aa287a8cef4f062e8db0a3a7 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1presburger_1_1MPInt.html">MPInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a136a0703aa287a8cef4f062e8db0a3a7">getEquality</a> (unsigned idx) const</td></tr>
<tr class="separator:a136a0703aa287a8cef4f062e8db0a3a7 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880f99d91e825ca07c33acceffeda097 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1presburger_1_1MPInt.html">MPInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a880f99d91e825ca07c33acceffeda097">getInequality</a> (unsigned idx) const</td></tr>
<tr class="separator:a880f99d91e825ca07c33acceffeda097 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360846b9a2630bbe3274d672d6754d7a inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a360846b9a2630bbe3274d672d6754d7a">getEquality64</a> (unsigned idx) const</td></tr>
<tr class="memdesc:a360846b9a2630bbe3274d672d6754d7a inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same, but casts to int64_t.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a360846b9a2630bbe3274d672d6754d7a">More...</a><br /></td></tr>
<tr class="separator:a360846b9a2630bbe3274d672d6754d7a inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89142dd8c56adf97c87b62fd217149b inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ae89142dd8c56adf97c87b62fd217149b">getInequality64</a> (unsigned idx) const</td></tr>
<tr class="separator:ae89142dd8c56adf97c87b62fd217149b inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46317eff53fe57d6a48e4a0e38d319cd inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a46317eff53fe57d6a48e4a0e38d319cd">getNumVarKind</a> (<a class="el" href="namespacemlir_1_1presburger.html#a0fa2eacf0a4f6b3656064ea54f8d3c35">VarKind</a> kind) const</td></tr>
<tr class="memdesc:a46317eff53fe57d6a48e4a0e38d319cd inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of vars of the specified kind.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a46317eff53fe57d6a48e4a0e38d319cd">More...</a><br /></td></tr>
<tr class="separator:a46317eff53fe57d6a48e4a0e38d319cd inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d2abc98c35ba80e46d68aeadfc50cf inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#af9d2abc98c35ba80e46d68aeadfc50cf">getVarKindOffset</a> (<a class="el" href="namespacemlir_1_1presburger.html#a0fa2eacf0a4f6b3656064ea54f8d3c35">VarKind</a> kind) const</td></tr>
<tr class="memdesc:af9d2abc98c35ba80e46d68aeadfc50cf inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index at which the specified kind of vars starts.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#af9d2abc98c35ba80e46d68aeadfc50cf">More...</a><br /></td></tr>
<tr class="separator:af9d2abc98c35ba80e46d68aeadfc50cf inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156bfb92f286875212af74b36c4fefaf inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a156bfb92f286875212af74b36c4fefaf">getVarKindEnd</a> (<a class="el" href="namespacemlir_1_1presburger.html#a0fa2eacf0a4f6b3656064ea54f8d3c35">VarKind</a> kind) const</td></tr>
<tr class="memdesc:a156bfb92f286875212af74b36c4fefaf inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index at Which the specified kind of vars ends.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a156bfb92f286875212af74b36c4fefaf">More...</a><br /></td></tr>
<tr class="separator:a156bfb92f286875212af74b36c4fefaf inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb3240da6f9940497cc09acc52fb5a1 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#adbb3240da6f9940497cc09acc52fb5a1">getVarKindOverlap</a> (<a class="el" href="namespacemlir_1_1presburger.html#a0fa2eacf0a4f6b3656064ea54f8d3c35">VarKind</a> kind, unsigned varStart, unsigned varLimit) const</td></tr>
<tr class="memdesc:adbb3240da6f9940497cc09acc52fb5a1 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of elements of the specified kind in the range [varStart, varLimit).  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#adbb3240da6f9940497cc09acc52fb5a1">More...</a><br /></td></tr>
<tr class="separator:adbb3240da6f9940497cc09acc52fb5a1 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1f92130d99f5ecbc59b2e531418edb inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1presburger.html#a0fa2eacf0a4f6b3656064ea54f8d3c35">VarKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a6a1f92130d99f5ecbc59b2e531418edb">getVarKindAt</a> (unsigned pos) const</td></tr>
<tr class="memdesc:a6a1f92130d99f5ecbc59b2e531418edb inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the VarKind of the var at the specified position.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a6a1f92130d99f5ecbc59b2e531418edb">More...</a><br /></td></tr>
<tr class="separator:a6a1f92130d99f5ecbc59b2e531418edb inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f431396270ed25e2ee49ed9cd32661 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1presburger_1_1IntegerRelation_1_1CountsSnapshot.html">CountsSnapshot</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a32f431396270ed25e2ee49ed9cd32661">getCounts</a> () const</td></tr>
<tr class="separator:a32f431396270ed25e2ee49ed9cd32661 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec8498e71a2011cbb2f451e77a3673d inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a2ec8498e71a2011cbb2f451e77a3673d">truncate</a> (const <a class="el" href="structmlir_1_1presburger_1_1IntegerRelation_1_1CountsSnapshot.html">CountsSnapshot</a> &amp;counts)</td></tr>
<tr class="separator:a2ec8498e71a2011cbb2f451e77a3673d inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e22f243bfe012e09a93fcb3c092a7e inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a51e22f243bfe012e09a93fcb3c092a7e">appendVar</a> (<a class="el" href="namespacemlir_1_1presburger.html#a0fa2eacf0a4f6b3656064ea54f8d3c35">VarKind</a> kind, unsigned num=1)</td></tr>
<tr class="memdesc:a51e22f243bfe012e09a93fcb3c092a7e inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append <code>num</code> variables of the specified kind after the last variable of that kind.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a51e22f243bfe012e09a93fcb3c092a7e">More...</a><br /></td></tr>
<tr class="separator:a51e22f243bfe012e09a93fcb3c092a7e inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174e4816920d6acbe120e3f85eea7a64 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a174e4816920d6acbe120e3f85eea7a64">addInequality</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1presburger_1_1MPInt.html">MPInt</a> &gt; inEq)</td></tr>
<tr class="memdesc:a174e4816920d6acbe120e3f85eea7a64 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an inequality (&gt;= 0) from the coefficients specified in <code>inEq</code>.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a174e4816920d6acbe120e3f85eea7a64">More...</a><br /></td></tr>
<tr class="separator:a174e4816920d6acbe120e3f85eea7a64 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0998b9826122a535bfcca8cc3311e629 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a0998b9826122a535bfcca8cc3311e629">addInequality</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; inEq)</td></tr>
<tr class="separator:a0998b9826122a535bfcca8cc3311e629 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256db2ed95ac2e5e4a4e9d6ceb8cc57a inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a256db2ed95ac2e5e4a4e9d6ceb8cc57a">addEquality</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1presburger_1_1MPInt.html">MPInt</a> &gt; eq)</td></tr>
<tr class="memdesc:a256db2ed95ac2e5e4a4e9d6ceb8cc57a inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an equality from the coefficients specified in <code>eq</code>.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a256db2ed95ac2e5e4a4e9d6ceb8cc57a">More...</a><br /></td></tr>
<tr class="separator:a256db2ed95ac2e5e4a4e9d6ceb8cc57a inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a70d8630f9bfd2b1880ba5d2d2c936c inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a6a70d8630f9bfd2b1880ba5d2d2c936c">addEquality</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; eq)</td></tr>
<tr class="separator:a6a70d8630f9bfd2b1880ba5d2d2c936c inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2fadd60de5caaf013fe6b347d16ea5 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a2f2fadd60de5caaf013fe6b347d16ea5">eliminateRedundantLocalVar</a> (unsigned posA, unsigned posB)</td></tr>
<tr class="memdesc:a2f2fadd60de5caaf013fe6b347d16ea5 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate the <code>posB^th</code> local variable, replacing every instance of it with the <code>posA^th</code> local variable.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a2f2fadd60de5caaf013fe6b347d16ea5">More...</a><br /></td></tr>
<tr class="separator:a2f2fadd60de5caaf013fe6b347d16ea5 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12e12e3b772fa42e807e46f8563a58b inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ac12e12e3b772fa42e807e46f8563a58b">removeVar</a> (<a class="el" href="namespacemlir_1_1presburger.html#a0fa2eacf0a4f6b3656064ea54f8d3c35">VarKind</a> kind, unsigned pos)</td></tr>
<tr class="memdesc:ac12e12e3b772fa42e807e46f8563a58b inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes variables of the specified kind with the specified pos (or within the specified range) from the system.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#ac12e12e3b772fa42e807e46f8563a58b">More...</a><br /></td></tr>
<tr class="separator:ac12e12e3b772fa42e807e46f8563a58b inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae418563794bea2dffbd358ae5e8e78ca inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ae418563794bea2dffbd358ae5e8e78ca">removeVar</a> (unsigned pos)</td></tr>
<tr class="memdesc:ae418563794bea2dffbd358ae5e8e78ca inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified variable from the system.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#ae418563794bea2dffbd358ae5e8e78ca">More...</a><br /></td></tr>
<tr class="separator:ae418563794bea2dffbd358ae5e8e78ca inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee8ece23dbafb7d8589b5c276f6050e inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a3ee8ece23dbafb7d8589b5c276f6050e">removeEquality</a> (unsigned pos)</td></tr>
<tr class="separator:a3ee8ece23dbafb7d8589b5c276f6050e inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8131b65d378ed96aa21caddb24ea794 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ac8131b65d378ed96aa21caddb24ea794">removeInequality</a> (unsigned pos)</td></tr>
<tr class="separator:ac8131b65d378ed96aa21caddb24ea794 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366deee545d5b19e6c58720758316a09 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a366deee545d5b19e6c58720758316a09">removeEqualityRange</a> (unsigned start, unsigned end)</td></tr>
<tr class="memdesc:a366deee545d5b19e6c58720758316a09 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the (in)equalities at positions [start, end).  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a366deee545d5b19e6c58720758316a09">More...</a><br /></td></tr>
<tr class="separator:a366deee545d5b19e6c58720758316a09 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27195ff4c05a11fcbe8c2414737c5757 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a27195ff4c05a11fcbe8c2414737c5757">removeInequalityRange</a> (unsigned start, unsigned end)</td></tr>
<tr class="separator:a27195ff4c05a11fcbe8c2414737c5757 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2de214b91887bc196761e5882616171 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1MaybeOptimum.html">MaybeOptimum</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1presburger_1_1Fraction.html">Fraction</a>, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ae2de214b91887bc196761e5882616171">findRationalLexMin</a> () const</td></tr>
<tr class="memdesc:ae2de214b91887bc196761e5882616171 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the lexicographically minimum rational point satisfying the constraints.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#ae2de214b91887bc196761e5882616171">More...</a><br /></td></tr>
<tr class="separator:ae2de214b91887bc196761e5882616171 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbbb8ea40f08c761eac2333e4dbe43a inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1MaybeOptimum.html">MaybeOptimum</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1presburger_1_1MPInt.html">MPInt</a>, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a6dbbb8ea40f08c761eac2333e4dbe43a">findIntegerLexMin</a> () const</td></tr>
<tr class="memdesc:a6dbbb8ea40f08c761eac2333e4dbe43a inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, but returns lexicographically minimal integer point.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a6dbbb8ea40f08c761eac2333e4dbe43a">More...</a><br /></td></tr>
<tr class="separator:a6dbbb8ea40f08c761eac2333e4dbe43a inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1032a361b5d13e18746696b7f1af41 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a7a1032a361b5d13e18746696b7f1af41">clearConstraints</a> ()</td></tr>
<tr class="memdesc:a7a1032a361b5d13e18746696b7f1af41 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all equalities and inequalities.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a7a1032a361b5d13e18746696b7f1af41">More...</a><br /></td></tr>
<tr class="separator:a7a1032a361b5d13e18746696b7f1af41 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9aaa05382e987aa754f4c6b236badc2 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad9aaa05382e987aa754f4c6b236badc2">setAndEliminate</a> (unsigned pos, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1presburger_1_1MPInt.html">MPInt</a> &gt; values)</td></tr>
<tr class="memdesc:ad9aaa05382e987aa754f4c6b236badc2 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code>values.size()</code> variables starting at <code>po</code>s to the specified values and removes them.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#ad9aaa05382e987aa754f4c6b236badc2">More...</a><br /></td></tr>
<tr class="separator:ad9aaa05382e987aa754f4c6b236badc2 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a249925e889f2e41b076a61fea8d32c inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a0a249925e889f2e41b076a61fea8d32c">setAndEliminate</a> (unsigned pos, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; values)</td></tr>
<tr class="separator:a0a249925e889f2e41b076a61fea8d32c inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada75d3d4cb6bc695ad94626853e4b43e inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ada75d3d4cb6bc695ad94626853e4b43e">clearAndCopyFrom</a> (const <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> &amp;other)</td></tr>
<tr class="memdesc:ada75d3d4cb6bc695ad94626853e4b43e inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of this <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html" title="An IntegerRelation represents the set of points from a PresburgerSpace that satisfy a list of affine ...">IntegerRelation</a> with <code>other</code>.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#ada75d3d4cb6bc695ad94626853e4b43e">More...</a><br /></td></tr>
<tr class="separator:ada75d3d4cb6bc695ad94626853e4b43e inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4ff7884644e641bc5affa78ce467d8 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#abe4ff7884644e641bc5affa78ce467d8">getLowerAndUpperBoundIndices</a> (unsigned pos, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; unsigned &gt; *lbIndices, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; unsigned &gt; *ubIndices, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; unsigned &gt; *eqIndices=nullptr, unsigned offset=0, unsigned num=0) const</td></tr>
<tr class="memdesc:abe4ff7884644e641bc5affa78ce467d8 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather positions of all lower and upper bounds of the variable at <code>pos</code>, and optionally any equalities on it.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#abe4ff7884644e641bc5affa78ce467d8">More...</a><br /></td></tr>
<tr class="separator:abe4ff7884644e641bc5affa78ce467d8 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9cb516db541340c61ca0ec56050220 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#abc9cb516db541340c61ca0ec56050220">isEmpty</a> () const</td></tr>
<tr class="memdesc:abc9cb516db541340c61ca0ec56050220 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for emptiness by performing variable elimination on all variables, running the GCD test on each equality constraint, and checking for invalid constraints.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#abc9cb516db541340c61ca0ec56050220">More...</a><br /></td></tr>
<tr class="separator:abc9cb516db541340c61ca0ec56050220 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468688279f14239bf08f335ad4d962be inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a468688279f14239bf08f335ad4d962be">isEmptyByGCDTest</a> () const</td></tr>
<tr class="memdesc:a468688279f14239bf08f335ad4d962be inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the GCD test on all equality constraints.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a468688279f14239bf08f335ad4d962be">More...</a><br /></td></tr>
<tr class="separator:a468688279f14239bf08f335ad4d962be inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4dc5a7b42cac79a365bbe7ef8851d0 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a5e4dc5a7b42cac79a365bbe7ef8851d0">isIntegerEmpty</a> () const</td></tr>
<tr class="memdesc:a5e4dc5a7b42cac79a365bbe7ef8851d0 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the set of constraints is found to have no solution, false if a solution exists.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a5e4dc5a7b42cac79a365bbe7ef8851d0">More...</a><br /></td></tr>
<tr class="separator:a5e4dc5a7b42cac79a365bbe7ef8851d0 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed78b98159cc85380412dd4c7f0eb31 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a7ed78b98159cc85380412dd4c7f0eb31">getBoundedDirections</a> () const</td></tr>
<tr class="memdesc:a7ed78b98159cc85380412dd4c7f0eb31 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix where each row is a vector along which the polytope is bounded.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a7ed78b98159cc85380412dd4c7f0eb31">More...</a><br /></td></tr>
<tr class="separator:a7ed78b98159cc85380412dd4c7f0eb31 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac344e237cb8b41f906a2c86fa89957 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1presburger_1_1MPInt.html">MPInt</a>, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a2ac344e237cb8b41f906a2c86fa89957">findIntegerSample</a> () const</td></tr>
<tr class="memdesc:a2ac344e237cb8b41f906a2c86fa89957 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an integer sample point satisfying the constraints using a branch and bound algorithm with generalized basis reduction, with some additional processing using <a class="el" href="classmlir_1_1presburger_1_1Simplex.html" title="The Simplex class uses the Normal pivot rule and supports integer emptiness checks as well as detecti...">Simplex</a> for unbounded sets.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a2ac344e237cb8b41f906a2c86fa89957">More...</a><br /></td></tr>
<tr class="separator:a2ac344e237cb8b41f906a2c86fa89957 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c1907eb475a1e283d737b1b1bc4217 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1presburger_1_1MPInt.html">MPInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a60c1907eb475a1e283d737b1b1bc4217">computeVolume</a> () const</td></tr>
<tr class="memdesc:a60c1907eb475a1e283d737b1b1bc4217 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an overapproximation of the number of integer points in the relation.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a60c1907eb475a1e283d737b1b1bc4217">More...</a><br /></td></tr>
<tr class="separator:a60c1907eb475a1e283d737b1b1bc4217 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54479dec47b42db8790e8c3351cb69e inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#af54479dec47b42db8790e8c3351cb69e">containsPoint</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1presburger_1_1MPInt.html">MPInt</a> &gt; point) const</td></tr>
<tr class="memdesc:af54479dec47b42db8790e8c3351cb69e inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given point satisfies the constraints, or false otherwise.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#af54479dec47b42db8790e8c3351cb69e">More...</a><br /></td></tr>
<tr class="separator:af54479dec47b42db8790e8c3351cb69e inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b5313b7a49ae9919c1169cb427bb17 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a72b5313b7a49ae9919c1169cb427bb17">containsPoint</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; point) const</td></tr>
<tr class="separator:a72b5313b7a49ae9919c1169cb427bb17 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1233ac82c5bff041ab5ca1671c9b42 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1presburger_1_1MPInt.html">MPInt</a>, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a8c1233ac82c5bff041ab5ca1671c9b42">containsPointNoLocal</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1presburger_1_1MPInt.html">MPInt</a> &gt; point) const</td></tr>
<tr class="memdesc:a8c1233ac82c5bff041ab5ca1671c9b42 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the values of non-local vars, return a satisfying assignment to the local if one exists, or an empty optional otherwise.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a8c1233ac82c5bff041ab5ca1671c9b42">More...</a><br /></td></tr>
<tr class="separator:a8c1233ac82c5bff041ab5ca1671c9b42 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67aea7b578ffbd2d0b595273847a113c inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1presburger_1_1MPInt.html">MPInt</a>, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a67aea7b578ffbd2d0b595273847a113c">containsPointNoLocal</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; point) const</td></tr>
<tr class="separator:a67aea7b578ffbd2d0b595273847a113c inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27fd4ad3f8ffde8937ce12a3e33ba67 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1DivisionRepr.html">DivisionRepr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad27fd4ad3f8ffde8937ce12a3e33ba67">getLocalReprs</a> (std::vector&lt; <a class="el" href="structmlir_1_1presburger_1_1MaybeLocalRepr.html">MaybeLocalRepr</a> &gt; *repr=nullptr) const</td></tr>
<tr class="memdesc:ad27fd4ad3f8ffde8937ce12a3e33ba67 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code>DivisonRepr</code> representing the division representation of local variables in the constraint system.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#ad27fd4ad3f8ffde8937ce12a3e33ba67">More...</a><br /></td></tr>
<tr class="separator:ad27fd4ad3f8ffde8937ce12a3e33ba67 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb91a85a929ffad93a213ed923cb9906 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#acb91a85a929ffad93a213ed923cb9906">addBound</a> (<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabc">BoundType</a> type, unsigned pos, const <a class="el" href="classmlir_1_1presburger_1_1MPInt.html">MPInt</a> &amp;<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="memdesc:acb91a85a929ffad93a213ed923cb9906 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant bound for the specified variable.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#acb91a85a929ffad93a213ed923cb9906">More...</a><br /></td></tr>
<tr class="separator:acb91a85a929ffad93a213ed923cb9906 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8858705bd57b66ab0397ccd530dbda inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a1f8858705bd57b66ab0397ccd530dbda">addBound</a> (<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabc">BoundType</a> type, unsigned pos, int64_t <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="separator:a1f8858705bd57b66ab0397ccd530dbda inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af345b13f9d33da7feda358329867a934 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#af345b13f9d33da7feda358329867a934">addBound</a> (<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabc">BoundType</a> type, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1presburger_1_1MPInt.html">MPInt</a> &gt; expr, const <a class="el" href="classmlir_1_1presburger_1_1MPInt.html">MPInt</a> &amp;<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="memdesc:af345b13f9d33da7feda358329867a934 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant bound for the specified expression.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#af345b13f9d33da7feda358329867a934">More...</a><br /></td></tr>
<tr class="separator:af345b13f9d33da7feda358329867a934 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd90cf57684a0dfb795e8ebb1ae1ed26 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#acd90cf57684a0dfb795e8ebb1ae1ed26">addBound</a> (<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabc">BoundType</a> type, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; expr, int64_t <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="separator:acd90cf57684a0dfb795e8ebb1ae1ed26 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8505ffc525b50eee871963c5d573704f inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a8505ffc525b50eee871963c5d573704f">addLocalFloorDiv</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1presburger_1_1MPInt.html">MPInt</a> &gt; dividend, const <a class="el" href="classmlir_1_1presburger_1_1MPInt.html">MPInt</a> &amp;divisor)</td></tr>
<tr class="memdesc:a8505ffc525b50eee871963c5d573704f inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new local variable as the floordiv of an affine function of other variables, the coefficients of which are provided in <code>dividend</code> and with respect to a positive constant <code>divisor</code>.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a8505ffc525b50eee871963c5d573704f">More...</a><br /></td></tr>
<tr class="separator:a8505ffc525b50eee871963c5d573704f inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf32e3e07ef4c2e82b7c5650524bdf3b inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#aaf32e3e07ef4c2e82b7c5650524bdf3b">addLocalFloorDiv</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; dividend, int64_t divisor)</td></tr>
<tr class="separator:aaf32e3e07ef4c2e82b7c5650524bdf3b inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabbad10f2e180e48ad4e83b0ccf7b2f inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#adabbad10f2e180e48ad4e83b0ccf7b2f">projectOut</a> (unsigned pos, unsigned num)</td></tr>
<tr class="memdesc:adabbad10f2e180e48ad4e83b0ccf7b2f inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects out (aka eliminates) <code>num</code> variables starting at position <code>pos</code>.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#adabbad10f2e180e48ad4e83b0ccf7b2f">More...</a><br /></td></tr>
<tr class="separator:adabbad10f2e180e48ad4e83b0ccf7b2f inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdfc93dbe7dc28f69e638426bb6d3b6 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a6bdfc93dbe7dc28f69e638426bb6d3b6">projectOut</a> (unsigned pos)</td></tr>
<tr class="separator:a6bdfc93dbe7dc28f69e638426bb6d3b6 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b32c5e21751fc494c05475197c51f2f inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a3b32c5e21751fc494c05475197c51f2f">constantFoldVar</a> (unsigned pos)</td></tr>
<tr class="memdesc:a3b32c5e21751fc494c05475197c51f2f inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to fold the specified variable to a constant using a trivial equality detection; if successful, the constant is substituted for the variable everywhere in the constraint system and then removed from the system.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a3b32c5e21751fc494c05475197c51f2f">More...</a><br /></td></tr>
<tr class="separator:a3b32c5e21751fc494c05475197c51f2f inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba142cab80ee16fa8bc4f08c0da47467 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#aba142cab80ee16fa8bc4f08c0da47467">constantFoldVarRange</a> (unsigned pos, unsigned num)</td></tr>
<tr class="memdesc:aba142cab80ee16fa8bc4f08c0da47467 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method calls <code>constantFoldVar</code> for the specified range of variables, <code>num</code> variables starting at position <code>pos</code>.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#aba142cab80ee16fa8bc4f08c0da47467">More...</a><br /></td></tr>
<tr class="separator:aba142cab80ee16fa8bc4f08c0da47467 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719304f13882671a30b3cf814c11a157 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a719304f13882671a30b3cf814c11a157">unionBoundingBox</a> (const <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> &amp;other)</td></tr>
<tr class="memdesc:a719304f13882671a30b3cf814c11a157 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the constraints to be the smallest bounding (enclosing) box that contains the points of <code>this</code> set and that of <code>other</code>, with the symbols being treated specially.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a719304f13882671a30b3cf814c11a157">More...</a><br /></td></tr>
<tr class="separator:a719304f13882671a30b3cf814c11a157 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594ad340b3c7501c946484c80f194ff8 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1presburger_1_1MPInt.html">MPInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a594ad340b3c7501c946484c80f194ff8">getConstantBoundOnDimSize</a> (unsigned pos, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1presburger_1_1MPInt.html">MPInt</a> &gt; *lb=nullptr, <a class="el" href="classmlir_1_1presburger_1_1MPInt.html">MPInt</a> *boundFloorDivisor=nullptr, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1presburger_1_1MPInt.html">MPInt</a> &gt; *ub=nullptr, unsigned *minLbPos=nullptr, unsigned *minUbPos=nullptr) const</td></tr>
<tr class="memdesc:a594ad340b3c7501c946484c80f194ff8 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest known constant bound for the extent of the specified variable (pos^th), i.e., the smallest known constant that is greater than or equal to 'exclusive upper bound' - 'lower bound' of the variable.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a594ad340b3c7501c946484c80f194ff8">More...</a><br /></td></tr>
<tr class="separator:a594ad340b3c7501c946484c80f194ff8 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade17ada7094a9ca8a41366f37e2fef42 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ade17ada7094a9ca8a41366f37e2fef42">getConstantBoundOnDimSize64</a> (unsigned pos, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *lb=nullptr, int64_t *boundFloorDivisor=nullptr, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *ub=nullptr, unsigned *minLbPos=nullptr, unsigned *minUbPos=nullptr) const</td></tr>
<tr class="memdesc:ade17ada7094a9ca8a41366f37e2fef42 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same, but casts to int64_t.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#ade17ada7094a9ca8a41366f37e2fef42">More...</a><br /></td></tr>
<tr class="separator:ade17ada7094a9ca8a41366f37e2fef42 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b00fe64f80f2eb91d8057316fa7bc9 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1presburger_1_1MPInt.html">MPInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a14b00fe64f80f2eb91d8057316fa7bc9">getConstantBound</a> (<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabc">BoundType</a> type, unsigned pos) const</td></tr>
<tr class="memdesc:a14b00fe64f80f2eb91d8057316fa7bc9 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant bound for the pos^th variable if there is one; None otherwise.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a14b00fe64f80f2eb91d8057316fa7bc9">More...</a><br /></td></tr>
<tr class="separator:a14b00fe64f80f2eb91d8057316fa7bc9 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4b3560a7c19dc970b87710921479de inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a0f4b3560a7c19dc970b87710921479de">getConstantBound64</a> (<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabc">BoundType</a> type, unsigned pos) const</td></tr>
<tr class="memdesc:a0f4b3560a7c19dc970b87710921479de inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same, but casts to int64_t.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a0f4b3560a7c19dc970b87710921479de">More...</a><br /></td></tr>
<tr class="separator:a0f4b3560a7c19dc970b87710921479de inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104c727179405d556154c39affb331b2 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a104c727179405d556154c39affb331b2">removeIndependentConstraints</a> (unsigned pos, unsigned num)</td></tr>
<tr class="memdesc:a104c727179405d556154c39affb331b2 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes constraints that are independent of (i.e., do not have a coefficient) variables in the range [pos, pos + num).  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a104c727179405d556154c39affb331b2">More...</a><br /></td></tr>
<tr class="separator:a104c727179405d556154c39affb331b2 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7330cb99e897efa1d60f9698a85e8837 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a7330cb99e897efa1d60f9698a85e8837">isHyperRectangular</a> (unsigned pos, unsigned num) const</td></tr>
<tr class="memdesc:a7330cb99e897efa1d60f9698a85e8837 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the set can be trivially detected as being hyper-rectangular on the specified contiguous set of variables.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a7330cb99e897efa1d60f9698a85e8837">More...</a><br /></td></tr>
<tr class="separator:a7330cb99e897efa1d60f9698a85e8837 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7092c24389f40c685372f3fa1e0edc inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a1c7092c24389f40c685372f3fa1e0edc">removeTrivialRedundancy</a> ()</td></tr>
<tr class="memdesc:a1c7092c24389f40c685372f3fa1e0edc inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes duplicate constraints, trivially true constraints, and constraints that can be detected as redundant as a result of differing only in their constant term part.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a1c7092c24389f40c685372f3fa1e0edc">More...</a><br /></td></tr>
<tr class="separator:a1c7092c24389f40c685372f3fa1e0edc inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7fccd1b94334c1054cfa10e920ee942 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#aa7fccd1b94334c1054cfa10e920ee942">removeRedundantInequalities</a> ()</td></tr>
<tr class="memdesc:aa7fccd1b94334c1054cfa10e920ee942 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">A more expensive check than <code>removeTrivialRedundancy</code> to detect redundant inequalities.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#aa7fccd1b94334c1054cfa10e920ee942">More...</a><br /></td></tr>
<tr class="separator:aa7fccd1b94334c1054cfa10e920ee942 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ddc803d4b5a2cad1ff6e117940cdf2 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#aa2ddc803d4b5a2cad1ff6e117940cdf2">removeRedundantConstraints</a> ()</td></tr>
<tr class="memdesc:aa2ddc803d4b5a2cad1ff6e117940cdf2 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes redundant constraints using <a class="el" href="classmlir_1_1presburger_1_1Simplex.html" title="The Simplex class uses the Normal pivot rule and supports integer emptiness checks as well as detecti...">Simplex</a>.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#aa2ddc803d4b5a2cad1ff6e117940cdf2">More...</a><br /></td></tr>
<tr class="separator:aa2ddc803d4b5a2cad1ff6e117940cdf2 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cffb0333901dbef827d4a550880177c inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a4cffb0333901dbef827d4a550880177c">removeDuplicateDivs</a> ()</td></tr>
<tr class="separator:a4cffb0333901dbef827d4a550880177c inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a528c00177b2b99b79756aa428f738f inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a4a528c00177b2b99b79756aa428f738f">convertVarKind</a> (<a class="el" href="namespacemlir_1_1presburger.html#a0fa2eacf0a4f6b3656064ea54f8d3c35">VarKind</a> srcKind, unsigned varStart, unsigned varLimit, <a class="el" href="namespacemlir_1_1presburger.html#a0fa2eacf0a4f6b3656064ea54f8d3c35">VarKind</a> dstKind, unsigned pos)</td></tr>
<tr class="memdesc:a4a528c00177b2b99b79756aa428f738f inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts variables of kind srcKind in the range [varStart, varLimit) to variables of kind dstKind.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a4a528c00177b2b99b79756aa428f738f">More...</a><br /></td></tr>
<tr class="separator:a4a528c00177b2b99b79756aa428f738f inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28679820ccfa889210785a54220e6831 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a28679820ccfa889210785a54220e6831">convertVarKind</a> (<a class="el" href="namespacemlir_1_1presburger.html#a0fa2eacf0a4f6b3656064ea54f8d3c35">VarKind</a> srcKind, unsigned varStart, unsigned varLimit, <a class="el" href="namespacemlir_1_1presburger.html#a0fa2eacf0a4f6b3656064ea54f8d3c35">VarKind</a> dstKind)</td></tr>
<tr class="separator:a28679820ccfa889210785a54220e6831 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e24c813009114863524feb91bddd93 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a73e24c813009114863524feb91bddd93">convertToLocal</a> (<a class="el" href="namespacemlir_1_1presburger.html#a0fa2eacf0a4f6b3656064ea54f8d3c35">VarKind</a> kind, unsigned varStart, unsigned varLimit)</td></tr>
<tr class="separator:a73e24c813009114863524feb91bddd93 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0dd9432990e2d687ba9c4757586c0bf inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ae0dd9432990e2d687ba9c4757586c0bf">mergeLocalVars</a> (<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> &amp;other)</td></tr>
<tr class="memdesc:ae0dd9432990e2d687ba9c4757586c0bf inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds additional local vars to the sets such that they both have the union of the local vars in each set, without changing the set of points that lie in <code>this</code> and <code>other</code>.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#ae0dd9432990e2d687ba9c4757586c0bf">More...</a><br /></td></tr>
<tr class="separator:ae0dd9432990e2d687ba9c4757586c0bf inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2985f4dab6d7051d91aa0349d3285bc inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad2985f4dab6d7051d91aa0349d3285bc">hasOnlyDivLocals</a> () const</td></tr>
<tr class="memdesc:ad2985f4dab6d7051d91aa0349d3285bc inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether all local ids have a division representation.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#ad2985f4dab6d7051d91aa0349d3285bc">More...</a><br /></td></tr>
<tr class="separator:ad2985f4dab6d7051d91aa0349d3285bc inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8da36de3e0a65e95962f4be956c719 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a9f8da36de3e0a65e95962f4be956c719">setDimSymbolSeparation</a> (unsigned newSymbolCount)</td></tr>
<tr class="memdesc:a9f8da36de3e0a65e95962f4be956c719 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the partition between dimensions and symbols.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a9f8da36de3e0a65e95962f4be956c719">More...</a><br /></td></tr>
<tr class="separator:a9f8da36de3e0a65e95962f4be956c719 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfd1dab782fa03d0aad3b386cbde7d1 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html">IntegerPolyhedron</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#accfd1dab782fa03d0aad3b386cbde7d1">getDomainSet</a> () const</td></tr>
<tr class="memdesc:accfd1dab782fa03d0aad3b386cbde7d1 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a set corresponding to all points in the domain of the relation.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#accfd1dab782fa03d0aad3b386cbde7d1">More...</a><br /></td></tr>
<tr class="separator:accfd1dab782fa03d0aad3b386cbde7d1 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421e8e84b5cd324feacedc8e99ffe404 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html">IntegerPolyhedron</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a421e8e84b5cd324feacedc8e99ffe404">getRangeSet</a> () const</td></tr>
<tr class="memdesc:a421e8e84b5cd324feacedc8e99ffe404 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a set corresponding to all points in the range of the relation.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a421e8e84b5cd324feacedc8e99ffe404">More...</a><br /></td></tr>
<tr class="separator:a421e8e84b5cd324feacedc8e99ffe404 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bb4e5fc1603ce2e22bcb50e2e17624 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a98bb4e5fc1603ce2e22bcb50e2e17624">intersectDomain</a> (const <a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html">IntegerPolyhedron</a> &amp;poly)</td></tr>
<tr class="memdesc:a98bb4e5fc1603ce2e22bcb50e2e17624 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersect the given <code>poly</code> with the domain in-place.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a98bb4e5fc1603ce2e22bcb50e2e17624">More...</a><br /></td></tr>
<tr class="separator:a98bb4e5fc1603ce2e22bcb50e2e17624 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537d64849cd479b16ab3d57121a2f712 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a537d64849cd479b16ab3d57121a2f712">intersectRange</a> (const <a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html">IntegerPolyhedron</a> &amp;poly)</td></tr>
<tr class="memdesc:a537d64849cd479b16ab3d57121a2f712 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersect the given <code>poly</code> with the range in-place.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a537d64849cd479b16ab3d57121a2f712">More...</a><br /></td></tr>
<tr class="separator:a537d64849cd479b16ab3d57121a2f712 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc5d877edb668dacb6500a4c6ed587a inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a8fc5d877edb668dacb6500a4c6ed587a">inverse</a> ()</td></tr>
<tr class="memdesc:a8fc5d877edb668dacb6500a4c6ed587a inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the relation i.e., swap its domain and range.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a8fc5d877edb668dacb6500a4c6ed587a">More...</a><br /></td></tr>
<tr class="separator:a8fc5d877edb668dacb6500a4c6ed587a inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d0c5c95afd0a4d4e446d2db51098e5 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a13d0c5c95afd0a4d4e446d2db51098e5">compose</a> (const <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> &amp;rel)</td></tr>
<tr class="memdesc:a13d0c5c95afd0a4d4e446d2db51098e5 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let the relation <code>this</code> be R1, and the relation <code>rel</code> be R2.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a13d0c5c95afd0a4d4e446d2db51098e5">More...</a><br /></td></tr>
<tr class="separator:a13d0c5c95afd0a4d4e446d2db51098e5 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92435e6e4134ab44b49a17897b99c1b8 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a92435e6e4134ab44b49a17897b99c1b8">applyDomain</a> (const <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> &amp;rel)</td></tr>
<tr class="memdesc:a92435e6e4134ab44b49a17897b99c1b8 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a relation <code>rel</code>, apply the relation to the domain of this relation.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a92435e6e4134ab44b49a17897b99c1b8">More...</a><br /></td></tr>
<tr class="separator:a92435e6e4134ab44b49a17897b99c1b8 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1481aacbad61e7f4106387b978577c6d inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a1481aacbad61e7f4106387b978577c6d">applyRange</a> (const <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> &amp;rel)</td></tr>
<tr class="memdesc:a1481aacbad61e7f4106387b978577c6d inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a relation <code>rel</code>, apply the relation to the range of this relation.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a1481aacbad61e7f4106387b978577c6d">More...</a><br /></td></tr>
<tr class="separator:a1481aacbad61e7f4106387b978577c6d inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30428cce2f63b146a2559b94f1ce1aa inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1PresburgerRelation.html">PresburgerRelation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#aa30428cce2f63b146a2559b94f1ce1aa">computeReprWithOnlyDivLocals</a> () const</td></tr>
<tr class="memdesc:aa30428cce2f63b146a2559b94f1ce1aa inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an equivalent representation of the same set, such that all local vars in all disjuncts have division representations.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#aa30428cce2f63b146a2559b94f1ce1aa">More...</a><br /></td></tr>
<tr class="separator:aa30428cce2f63b146a2559b94f1ce1aa inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0445bd4742bbbeb298327adc3ccf380d inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1presburger_1_1SymbolicLexMin.html">SymbolicLexMin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a0445bd4742bbbeb298327adc3ccf380d">findSymbolicIntegerLexMin</a> () const</td></tr>
<tr class="memdesc:a0445bd4742bbbeb298327adc3ccf380d inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the symbolic integer lexmin of the relation.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a0445bd4742bbbeb298327adc3ccf380d">More...</a><br /></td></tr>
<tr class="separator:a0445bd4742bbbeb298327adc3ccf380d inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99aa00e264b7f6c68f3a31410402fded inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1PresburgerRelation.html">PresburgerRelation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a99aa00e264b7f6c68f3a31410402fded">subtract</a> (const <a class="el" href="classmlir_1_1presburger_1_1PresburgerRelation.html">PresburgerRelation</a> &amp;set) const</td></tr>
<tr class="memdesc:a99aa00e264b7f6c68f3a31410402fded inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the set difference of this set and the given set, i.e., return <code>this \ set</code>.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a99aa00e264b7f6c68f3a31410402fded">More...</a><br /></td></tr>
<tr class="separator:a99aa00e264b7f6c68f3a31410402fded inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa3bb83ac8ceaee9d417b70d738e2c2 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a5aa3bb83ac8ceaee9d417b70d738e2c2">print</a> (raw_ostream &amp;os) const</td></tr>
<tr class="separator:a5aa3bb83ac8ceaee9d417b70d738e2c2 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea7be3fe92622dbf73699a113ea8a32 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a7ea7be3fe92622dbf73699a113ea8a32">dump</a> () const</td></tr>
<tr class="separator:a7ea7be3fe92622dbf73699a113ea8a32 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:acfee23f39d31078e69df752b973f53b6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#acfee23f39d31078e69df752b973f53b6">getHyperrectangular</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ivs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs)</td></tr>
<tr class="separator:acfee23f39d31078e69df752b973f53b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407729200db5589c49636b07bc2fd359"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a407729200db5589c49636b07bc2fd359">classof</a> (const <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a720bc08a94b0b8e26ffffedebf24fc1c">IntegerRelation</a> *cst)</td></tr>
<tr class="separator:a407729200db5589c49636b07bc2fd359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmlir_1_1presburger_1_1IntegerPolyhedron')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html">mlir::presburger::IntegerPolyhedron</a></td></tr>
<tr class="memitem:af18fc68c685606bccf0edb704eeaa219 inherit pub_static_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html">IntegerPolyhedron</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#af18fc68c685606bccf0edb704eeaa219">getUniverse</a> (const <a class="el" href="classmlir_1_1presburger_1_1PresburgerSpace.html">PresburgerSpace</a> &amp;<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a80fe301a2d8c1e77d84894aaaae00db8">space</a>)</td></tr>
<tr class="memdesc:af18fc68c685606bccf0edb704eeaa219 inherit pub_static_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a system with no constraints, i.e., one which is satisfied by all points.  <a href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#af18fc68c685606bccf0edb704eeaa219">More...</a><br /></td></tr>
<tr class="separator:af18fc68c685606bccf0edb704eeaa219 inherit pub_static_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f190eec942f4e6154a5be167baf6f42 inherit pub_static_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#a3f190eec942f4e6154a5be167baf6f42">classof</a> (const <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> *cst)</td></tr>
<tr class="separator:a3f190eec942f4e6154a5be167baf6f42 inherit pub_static_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classmlir_1_1presburger_1_1IntegerRelation"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmlir_1_1presburger_1_1IntegerRelation')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">mlir::presburger::IntegerRelation</a></td></tr>
<tr class="memitem:a8b410fc634df082bfe60882342a295f6 inherit pub_static_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a8b410fc634df082bfe60882342a295f6">getUniverse</a> (const <a class="el" href="classmlir_1_1presburger_1_1PresburgerSpace.html">PresburgerSpace</a> &amp;<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a80fe301a2d8c1e77d84894aaaae00db8">space</a>)</td></tr>
<tr class="memdesc:a8b410fc634df082bfe60882342a295f6 inherit pub_static_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a system with no constraints, i.e., one which is satisfied by all points.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a8b410fc634df082bfe60882342a295f6">More...</a><br /></td></tr>
<tr class="separator:a8b410fc634df082bfe60882342a295f6 inherit pub_static_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf3b75527052c848183b6f0e6750bfd inherit pub_static_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a2cf3b75527052c848183b6f0e6750bfd">classof</a> (const <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> *cst)</td></tr>
<tr class="separator:a2cf3b75527052c848183b6f0e6750bfd inherit pub_static_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a7234b85808ebeba69ccbe37452e61d9d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a7234b85808ebeba69ccbe37452e61d9d">VarKind</a> = <a class="el" href="namespacemlir_1_1presburger.html#a0fa2eacf0a4f6b3656064ea54f8d3c35">presburger::VarKind</a></td></tr>
<tr class="separator:a7234b85808ebeba69ccbe37452e61d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3202cddcf31d0798de72cac6742248b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a3202cddcf31d0798de72cac6742248b0">hasConsistentState</a> () const override</td></tr>
<tr class="memdesc:a3202cddcf31d0798de72cac6742248b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns false if the fields corresponding to various variable counts, or equality/inequality buffer sizes aren't consistent; true otherwise.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a3202cddcf31d0798de72cac6742248b0">More...</a><br /></td></tr>
<tr class="separator:a3202cddcf31d0798de72cac6742248b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec33e9ae86390c8f29078675dd53870e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#aec33e9ae86390c8f29078675dd53870e">flattenAlignedMapAndMergeLocals</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *flattenedExprs)</td></tr>
<tr class="memdesc:aec33e9ae86390c8f29078675dd53870e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an affine map that is aligned with this constraint system:  <a href="classmlir_1_1FlatAffineValueConstraints.html#aec33e9ae86390c8f29078675dd53870e">More...</a><br /></td></tr>
<tr class="separator:aec33e9ae86390c8f29078675dd53870e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b3ca6765edfa5677b1b23130e0187c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a30b3ca6765edfa5677b1b23130e0187c">fourierMotzkinEliminate</a> (unsigned pos, bool darkShadow=false, bool *isResultIntegerExact=nullptr) override</td></tr>
<tr class="memdesc:a30b3ca6765edfa5677b1b23130e0187c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates the variable at the specified position using Fourier-Motzkin variable elimination, but uses Gaussian elimination if there is an equality involving that variable.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a30b3ca6765edfa5677b1b23130e0187c">More...</a><br /></td></tr>
<tr class="separator:a30b3ca6765edfa5677b1b23130e0187c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22f9e8a2b6d20dbe52378823edc5a9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ab22f9e8a2b6d20dbe52378823edc5a9c">printSpace</a> (raw_ostream &amp;os) const override</td></tr>
<tr class="memdesc:ab22f9e8a2b6d20dbe52378823edc5a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the number of constraints, dimensions, symbols and locals in the FlatAffineConstraints.  <a href="classmlir_1_1FlatAffineValueConstraints.html#ab22f9e8a2b6d20dbe52378823edc5a9c">More...</a><br /></td></tr>
<tr class="separator:ab22f9e8a2b6d20dbe52378823edc5a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmlir_1_1presburger_1_1IntegerRelation')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">mlir::presburger::IntegerRelation</a></td></tr>
<tr class="memitem:a70fa88c51b843b4c4a1a72028172198e inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a70fa88c51b843b4c4a1a72028172198e">hasInvalidConstraint</a> () const</td></tr>
<tr class="memdesc:a70fa88c51b843b4c4a1a72028172198e inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks all rows of equality/inequality constraints for trivial contradictions (for example: 1 == 0, 0 &gt;= 1), which may have surfaced after elimination.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a70fa88c51b843b4c4a1a72028172198e">More...</a><br /></td></tr>
<tr class="separator:a70fa88c51b843b4c4a1a72028172198e inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0c2ecd2bd72b36ef893d0ec0398474 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memTemplParams" colspan="2">template&lt;bool isLower&gt; </td></tr>
<tr class="memitem:a4a0c2ecd2bd72b36ef893d0ec0398474 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1presburger_1_1MPInt.html">MPInt</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a4a0c2ecd2bd72b36ef893d0ec0398474">computeConstantLowerOrUpperBound</a> (unsigned pos)</td></tr>
<tr class="memdesc:a4a0c2ecd2bd72b36ef893d0ec0398474 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant lower bound bound if isLower is true, and the upper bound if isLower is false.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a4a0c2ecd2bd72b36ef893d0ec0398474">More...</a><br /></td></tr>
<tr class="separator:a4a0c2ecd2bd72b36ef893d0ec0398474 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c35450d2946905073e692c2eebd0da inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memTemplParams" colspan="2">template&lt;bool isLower&gt; </td></tr>
<tr class="memitem:ae0c35450d2946905073e692c2eebd0da inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ae0c35450d2946905073e692c2eebd0da">computeConstantLowerOrUpperBound64</a> (unsigned pos)</td></tr>
<tr class="memdesc:ae0c35450d2946905073e692c2eebd0da inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same, but casts to int64_t.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#ae0c35450d2946905073e692c2eebd0da">More...</a><br /></td></tr>
<tr class="separator:ae0c35450d2946905073e692c2eebd0da inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f2f340cbb37973e0b106537132c9f5 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a79f2f340cbb37973e0b106537132c9f5">gaussianEliminateVar</a> (unsigned position)</td></tr>
<tr class="memdesc:a79f2f340cbb37973e0b106537132c9f5 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates a single variable at <code>position</code> from equality and inequality constraints.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a79f2f340cbb37973e0b106537132c9f5">More...</a><br /></td></tr>
<tr class="separator:a79f2f340cbb37973e0b106537132c9f5 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade159612a3056ec58ea0940e116c9bfb inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ade159612a3056ec58ea0940e116c9bfb">removeRedundantLocalVars</a> ()</td></tr>
<tr class="memdesc:ade159612a3056ec58ea0940e116c9bfb inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes local variables using equalities.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#ade159612a3056ec58ea0940e116c9bfb">More...</a><br /></td></tr>
<tr class="separator:ade159612a3056ec58ea0940e116c9bfb inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac287b236315217c36e1eb5d07721eece inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ac287b236315217c36e1eb5d07721eece">gaussianEliminateVars</a> (unsigned posStart, unsigned posLimit)</td></tr>
<tr class="memdesc:ac287b236315217c36e1eb5d07721eece inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates variables from equality and inequality constraints in column range [posStart, posLimit).  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#ac287b236315217c36e1eb5d07721eece">More...</a><br /></td></tr>
<tr class="separator:ac287b236315217c36e1eb5d07721eece inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea6bf84ef57c39c622dad8439c1e3fc inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#abea6bf84ef57c39c622dad8439c1e3fc">gcdTightenInequalities</a> ()</td></tr>
<tr class="memdesc:abea6bf84ef57c39c622dad8439c1e3fc inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tightens inequalities given that we are dealing with integer spaces.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#abea6bf84ef57c39c622dad8439c1e3fc">More...</a><br /></td></tr>
<tr class="separator:abea6bf84ef57c39c622dad8439c1e3fc inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbb719141f0ade802f8c5ddb4f081af inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a2cbb719141f0ade802f8c5ddb4f081af">normalizeConstraintsByGCD</a> ()</td></tr>
<tr class="memdesc:a2cbb719141f0ade802f8c5ddb4f081af inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalized each constraints by the GCD of its coefficients.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a2cbb719141f0ade802f8c5ddb4f081af">More...</a><br /></td></tr>
<tr class="separator:a2cbb719141f0ade802f8c5ddb4f081af inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb673542ed4e593652993f30164c3867 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#aeb673542ed4e593652993f30164c3867">findConstraintWithNonZeroAt</a> (unsigned colIdx, bool isEq, unsigned *rowIdx) const</td></tr>
<tr class="memdesc:aeb673542ed4e593652993f30164c3867 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a constraint with a non-zero coefficient at <code>colIdx</code> in equality (isEq=true) or inequality (isEq=false) constraints.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#aeb673542ed4e593652993f30164c3867">More...</a><br /></td></tr>
<tr class="separator:aeb673542ed4e593652993f30164c3867 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b048e5f43d1b7a764f296999befcd0 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#af7b048e5f43d1b7a764f296999befcd0">isColZero</a> (unsigned pos) const</td></tr>
<tr class="memdesc:af7b048e5f43d1b7a764f296999befcd0 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the pos^th column is all zero for both inequalities and equalities.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#af7b048e5f43d1b7a764f296999befcd0">More...</a><br /></td></tr>
<tr class="separator:af7b048e5f43d1b7a764f296999befcd0 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73d3ef7b9989ed13832086eef85f3e8 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#aa73d3ef7b9989ed13832086eef85f3e8">removeVarRange</a> (unsigned varStart, unsigned varLimit)</td></tr>
<tr class="memdesc:aa73d3ef7b9989ed13832086eef85f3e8 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes variables in the column range [varStart, varLimit), and copies any remaining valid data into place, updates member variables, and resizes arrays as needed.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#aa73d3ef7b9989ed13832086eef85f3e8">More...</a><br /></td></tr>
<tr class="separator:aa73d3ef7b9989ed13832086eef85f3e8 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2141098ad7def9f6520f9219df7e30d inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ab2141098ad7def9f6520f9219df7e30d">truncateVarKind</a> (<a class="el" href="namespacemlir_1_1presburger.html#a0fa2eacf0a4f6b3656064ea54f8d3c35">VarKind</a> kind, unsigned num)</td></tr>
<tr class="memdesc:ab2141098ad7def9f6520f9219df7e30d inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate the vars of the specified kind to the specified number by dropping some vars at the end.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#ab2141098ad7def9f6520f9219df7e30d">More...</a><br /></td></tr>
<tr class="separator:ab2141098ad7def9f6520f9219df7e30d inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5a80a35ab0df79dda00dc2f36a34c6 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#adc5a80a35ab0df79dda00dc2f36a34c6">truncateVarKind</a> (<a class="el" href="namespacemlir_1_1presburger.html#a0fa2eacf0a4f6b3656064ea54f8d3c35">VarKind</a> kind, const <a class="el" href="structmlir_1_1presburger_1_1IntegerRelation_1_1CountsSnapshot.html">CountsSnapshot</a> &amp;counts)</td></tr>
<tr class="memdesc:adc5a80a35ab0df79dda00dc2f36a34c6 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate the vars to the number in the space of the specified <a class="el" href="structmlir_1_1presburger_1_1IntegerRelation_1_1CountsSnapshot.html" title="The struct CountsSnapshot stores the count of each VarKind, and also of each constraint type.">CountsSnapshot</a>.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#adc5a80a35ab0df79dda00dc2f36a34c6">More...</a><br /></td></tr>
<tr class="separator:adc5a80a35ab0df79dda00dc2f36a34c6 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2662045a8d845c7cf9aa9516af6ea914"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a2662045a8d845c7cf9aa9516af6ea914">values</a></td></tr>
<tr class="memdesc:a2662045a8d845c7cf9aa9516af6ea914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values corresponding to the (column) non-local variables of this constraint system appearing in the order the variables correspond to columns.  <a href="classmlir_1_1FlatAffineValueConstraints.html#a2662045a8d845c7cf9aa9516af6ea914">More...</a><br /></td></tr>
<tr class="separator:a2662045a8d845c7cf9aa9516af6ea914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classmlir_1_1presburger_1_1IntegerRelation"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classmlir_1_1presburger_1_1IntegerRelation')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">mlir::presburger::IntegerRelation</a></td></tr>
<tr class="memitem:a80fe301a2d8c1e77d84894aaaae00db8 inherit pro_attribs_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1PresburgerSpace.html">PresburgerSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a80fe301a2d8c1e77d84894aaaae00db8">space</a></td></tr>
<tr class="separator:a80fe301a2d8c1e77d84894aaaae00db8 inherit pro_attribs_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ca1194b199db265fd2d33fa19cdc65 inherit pro_attribs_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a20ca1194b199db265fd2d33fa19cdc65">equalities</a></td></tr>
<tr class="memdesc:a20ca1194b199db265fd2d33fa19cdc65 inherit pro_attribs_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coefficients of affine equalities (in == 0 form).  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a20ca1194b199db265fd2d33fa19cdc65">More...</a><br /></td></tr>
<tr class="separator:a20ca1194b199db265fd2d33fa19cdc65 inherit pro_attribs_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a45bb310b47515f4468e5aaee65516 inherit pro_attribs_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ae4a45bb310b47515f4468e5aaee65516">inequalities</a></td></tr>
<tr class="memdesc:ae4a45bb310b47515f4468e5aaee65516 inherit pro_attribs_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coefficients of affine inequalities (in &gt;= 0 form).  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#ae4a45bb310b47515f4468e5aaee65516">More...</a><br /></td></tr>
<tr class="separator:ae4a45bb310b47515f4468e5aaee65516 inherit pro_attribs_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classmlir_1_1presburger_1_1IntegerRelation"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmlir_1_1presburger_1_1IntegerRelation')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">mlir::presburger::IntegerRelation</a></td></tr>
<tr class="memitem:a02a605e2b5fca97f0ea2af1f24a24703 inherit pub_types_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a02a605e2b5fca97f0ea2af1f24a24703">Kind</a> { <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a02a605e2b5fca97f0ea2af1f24a24703a5d3c39d196a997e225b4f3ee3e1da745">FlatAffineConstraints</a>
, <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a02a605e2b5fca97f0ea2af1f24a24703a38bdec3fb5cb6b2e66b5acddb32f9cb4">FlatAffineValueConstraints</a>
, <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a02a605e2b5fca97f0ea2af1f24a24703a817d2f7f1430fc50808ae3809af385a3">IntegerRelation</a>
, <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a02a605e2b5fca97f0ea2af1f24a24703aaaa02ac14b63aada677a5426f1782df9">IntegerPolyhedron</a>
 }</td></tr>
<tr class="memdesc:a02a605e2b5fca97f0ea2af1f24a24703"><td class="mdescLeft">&#160;</td><td class="mdescRight">All derived classes of <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html" title="An IntegerRelation represents the set of points from a PresburgerSpace that satisfy a list of affine ...">IntegerRelation</a>.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a02a605e2b5fca97f0ea2af1f24a24703">More...</a><br /></td></tr>
<tr class="separator:a02a605e2b5fca97f0ea2af1f24a24703 inherit pub_types_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad152d6d3a3f2c46a702bd1b59ecdaabc inherit pub_types_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabc">BoundType</a> { <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabca77f105202929db0df2f3d3c1cb5e7f2a">EQ</a>
, <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabcaa3e8dc9a8b5853177508d80ebf42d555">LB</a>
, <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabcaa451545b93620cf26d5bdffb0939d3d0">UB</a>
 }</td></tr>
<tr class="memdesc:ad152d6d3a3f2c46a702bd1b59ecdaabc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of bound: equal, lower bound or upper bound.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabc">More...</a><br /></td></tr>
<tr class="separator:ad152d6d3a3f2c46a702bd1b59ecdaabc inherit pub_types_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classmlir_1_1presburger_1_1IntegerRelation"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classmlir_1_1presburger_1_1IntegerRelation')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">mlir::presburger::IntegerRelation</a></td></tr>
<tr class="memitem:ad3a6d2436b91fb2fdd11ee247064341c inherit pro_static_attribs_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">constexpr static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad3a6d2436b91fb2fdd11ee247064341c">kExplosionFactor</a> = 32</td></tr>
<tr class="memdesc:ad3a6d2436b91fb2fdd11ee247064341c inherit pro_static_attribs_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parameter that controls detection of an unrealistic number of constraints.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#ad3a6d2436b91fb2fdd11ee247064341c">More...</a><br /></td></tr>
<tr class="separator:ad3a6d2436b91fb2fdd11ee247064341c inherit pro_static_attribs_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html" title="FlatAffineValueConstraints represents an extension of IntegerPolyhedron where each non-local variable...">FlatAffineValueConstraints</a> represents an extension of IntegerPolyhedron where each non-local variable can have an SSA <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> attached to it. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00041">41</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a7234b85808ebeba69ccbe37452e61d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7234b85808ebeba69ccbe37452e61d9d">&#9670;&nbsp;</a></span>VarKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1presburger.html#a0fa2eacf0a4f6b3656064ea54f8d3c35">mlir::FlatAffineValueConstraints::VarKind</a> =  <a class="el" href="namespacemlir_1_1presburger.html#a0fa2eacf0a4f6b3656064ea54f8d3c35">presburger::VarKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00470">470</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aaec51cfb6129c7a10dbf24740897cf1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec51cfb6129c7a10dbf24740897cf1b">&#9670;&nbsp;</a></span>FlatAffineValueConstraints() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineValueConstraints::FlatAffineValueConstraints </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numReservedInequalities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numReservedEqualities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numReservedCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numLocals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>valArgs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a constraint system reserving memory for the specified number of constraints and variables. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00045">45</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00973">getSliceBounds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00228">reset()</a>.</p>

</div>
</div>
<a id="a8ba51af6e35a94b11d73b5215a35ff7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba51af6e35a94b11d73b5215a35ff7a">&#9670;&nbsp;</a></span>FlatAffineValueConstraints() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineValueConstraints::FlatAffineValueConstraints </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numSymbols</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numLocals</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>valArgs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a constraint system with the specified number of dimensions and symbols. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00065">65</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

</div>
</div>
<a id="a1a72f6f50a3c14fb9b64ff67fd3dfdc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a72f6f50a3c14fb9b64ff67fd3dfdc1">&#9670;&nbsp;</a></span>FlatAffineValueConstraints() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineValueConstraints::FlatAffineValueConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#ac39dd991a3d29265b2f1d70390091139">IntegerPolyhedron</a> &amp;&#160;</td>
          <td class="paramname"><em>fac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>valArgs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00074">74</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

</div>
</div>
<a id="af048f5fb19968688b331c7bb0f8d9a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af048f5fb19968688b331c7bb0f8d9a4d">&#9670;&nbsp;</a></span>FlatAffineValueConstraints() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineValueConstraints::FlatAffineValueConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> &amp;&#160;</td>
          <td class="paramname"><em>avm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a flat affine constraint system from an <a class="el" href="classmlir_1_1AffineValueMap.html" title="An AffineValueMap is an affine map plus its ML value operands and results for analysis purposes.">AffineValueMap</a> or a list of these. </p>
<p>The constructed system will only include equalities. </p>

</div>
</div>
<a id="adb1b9f72ea71c10baebb8e93d716c1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb1b9f72ea71c10baebb8e93d716c1df">&#9670;&nbsp;</a></span>FlatAffineValueConstraints() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineValueConstraints::FlatAffineValueConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> * &gt;&#160;</td>
          <td class="paramname"><em>avmRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fa812729dd90454f1c10517520dde9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa812729dd90454f1c10517520dde9a">&#9670;&nbsp;</a></span>FlatAffineValueConstraints() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FlatAffineValueConstraints::FlatAffineValueConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an affine constraint system from an <a class="el" href="classmlir_1_1IntegerSet.html" title="An integer set representing a conjunction of one or more affine equalities and inequalities.">IntegerSet</a>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00152">152</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8cpp_source.html#l00275">mlir::presburger::IntegerRelation::addEquality()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00282">mlir::presburger::IntegerRelation::addInequality()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00055">mlir::presburger::IntegerRelation::append()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00051">mlir::IntegerSet::getEqFlags()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00118">mlir::getFlattenedAffineExprs()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00171">mlir::presburger::IntegerRelation::getNumCols()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00021">mlir::IntegerSet::getNumConstraints()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00165">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00162">mlir::presburger::IntegerRelation::getNumLocalVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00203">mlir::presburger::IntegerRelation::getNumVarKind()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00292">insertVar()</a>, <a class="el" href="MlirTblgenMain_8cpp_source.html#l00028">None</a>, and <a class="el" href="AffineStructures_8h_source.html#l00509">values</a>.</p>

</div>
</div>
<a id="acf63cb6df8a2b726569a10c067639ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf63cb6df8a2b726569a10c067639ee8">&#9670;&nbsp;</a></span>FlatAffineValueConstraints() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineValueConstraints::FlatAffineValueConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> * &gt;&#160;</td>
          <td class="paramname"><em>avmRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a85192d2ad28e90993950ec5c2598a3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85192d2ad28e90993950ec5c2598a3e7">&#9670;&nbsp;</a></span>addAffineForOpDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::addAffineForOpDomain </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds constraints (lower and upper bounds) for the specified 'affine.for' operation's <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> using IR information stored in its bound maps. </p>
<p>The right variable is first looked up using <code>forOp</code>'s <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. Asserts if the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> corresponding to the 'affine.for' operation isn't found in the constraint system. Returns failure for the yet unimplemented/unsupported cases. Any new variables that are found in the bound operands of the 'affine.for' operation are added as trailing variables (either dimensional or symbolic depending on whether the operand is a valid symbol). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00591">591</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01170">addBound()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00275">mlir::presburger::IntegerRelation::addEquality()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01314">mlir::presburger::IntegerRelation::addLocalFloorDiv()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01327">findVar()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00171">mlir::presburger::IntegerRelation::getNumCols()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00643">addDomainFromSliceMaps()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00568">addInductionVarOrTerminalSymbol()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00760">addMissingLoopIVBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01284">addSliceBounds()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00080">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00240">mlir::getIndexSet()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00066">mlir::ComputationSliceState::getSourceAsConstraints()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00288">mlir::ComputationSliceState::isMaximal()</a>.</p>

</div>
</div>
<a id="a1b74b3973d5329fe7ec99a7d2f8ed31f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b74b3973d5329fe7ec99a7d2f8ed31f">&#9670;&nbsp;</a></span>addAffineIfOpDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineValueConstraints::addAffineIfOpDomain </td>
          <td>(</td>
          <td class="paramtype">AffineIfOp&#160;</td>
          <td class="paramname"><em>ifOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds constraints imposed by the <code>affine.if</code> operation. </p>
<p>These constraints are collected from the <a class="el" href="classmlir_1_1IntegerSet.html" title="An integer set representing a conjunction of one or more affine equalities and inequalities.">IntegerSet</a> attached to the given <code>affine.if</code> instance argument (<code>ifOp</code>). It is asserted that: 1) The <a class="el" href="classmlir_1_1IntegerSet.html" title="An integer set representing a conjunction of one or more affine equalities and inequalities.">IntegerSet</a> of the given <code>affine.if</code> instance should not contain semi-affine expressions, 2) The columns of the constraint system created from <code>ifOp</code> should match the columns in the current one regarding numbers and values. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00692">692</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8cpp_source.html#l00055">mlir::presburger::IntegerRelation::append()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00165">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00443">mergeAndAlignVarsWithOther()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00454">setValues()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00240">mlir::getIndexSet()</a>.</p>

</div>
</div>
<a id="a9c982da57d4288f8cbe655848ecd204c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c982da57d4288f8cbe655848ecd204c">&#9670;&nbsp;</a></span>addBound() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::addBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabc">BoundType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>boundMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a bound for the variable at the specified position with constraints being drawn from the specified bound map. </p>
<p>In case of an EQ bound, the bound map is expected to have exactly one result. In case of a LB/UB, the bound map may have more than one result, for each of which an inequality is added. Note: The dimensions/symbols of this FlatAffineConstraints must match the dimensions/symbols of the affine map. By default the lower bound is closed and the upper bound is open. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01222">1222</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01170">addBound()</a>.</p>

</div>
</div>
<a id="a2a1549c4022326443281b2af784da2ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1549c4022326443281b2af784da2ba">&#9670;&nbsp;</a></span>addBound() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::addBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabc">BoundType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>boundMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isClosedBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a bound for the variable at the specified position with constraints being drawn from the specified bound map. </p>
<p>In case of an EQ bound, the bound map is expected to have exactly one result. In case of a LB/UB, the bound map may have more than one result, for each of which an inequality is added.</p>
<p>The bound can be added as open or closed by specifying isClosedBound. In case of a LB/UB, isClosedBound = false means the bound is added internally as a closed bound by +1/-1 respectively. In case of an EQ bound, it can only be added as a closed bound.</p>
<p>Note: The dimensions/symbols of this FlatAffineConstraints must match the dimensions/symbols of the affine map. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01170">1170</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8cpp_source.html#l00275">mlir::presburger::IntegerRelation::addEquality()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00282">mlir::presburger::IntegerRelation::addInequality()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01146">flattenAlignedMapAndMergeLocals()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00171">mlir::presburger::IntegerRelation::getNumCols()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00165">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00306">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00164">mlir::presburger::IntegerRelation::getNumDimVars()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00315">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00314">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00310">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00161">mlir::presburger::IntegerRelation::getNumSymbolVars()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00591">addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01222">addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00643">addDomainFromSliceMaps()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00568">addInductionVarOrTerminalSymbol()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00203">addLoopRangeConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01284">addSliceBounds()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00041">alignAndAddBound()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00104">canonicalizeMinMaxOp()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00080">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00342">mlir::MemRefRegion::getConstantBoundingSizeAndShape()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00227">mlir::linalg::getUpperBoundForIndex()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01745">mlir::normalizeMemRefType()</a>, and <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00326">mlir::scf::rewritePeeledMinMaxOp()</a>.</p>

</div>
</div>
<a id="ae0266a236d1adc4c4a08e4d68b741e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0266a236d1adc4c4a08e4d68b741e38">&#9670;&nbsp;</a></span>addBound() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::addBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabc">BoundType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>boundMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a bound for the variable at the specified position with constraints being drawn from the specified bound map and operands. </p>
<p>In case of an EQ bound, the bound map is expected to have exactly one result. In case of a LB/UB, the bound map may have more than one result, for each of which an inequality is added. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01260">1260</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01170">addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00568">addInductionVarOrTerminalSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01225">mlir::canonicalizeMapAndOperands()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01228">computeAlignedMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00860">mlir::fullyComposeAffineMapAndOperands()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00646">mlir::simplifyAffineMap()</a>.</p>

</div>
</div>
<a id="a210341fc77fde46aedce6d2609f26738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210341fc77fde46aedce6d2609f26738">&#9670;&nbsp;</a></span>addBound() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineValueConstraints::addBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabc">BoundType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a constant bound for the variable associated with the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01361">1361</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01170">addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01327">findVar()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00160">value</a>.</p>

</div>
</div>
<a id="a4287995c9f074be38e7e1d76b39d93f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4287995c9f074be38e7e1d76b39d93f8">&#9670;&nbsp;</a></span>addDomainFromSliceMaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::addDomainFromSliceMaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>lbMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>ubMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds constraints (lower and upper bounds) for each loop in the loop nest described by the bound maps <code>lbMaps</code> and <code>ubMaps</code> of a computation slice. </p>
<p>Every pair (<code>lbMaps[i]</code>, <code>ubMaps[i]</code>) describes the bounds of a loop in the nest, sorted outer-to-inner. <code>operands</code> contains the bound operands for a single bound map. All the bound maps will use the same bound operands. Note that some loops described by a computation slice might not exist yet in the IR so the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> attached to those dimension variables might be empty. For that reason, this method doesn't perform <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> look-ups to retrieve the dimension variable positions. Instead, it assumes the position of the dim variables in the constraint system is the same as the position of the loop in the loop nest. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00643">643</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00591">addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01170">addBound()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00281">mlir::AffineExpr::dyn_cast()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02294">mlir::getForInductionVarOwner()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00164">mlir::presburger::IntegerRelation::getNumDimVars()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00315">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00314">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00311">mlir::AffineDimExpr::getPosition()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00323">mlir::AffineMap::getResult()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00270">mlir::AffineExpr::isa()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00288">mlir::ComputationSliceState::isMaximal()</a>.</p>

</div>
</div>
<a id="a1150883739ccac33efedf30dd36decfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1150883739ccac33efedf30dd36decfb">&#9670;&nbsp;</a></span>addInductionVarOrTerminalSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineValueConstraints::addInductionVarOrTerminalSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the specified values as a dim or symbol var depending on its nature, if it already doesn't exist in the system. </p>
<p><code>val</code> has to be either a terminal symbol or a loop IV, i.e., it cannot be the result affine.apply of any symbols or loop IVs. The variable is added to the end of the existing dims or symbols. Additional information on the variable is extracted from the IR and added to the constraint system. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00568">568</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00591">addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01170">addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00272">appendDimVar()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00277">appendSymbolVar()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01339">containsVar()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02294">mlir::getForInductionVarOwner()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02288">mlir::isForInductionVar()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00232">mlir::isTopLevelValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01260">addBound()</a>.</p>

</div>
</div>
<a id="ad38a7dd065a6c286b7ac84f0d1712c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38a7dd065a6c286b7ac84f0d1712c23">&#9670;&nbsp;</a></span>addSliceBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::addSliceBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>lbMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>ubMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds slice lower bounds represented by lower bounds in <code>lbMaps</code> and upper bounds in <code>ubMaps</code> to each variable in the constraint system which has a value in <code>values</code>. </p>
<p>Note that both lower/upper bounds share the same operand list <code>operands</code>. This function assumes <code>values.size</code> == <code>lbMaps.size</code> == <code>ubMaps.size</code>. Note that both lower/upper bounds use operands from <code>operands</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01284">1284</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00591">addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01170">addBound()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01327">findVar()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02294">mlir::getForInductionVarOwner()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00315">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00314">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00323">mlir::AffineMap::getResult()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00509">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00080">mlir::ComputationSliceState::getAsConstraints()</a>.</p>

</div>
</div>
<a id="ad77ebdda919f83bf948fd79b2f7dfd14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77ebdda919f83bf948fd79b2f7dfd14">&#9670;&nbsp;</a></span>appendDimVar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::FlatAffineValueConstraints::appendDimVar </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00312">312</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8cpp_source.html#l00270">mlir::presburger::IntegerRelation::appendVar()</a>.</p>

</div>
</div>
<a id="a99a7838df1d1496136d23dac312240c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a7838df1d1496136d23dac312240c4">&#9670;&nbsp;</a></span>appendDimVar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned FlatAffineValueConstraints::appendDimVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>vals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append variables of the specified kind after the last variable of that kind. </p>
<p>The coefficient columns corresponding to the added variables are initialized to zero. <code>vals</code> are the Values corresponding to the variables. Return the absolute column position (i.e., not relative to the kind of variable) of the first appended variable.</p>
<p>Note: Empty Values are allowed in <code>vals</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00272">272</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00164">mlir::presburger::IntegerRelation::getNumDimVars()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00292">insertVar()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00568">addInductionVarOrTerminalSymbol()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00203">addLoopRangeConstraints()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00104">canonicalizeMinMaxOp()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01752">mlir::getRelationFromMap()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00227">mlir::linalg::getUpperBoundForIndex()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00393">mergeAndAlignVars()</a>, and <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00326">mlir::scf::rewritePeeledMinMaxOp()</a>.</p>

</div>
</div>
<a id="a046b0ec09fb973fb08a0365ce4f6cc8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a046b0ec09fb973fb08a0365ce4f6cc8a">&#9670;&nbsp;</a></span>appendLocalVar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::FlatAffineValueConstraints::appendLocalVar </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00318">318</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8cpp_source.html#l00270">mlir::presburger::IntegerRelation::appendVar()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01146">flattenAlignedMapAndMergeLocals()</a>.</p>

</div>
</div>
<a id="afb3df3ed0dbc2abf7eed4e6249cbfbac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3df3ed0dbc2abf7eed4e6249cbfbac">&#9670;&nbsp;</a></span>appendSymbolVar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::FlatAffineValueConstraints::appendSymbolVar </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00315">315</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8cpp_source.html#l00270">mlir::presburger::IntegerRelation::appendVar()</a>.</p>

</div>
</div>
<a id="aec1e7bace4b883c1aaf15bd8a811aad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec1e7bace4b883c1aaf15bd8a811aad2">&#9670;&nbsp;</a></span>appendSymbolVar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned FlatAffineValueConstraints::appendSymbolVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>vals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00277">277</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00161">mlir::presburger::IntegerRelation::getNumSymbolVars()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00292">insertVar()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00568">addInductionVarOrTerminalSymbol()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00203">addLoopRangeConstraints()</a>, and <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00041">alignAndAddBound()</a>.</p>

</div>
</div>
<a id="ab31609659b8eb41c2880ee4c1a648bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab31609659b8eb41c2880ee4c1a648bf5">&#9670;&nbsp;</a></span>areVarsAlignedWithOther()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineValueConstraints::areVarsAlignedWithOther </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this constraint system and <code>other</code> are in the same space, i.e., if they are associated with the same set of variables, appearing in the same order. </p>
<p>Calls areVarsAligned to check if two constraint systems have the same set of variables in the same order.</p>
<p>Returns false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00338">338</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00328">areVarsAligned()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00808">mlir::computeSliceUnion()</a>.</p>

</div>
</div>
<a id="a407729200db5589c49636b07bc2fd359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a407729200db5589c49636b07bc2fd359">&#9670;&nbsp;</a></span>classof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::FlatAffineValueConstraints::classof </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a720bc08a94b0b8e26ffffedebf24fc1c">IntegerRelation</a> *&#160;</td>
          <td class="paramname"><em>cst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00112">112</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a02a605e2b5fca97f0ea2af1f24a24703a38bdec3fb5cb6b2e66b5acddb32f9cb4">mlir::presburger::IntegerRelation::FlatAffineValueConstraints</a>.</p>

</div>
</div>
<a id="a003266c0f9665b8b6dabd3df392cb6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a003266c0f9665b8b6dabd3df392cb6c1">&#9670;&nbsp;</a></span>clearAndCopyFrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineValueConstraints::clearAndCopyFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents of this <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html" title="FlatAffineValueConstraints represents an extension of IntegerPolyhedron where each non-local variable...">FlatAffineValueConstraints</a> with <code>other</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01386">1386</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00165">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, <a class="el" href="MlirTblgenMain_8cpp_source.html#l00028">None</a>, and <a class="el" href="AffineStructures_8h_source.html#l00509">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00072">getFlattenedAffineExprs()</a>.</p>

</div>
</div>
<a id="a592860df144ae17907bccf79792e3f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592860df144ae17907bccf79792e3f90">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &gt; FlatAffineValueConstraints::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clones this object. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00147">147</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

</div>
</div>
<a id="ad4dd23a785eb9a02c7f2ba43fa1aa7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4dd23a785eb9a02c7f2ba43fa1aa7db">&#9670;&nbsp;</a></span>composeMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::composeMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *&#160;</td>
          <td class="paramname"><em>vMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composes the affine value map with this FlatAffineValueConstrains, adding the results of the map as dimensions at the front [0, vMap-&gt;getNumResults()) and with the dimensions set to the equalities specified by the value map. </p>
<p>Returns failure if the composition fails (when vMap is a semi-affine map). The vMap's operand <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>'s are used to look up the right positions in the FlatAffineConstraints with which to associate. Every operand of vMap should have a matching dim/symbol column in this constraint system (with the same associated <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00449">449</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00457">composeMatchingMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01228">computeAlignedMap()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00100">mlir::AffineValueMap::getAffineMap()</a>, and <a class="el" href="AffineValueMap_8cpp_source.html#l00096">mlir::AffineValueMap::getOperands()</a>.</p>

</div>
</div>
<a id="ae5e83c0b271e4aff69e15b7bd96a1c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e83c0b271e4aff69e15b7bd96a1c4b">&#9670;&nbsp;</a></span>composeMatchingMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::composeMatchingMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composes an affine map whose dimensions and symbols match one to one with the dimensions and symbols of this FlatAffineConstraints. </p>
<p>The results of the map <code>other</code> are added as the leading dimensions of this constraint system. Returns failure if <code>other</code> is a semi-affine map. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00457">457</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8cpp_source.html#l00275">mlir::presburger::IntegerRelation::addEquality()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01146">flattenAlignedMapAndMergeLocals()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00171">mlir::presburger::IntegerRelation::getNumCols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00306">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00164">mlir::presburger::IntegerRelation::getNumDimVars()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00315">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00314">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00310">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00161">mlir::presburger::IntegerRelation::getNumSymbolVars()</a>, <a class="el" href="AffineStructures_8h_source.html#l00288">insertDimVar()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00449">composeMap()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01745">mlir::normalizeMemRefType()</a>.</p>

</div>
</div>
<a id="a5f1918c91299c463de63c843ee1f7628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1918c91299c463de63c843ee1f7628">&#9670;&nbsp;</a></span>computeAlignedMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> FlatAffineValueConstraints::computeAlignedMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Align <code>map</code> with this constraint system based on <code>operands</code>. </p>
<p>Each operand must already have a corresponding dim/symbol in this constraint system. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01228">1228</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01571">mlir::alignAffineMapWithValues()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00164">mlir::presburger::IntegerRelation::getNumDimVars()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00315">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00161">mlir::presburger::IntegerRelation::getNumSymbolVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00213">mlir::presburger::IntegerRelation::getVarKindEnd()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00208">mlir::presburger::IntegerRelation::getVarKindOffset()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00509">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01260">addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00449">composeMap()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00227">mlir::linalg::getUpperBoundForIndex()</a>.</p>

</div>
</div>
<a id="a77883ce535bd59441c6cd5e919b6b221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77883ce535bd59441c6cd5e919b6b221">&#9670;&nbsp;</a></span>containsVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineValueConstraints::containsVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>mayBeVar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if an variable with the specified <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> exists, false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01339">1339</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00509">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00568">addInductionVarOrTerminalSymbol()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00080">mlir::ComputationSliceState::getAsConstraints()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00227">mlir::linalg::getUpperBoundForIndex()</a>.</p>

</div>
</div>
<a id="a38b004fb4978436d8c8cd8976803468c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b004fb4978436d8c8cd8976803468c">&#9670;&nbsp;</a></span>convertLoopIVSymbolsToDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineValueConstraints::convertLoopIVSymbolsToDims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes all symbol variables which are loop IVs to dim variables. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00555">555</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l02294">mlir::getForInductionVarOwner()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00165">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00164">mlir::presburger::IntegerRelation::getNumDimVars()</a>, <a class="el" href="AffineStructures_8h_source.html#l00405">getValue()</a>, <a class="el" href="AffineStructures_8h_source.html#l00412">hasValue()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00506">turnSymbolIntoDim()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00808">mlir::computeSliceUnion()</a>.</p>

</div>
</div>
<a id="aa71e730c49c436786b39ba3a4eb98c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71e730c49c436786b39ba3a4eb98c14">&#9670;&nbsp;</a></span>findVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineValueConstraints::findVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks up the position of the variable with the specified <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>
<p>Returns true if found (false otherwise). <code>pos</code> is set to the (column) position of the variable. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01327">1327</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00509">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00591">addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01361">addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01284">addSliceBounds()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00444">mlir::MemRefAccess::getAccessRelation()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00227">mlir::linalg::getUpperBoundForIndex()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00393">mergeAndAlignVars()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00519">mergeSymbolVars()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01411">projectOut()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00506">turnSymbolIntoDim()</a>.</p>

</div>
</div>
<a id="aec33e9ae86390c8f29078675dd53870e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec33e9ae86390c8f29078675dd53870e">&#9670;&nbsp;</a></span>flattenAlignedMapAndMergeLocals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::flattenAlignedMapAndMergeLocals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>flattenedExprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an affine map that is aligned with this constraint system: </p>
<ul>
<li>Flatten the map.</li>
<li>Add newly introduced local columns at the beginning of this constraint system (local column pos 0).</li>
<li>Add equalities that define the new local columns to this constraint system.</li>
<li>Return the flattened expressions via <code>flattenedExprs</code>.</li>
</ul>
<p>Note: This is a shared helper function of <code>addLowerOrUpperBound</code> and <code>composeMatchingMap</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01146">1146</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8cpp_source.html#l00055">mlir::presburger::IntegerRelation::append()</a>, <a class="el" href="AffineStructures_8h_source.html#l00318">appendLocalVar()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00118">mlir::getFlattenedAffineExprs()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00162">mlir::presburger::IntegerRelation::getNumLocalVars()</a>, <a class="el" href="AffineStructures_8h_source.html#l00294">insertLocalVar()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01170">addBound()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00457">composeMatchingMap()</a>.</p>

</div>
</div>
<a id="a30b3ca6765edfa5677b1b23130e0187c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b3ca6765edfa5677b1b23130e0187c">&#9670;&nbsp;</a></span>fourierMotzkinEliminate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineValueConstraints::fourierMotzkinEliminate </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>darkShadow</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>isResultIntegerExact</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Eliminates the variable at the specified position using Fourier-Motzkin variable elimination, but uses Gaussian elimination if there is an equality involving that variable. </p>
<p>If the result of the elimination is integer exact, <code>*isResultIntegerExact</code> is set to true. If <code>darkShadow</code> is set to true, a potential under approximation (subset) of the rational shadow / exact integer shadow is computed. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#afd4a1e9844c11f13e2cc5bb1befea77c">mlir::presburger::IntegerRelation</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01399">1399</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00165">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00225">mlir::presburger::IntegerRelation::getVarKindAt()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00509">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01411">projectOut()</a>.</p>

</div>
</div>
<a id="af5177b199aa494103835274f72907a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5177b199aa494103835274f72907a8b">&#9670;&nbsp;</a></span>getAllValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::FlatAffineValueConstraints::getAllValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00431">431</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00165">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, <a class="el" href="AffineStructures_8h_source.html#l00422">getValues()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00509">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00227">mlir::linalg::getUpperBoundForIndex()</a>.</p>

</div>
</div>
<a id="a714f817973fece68d8223bf3d8d598de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714f817973fece68d8223bf3d8d598de">&#9670;&nbsp;</a></span>getAsIntegerSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> FlatAffineValueConstraints::getAsIntegerSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the constraint system as an integer set. </p>
<p>Returns a null integer set if the system has no constraints, or if an integer set couldn't be constructed as a result of a local variable's explicit representation not being known and such a local variable appearing in any of the constraints. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01518">1518</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01442">computeLocalVars()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l02261">mlir::presburger::IntegerRelation::dump()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01069">mlir::IntegerSet::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00513">mlir::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00890">mlir::getAffineExprFromFlatForm()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00195">mlir::presburger::IntegerRelation::getEquality64()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00198">mlir::presburger::IntegerRelation::getInequality64()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00155">mlir::presburger::IntegerRelation::getNumConstraints()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00165">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00164">mlir::presburger::IntegerRelation::getNumDimVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00173">mlir::presburger::IntegerRelation::getNumEqualities()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00175">mlir::presburger::IntegerRelation::getNumInequalities()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00162">mlir::presburger::IntegerRelation::getNumLocalVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00161">mlir::presburger::IntegerRelation::getNumSymbolVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00168">mlir::presburger::IntegerRelation::getNumVars()</a>, and <a class="el" href="IntegerRelation_8cpp_source.html#l02087">mlir::presburger::IntegerRelation::isColZero()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02658">createSeparationCondition()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01354">mlir::simplifyIntegerSet()</a>.</p>

</div>
</div>
<a id="acfee23f39d31078e69df752b973f53b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfee23f39d31078e69df752b973f53b6">&#9670;&nbsp;</a></span>getHyperrectangular()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> FlatAffineValueConstraints::getHyperrectangular </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ubs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00198">198</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

</div>
</div>
<a id="ac0dbadcb953c32567a17ab1b662505e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0dbadcb953c32567a17ab1b662505e0">&#9670;&nbsp;</a></span>getIneqAsAffineValueMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineValueConstraints::getIneqAsAffineValueMap </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ineqPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> &amp;&#160;</td>
          <td class="paramname"><em>vmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bound for the variable at <code>pos</code> from the inequality at <code>ineqPos</code> as a 1-d affine value map (affine map + operands). </p>
<p>The returned affine value map can either be a lower bound or an upper bound depending on the sign of atIneq(ineqPos, pos). Asserts if the row at <code>ineqPos</code> does not involve the <code>pos</code>th variable. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01472">1472</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01442">computeLocalVars()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01043">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00890">mlir::getAffineExprFromFlatForm()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00198">mlir::presburger::IntegerRelation::getInequality64()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00171">mlir::presburger::IntegerRelation::getNumCols()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00165">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00164">mlir::presburger::IntegerRelation::getNumDimVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00175">mlir::presburger::IntegerRelation::getNumInequalities()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00162">mlir::presburger::IntegerRelation::getNumLocalVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00161">mlir::presburger::IntegerRelation::getNumSymbolVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00168">mlir::presburger::IntegerRelation::getNumVars()</a>, <a class="el" href="AffineStructures_8h_source.html#l00422">getValues()</a>, and <a class="el" href="AffineValueMap_8cpp_source.html#l00019">mlir::AffineValueMap::reset()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02738">createFullTiles()</a>.</p>

</div>
</div>
<a id="ac6234845a4fa3eb9444e56cab0fe5b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6234845a4fa3eb9444e56cab0fe5b0e">&#9670;&nbsp;</a></span>getKind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a02a605e2b5fca97f0ea2af1f24a24703">Kind</a> mlir::FlatAffineValueConstraints::getKind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the kind of this FlatAffineConstraints. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#a895daf49eff151a9c2242a65c06e5c0a">mlir::presburger::IntegerPolyhedron</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00110">110</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a02a605e2b5fca97f0ea2af1f24a24703a38bdec3fb5cb6b2e66b5acddb32f9cb4">mlir::presburger::IntegerRelation::FlatAffineValueConstraints</a>.</p>

</div>
</div>
<a id="a77763faa50eb0b78f95f0c195fe4bc49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77763faa50eb0b78f95f0c195fe4bc49">&#9670;&nbsp;</a></span>getLowerAndUpperBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; FlatAffineValueConstraints::getLowerAndUpperBound </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>symStartPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>localExprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the lower and upper bound of the <code>offset</code> + <code>pos</code>th variable treating [0, offset) U [offset + num, symStartPos) as dimensions and [symStartPos, getNumDimAndSymbolVars) as symbols, and <code>pos</code> lies in [0, num). </p>
<p>The multi-dimensional maps in the returned pair represent the max and min of potentially multiple affine expressions. The upper bound is exclusive. <code>localExprs</code> holds pre-computed <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a>'s for all local variables in the system. </p>
<p>Add to 'b' from 'a' in set [0, offset) U [offset + num, symbStartPos).</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00885">885</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="MPInt_8h_source.html#l00370">mlir::presburger::abs()</a>, <a class="el" href="MathExtras_8h_source.html#l00033">mlir::floorDiv()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01043">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00890">mlir::getAffineExprFromFlatForm()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00195">mlir::presburger::IntegerRelation::getEquality64()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00198">mlir::presburger::IntegerRelation::getInequality64()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00388">mlir::presburger::IntegerRelation::getLowerAndUpperBoundIndices()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00165">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00164">mlir::presburger::IntegerRelation::getNumDimVars()</a>, and <a class="el" href="IntegerRelation_8h_source.html#l00162">mlir::presburger::IntegerRelation::getNumLocalVars()</a>.</p>

</div>
</div>
<a id="ad7998d8323c934c13a86769ca8fad877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7998d8323c934c13a86769ca8fad877">&#9670;&nbsp;</a></span>getMaybeValues() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &gt; mlir::FlatAffineValueConstraints::getMaybeValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00435">435</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00509">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00041">alignAndAddBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00328">areVarsAligned()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00345">areVarsUnique()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00104">canonicalizeMinMaxOp()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01631">mlir::FlatAffineRelation::compose()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00393">mergeAndAlignVars()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01419">unionBoundingBox()</a>.</p>

</div>
</div>
<a id="a789eb319f31cdec1440144ad77d891a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a789eb319f31cdec1440144ad77d891a3">&#9670;&nbsp;</a></span>getMaybeValues() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &gt; mlir::FlatAffineValueConstraints::getMaybeValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1presburger.html#a0fa2eacf0a4f6b3656064ea54f8d3c35">presburger::VarKind</a>&#160;</td>
          <td class="paramname"><em>kind</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00440">440</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

</div>
</div>
<a id="ac3c6d8417b9fec1a599ca72343a82b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c6d8417b9fec1a599ca72343a82b15">&#9670;&nbsp;</a></span>getSliceBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineValueConstraints::getSliceBounds </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; *&#160;</td>
          <td class="paramname"><em>lbMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; *&#160;</td>
          <td class="paramname"><em>ubMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>getClosedUB</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the lower and upper bounds of the first <code>num</code> dimensional variables (starting at <code>offset</code>) as an affine map of the remaining variables (dimensional and symbolic). </p>
<p>Computes the lower and upper bounds of the first 'num' dimensional variables (starting at 'offset') as affine maps of the remaining variables (dimensional and symbolic variables).</p>
<p>This method is able to detect variables as floordiv's and mod's of affine expressions of other variables with respect to (positive) constants. Sets bound map to a null <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> if such a bound can't be found (or yet unimplemented).</p>
<p>By default the returned lower bounds are closed and upper bounds are open. This can be changed by getClosedUB.</p>
<p>Local variables are themselves explicitly computed as affine functions of other variables in this process if needed. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00973">973</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00139">mlir::presburger::IntegerRelation::atEq64()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00854">detectAsFloorDiv()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00743">detectAsMod()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l02261">mlir::presburger::IntegerRelation::dump()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l03394">mlir::AffineMap::dump()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00470">mlir::presburger::IntegerRelation::findConstraintWithNonZeroAt()</a>, <a class="el" href="AffineStructures_8h_source.html#l00045">FlatAffineValueConstraints()</a>, <a class="el" href="MathExtras_8h_source.html#l00033">mlir::floorDiv()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01043">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00513">mlir::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00488">mlir::getAffineDimExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00498">mlir::getAffineSymbolExpr()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00504">mlir::presburger::IntegerRelation::getConstantBound64()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00165">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00164">mlir::presburger::IntegerRelation::getNumDimVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00162">mlir::presburger::IntegerRelation::getNumLocalVars()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00314">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00161">mlir::presburger::IntegerRelation::getNumSymbolVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00168">mlir::presburger::IntegerRelation::getNumVars()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00485">mlir::presburger::IntegerRelation::normalizeConstraintsByGCD()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01393">mlir::simplifyAffineExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00104">canonicalizeMinMaxOp()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00808">mlir::computeSliceUnion()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01042">mlir::getComputationSliceState()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00227">mlir::linalg::getUpperBoundForIndex()</a>.</p>

</div>
</div>
<a id="a3896e7ab007a7bd1e8d1fb1fb098bdea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3896e7ab007a7bd1e8d1fb1fb098bdea">&#9670;&nbsp;</a></span>getValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::FlatAffineValueConstraints::getValue </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> associated with the pos^th variable. </p>
<p>Asserts if no <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> variable was associated. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00405">405</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00165">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, <a class="el" href="AffineStructures_8h_source.html#l00412">hasValue()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00509">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00760">addMissingLoopIVBounds()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00808">mlir::computeSliceUnion()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00555">convertLoopIVSymbolsToDims()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00444">mlir::MemRefAccess::getAccessRelation()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01042">mlir::getComputationSliceState()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00283">getNumCommonLoops()</a>, <a class="el" href="AffineStructures_8h_source.html#l00422">getValues()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00393">mergeAndAlignVars()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00519">mergeSymbolVars()</a>.</p>

</div>
</div>
<a id="a9ccc790e216f3bbf7416308c04045094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ccc790e216f3bbf7416308c04045094">&#9670;&nbsp;</a></span>getValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::FlatAffineValueConstraints::getValues </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Values associated with variables in range [start, end). </p>
<p>Asserts if no <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> was associated with one of these variables. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00422">422</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00165">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, <a class="el" href="AffineStructures_8h_source.html#l00405">getValue()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00509">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00808">mlir::computeSliceUnion()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00891">createPrivateMemRef()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02658">createSeparationCondition()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02046">generateCopy()</a>, <a class="el" href="AffineStructures_8h_source.html#l00431">getAllValues()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01042">mlir::getComputationSliceState()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01472">getIneqAsAffineValueMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00393">mergeAndAlignVars()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00519">mergeSymbolVars()</a>.</p>

</div>
</div>
<a id="a3202cddcf31d0798de72cac6742248b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3202cddcf31d0798de72cac6742248b0">&#9670;&nbsp;</a></span>hasConsistentState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineValueConstraints::hasConsistentState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns false if the fields corresponding to various variable counts, or equality/inequality buffer sizes aren't consistent; true otherwise. </p>
<p>This is meant to be used within an assert internally. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ae3ea69dad17cc800b4325929ec3871d6">mlir::presburger::IntegerRelation</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00707">707</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00165">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00509">values</a>.</p>

</div>
</div>
<a id="a5e39afc73e0776e068eb7331bcb349c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e39afc73e0776e068eb7331bcb349c7">&#9670;&nbsp;</a></span>hasValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::FlatAffineValueConstraints::hasValue </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the pos^th variable has an associated <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00412">412</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00165">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00509">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00555">convertLoopIVSymbolsToDims()</a>, <a class="el" href="AffineStructures_8h_source.html#l00405">getValue()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01370">printSpace()</a>.</p>

</div>
</div>
<a id="a321a6a4ea45324a6c969a5b5062ec932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321a6a4ea45324a6c969a5b5062ec932">&#9670;&nbsp;</a></span>hasValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineValueConstraints::hasValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if at least one variable has an associated <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00321">321</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00509">values</a>.</p>

</div>
</div>
<a id="accc57d88ce75e704217336a290374419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc57d88ce75e704217336a290374419">&#9670;&nbsp;</a></span>insertDimVar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::FlatAffineValueConstraints::insertDimVar </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert variables of the specified kind at position <code>pos</code>. </p>
<p>Positions are relative to the kind of variable. The coefficient columns corresponding to the added variables are initialized to zero. <code>vals</code> are the Values corresponding to the variables. Values should not be used with VarKind::Local since values can only be attached to non-local variables. Return the absolute column position (i.e., not relative to the kind of variable) of the first added variable.</p>
<p>Note: Empty Values are allowed in <code>vals</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00288">288</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00292">insertVar()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01717">mlir::FlatAffineRelation::appendDomainVar()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01722">mlir::FlatAffineRelation::appendRangeVar()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00457">composeMatchingMap()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00393">computeDirectionVector()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01703">mlir::FlatAffineRelation::insertDomainVar()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01710">mlir::FlatAffineRelation::insertRangeVar()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00393">mergeAndAlignVars()</a>.</p>

</div>
</div>
<a id="a4d82ee30050dfae50aeb804194331f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d82ee30050dfae50aeb804194331f0a">&#9670;&nbsp;</a></span>insertDimVar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned FlatAffineValueConstraints::insertDimVar </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00282">282</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00292">insertVar()</a>.</p>

</div>
</div>
<a id="a437ba7c788fa234e76dda9ec1f0bda19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437ba7c788fa234e76dda9ec1f0bda19">&#9670;&nbsp;</a></span>insertLocalVar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::FlatAffineValueConstraints::insertLocalVar </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00294">294</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00292">insertVar()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01146">flattenAlignedMapAndMergeLocals()</a>.</p>

</div>
</div>
<a id="a1566b2ad81b3cb258dad9e604604cf63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1566b2ad81b3cb258dad9e604604cf63">&#9670;&nbsp;</a></span>insertSymbolVar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::FlatAffineValueConstraints::insertSymbolVar </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00291">291</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00292">insertVar()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00519">mergeSymbolVars()</a>.</p>

</div>
</div>
<a id="a419d692ad1e68deafa03ca4bbef64bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419d692ad1e68deafa03ca4bbef64bbf">&#9670;&nbsp;</a></span>insertSymbolVar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned FlatAffineValueConstraints::insertSymbolVar </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00287">287</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00292">insertVar()</a>.</p>

</div>
</div>
<a id="a35cef22df821ed6026694fec9e0d9243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35cef22df821ed6026694fec9e0d9243">&#9670;&nbsp;</a></span>insertVar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned FlatAffineValueConstraints::insertVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1presburger.html#a0fa2eacf0a4f6b3656064ea54f8d3c35">presburger::VarKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert <code>num</code> variables of the specified kind at position <code>pos</code>. </p>
<p>Positions are relative to the kind of variable. Return the absolute column position (i.e., not relative to the kind of variable) of the first added variable. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#ab3c239339baca42fe61cf12d3a2f72d1">mlir::presburger::IntegerPolyhedron</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00292">292</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00272">appendDimVar()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00277">appendSymbolVar()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00152">FlatAffineValueConstraints()</a>, <a class="el" href="AffineStructures_8h_source.html#l00288">insertDimVar()</a>, <a class="el" href="AffineStructures_8h_source.html#l00294">insertLocalVar()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00291">insertSymbolVar()</a>.</p>

</div>
</div>
<a id="abe613f7abac640e7d9cf2804458915f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe613f7abac640e7d9cf2804458915f0">&#9670;&nbsp;</a></span>insertVar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned FlatAffineValueConstraints::insertVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1presburger.html#a0fa2eacf0a4f6b3656064ea54f8d3c35">presburger::VarKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00304">304</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

</div>
</div>
<a id="a89053c897c2310e74204a899901deb5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89053c897c2310e74204a899901deb5f">&#9670;&nbsp;</a></span>mergeAndAlignVarsWithOther()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineValueConstraints::mergeAndAlignVarsWithOther </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge and align the variables of <code>this</code> and <code>other</code> starting at <code>offset</code>, so that both constraint systems get the union of the contained variables that is dimension-wise and symbol-wise unique; both constraint systems are updated so that they have the union of all variables, with <code>this</code>'s original variables appearing first followed by any of <code>other</code>'s variables that didn't appear in <code>this</code>. </p>
<p>Local variables in <code>other</code> that have the same division representation as local variables in <code>this</code> are merged into one. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00443">443</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00393">mergeAndAlignVars()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00692">addAffineIfOpDomain()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00808">mlir::computeSliceUnion()</a>.</p>

</div>
</div>
<a id="a9aa93b30b85ee67b7d42c3f60b452f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aa93b30b85ee67b7d42c3f60b452f24">&#9670;&nbsp;</a></span>mergeSymbolVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineValueConstraints::mergeSymbolVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge and align symbols of <code>this</code> and <code>other</code> such that both get union of of symbols that are unique. </p>
<p>Symbols in <code>this</code> and <code>other</code> should be unique. Symbols with <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> as <code>None</code> are considered to be inequal to all other symbols. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00519">519</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00345">areVarsUnique()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01327">findVar()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00165">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00164">mlir::presburger::IntegerRelation::getNumDimVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00161">mlir::presburger::IntegerRelation::getNumSymbolVars()</a>, <a class="el" href="AffineStructures_8h_source.html#l00405">getValue()</a>, <a class="el" href="AffineStructures_8h_source.html#l00422">getValues()</a>, <a class="el" href="AffineStructures_8h_source.html#l00291">insertSymbolVar()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01345">swapVar()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01631">mlir::FlatAffineRelation::compose()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00444">mlir::MemRefAccess::getAccessRelation()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00393">mergeAndAlignVars()</a>.</p>

</div>
</div>
<a id="ab22f9e8a2b6d20dbe52378823edc5a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22f9e8a2b6d20dbe52378823edc5a9c">&#9670;&nbsp;</a></span>printSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineValueConstraints::printSpace </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the number of constraints, dimensions, symbols and locals in the FlatAffineConstraints. </p>
<p>Also, prints for each variable whether there is an SSA <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> attached to it. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a9c038eeeb326c7c2f6d990998f046f1e">mlir::presburger::IntegerRelation</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01370">1370</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00165">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00213">mlir::presburger::IntegerRelation::getVarKindEnd()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00208">mlir::presburger::IntegerRelation::getVarKindOffset()</a>, <a class="el" href="AffineStructures_8h_source.html#l00412">hasValue()</a>, and <a class="el" href="RunnerUtils_8h_source.html#l00088">impl::printSpace()</a>.</p>

</div>
</div>
<a id="a79575e2c2693576f2c5a4accf0dcdab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79575e2c2693576f2c5a4accf0dcdab6">&#9670;&nbsp;</a></span>projectOut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineValueConstraints::projectOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projects out the variable that is associate with <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01411">1411</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01327">findVar()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01399">fourierMotzkinEliminate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00393">computeDirectionVector()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01042">mlir::getComputationSliceState()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00218">mlir::ComputationSliceState::isSliceValid()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01745">mlir::normalizeMemRefType()</a>.</p>

</div>
</div>
<a id="a99e3159a9bc6a0113f7957899cb2b636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e3159a9bc6a0113f7957899cb2b636">&#9670;&nbsp;</a></span>removeVarRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineValueConstraints::removeVarRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1presburger.html#a0fa2eacf0a4f6b3656064ea54f8d3c35">presburger::VarKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>varStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>varLimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes variables in the column range [varStart, varLimit), and copies any remaining valid data into place, updates member variables, and resizes arrays as needed. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#afc8d5ae86ad10339a382b7d67a78c853">mlir::presburger::IntegerRelation</a>.</p>

<p>Reimplemented in <a class="el" href="classmlir_1_1FlatAffineRelation.html#ac309343c8793c7ba66946451476ce2a3">mlir::FlatAffineRelation</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00712">712</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

</div>
</div>
<a id="ae3a94ce5a825b81e5767fef38db2329a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a94ce5a825b81e5767fef38db2329a">&#9670;&nbsp;</a></span>reset() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineValueConstraints::reset </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numLocals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>valArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00264">264</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00228">reset()</a>.</p>

</div>
</div>
<a id="ad96f71bbc66b10ee4e5286483b7b141f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96f71bbc66b10ee4e5286483b7b141f">&#9670;&nbsp;</a></span>reset() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineValueConstraints::reset </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numSymbols</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numLocals</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00241">241</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00228">reset()</a>.</p>

</div>
</div>
<a id="a58e00fa2f257f1bd2c8ab11369207198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58e00fa2f257f1bd2c8ab11369207198">&#9670;&nbsp;</a></span>reset() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineValueConstraints::reset </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numReservedInequalities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numReservedEqualities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numReservedCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numLocals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>valArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00249">249</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00045">FlatAffineValueConstraints()</a>.</p>

</div>
</div>
<a id="aadf03e7c9ae234b714e008160e7d3fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf03e7c9ae234b714e008160e7d3fba">&#9670;&nbsp;</a></span>reset() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineValueConstraints::reset </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numReservedInequalities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numReservedEqualities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numReservedCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numLocals</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears any existing data and reserves memory for the specified constraints. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00228">228</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00045">FlatAffineValueConstraints()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00367">checkTilingLegalityImpl()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00080">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00118">mlir::getFlattenedAffineExprs()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00072">getFlattenedAffineExprs()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00240">mlir::getIndexSet()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00066">mlir::ComputationSliceState::getSourceAsConstraints()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00288">mlir::ComputationSliceState::isMaximal()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00241">reset()</a>.</p>

</div>
</div>
<a id="a5eccad1d331cf5cfb78bf1f08fda7224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eccad1d331cf5cfb78bf1f08fda7224">&#9670;&nbsp;</a></span>setValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::FlatAffineValueConstraints::setValue </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> associated with the pos^th variable. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00447">447</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00165">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00509">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01631">mlir::FlatAffineRelation::compose()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00444">mlir::MemRefAccess::getAccessRelation()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01788">mlir::getRelationFromMap()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00454">setValues()</a>.</p>

</div>
</div>
<a id="a320c65d604a6089bb16894e4a9ee33bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320c65d604a6089bb16894e4a9ee33bf">&#9670;&nbsp;</a></span>setValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::FlatAffineValueConstraints::setValues </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the Values associated with the variables in the range [start, end). </p>
<p>The range must contain only dim and symbol variables. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00454">454</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00168">mlir::presburger::IntegerRelation::getNumVars()</a>, <a class="el" href="AffineStructures_8h_source.html#l00447">setValue()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00509">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00692">addAffineIfOpDomain()</a>.</p>

</div>
</div>
<a id="a089f2a8429b04365f4f869c4423ba890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089f2a8429b04365f4f869c4423ba890">&#9670;&nbsp;</a></span>swapVar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineValueConstraints::swapVar </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>posA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>posB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the posA^th variable with the posB^th variable. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a09ab55a06eb5f52a0ba7bb4a73381a59">mlir::presburger::IntegerRelation</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01345">1345</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00225">mlir::presburger::IntegerRelation::getVarKindAt()</a>, <a class="el" href="MlirTblgenMain_8cpp_source.html#l00028">None</a>, and <a class="el" href="AffineStructures_8h_source.html#l00509">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00444">mlir::MemRefAccess::getAccessRelation()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01688">mlir::FlatAffineRelation::inverse()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00393">mergeAndAlignVars()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00519">mergeSymbolVars()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00506">turnSymbolIntoDim()</a>.</p>

</div>
</div>
<a id="af0c35f1d2d81adf4ba06b84df578cd78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c35f1d2d81adf4ba06b84df578cd78">&#9670;&nbsp;</a></span>unionBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::unionBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the constraints to be the smallest bounding (enclosing) box that contains the points of <code>this</code> set and that of <code>other</code>, with the symbols being treated specially. </p>
<p>For each of the dimensions, the min of the lower bounds (symbolic) and the max of the upper bounds (symbolic) is computed to determine such a bounding box. <code>other</code> is expected to have the same dimensional variables as this constraint system (in the same order).</p>
<p>E.g.: 1) this = {0 &lt;= d0 &lt;= 127}, other = {16 &lt;= d0 &lt;= 192}, output = {0 &lt;= d0 &lt;= 192} 2) this = {s0 + 5 &lt;= d0 &lt;= s0 + 20}, other = {s0 + 1 &lt;= d0 &lt;= s0 + 9}, output = {s0 + 1 &lt;= d0 &lt;= s0 + 20} 3) this = {0 &lt;= d0 &lt;= 5, 1 &lt;= d1 &lt;= 9} other = {2 &lt;= d0 &lt;= 6, 5 &lt;= d1 &lt;= 15}, output = {0 &lt;= d0 &lt;= 6, 1 &lt;= d1 &lt;= 15} </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01419">1419</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00328">areVarsAligned()</a>, <a class="el" href="AffineStructures_8h_source.html#l00435">getMaybeValues()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00164">mlir::presburger::IntegerRelation::getNumDimVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00162">mlir::presburger::IntegerRelation::getNumLocalVars()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00393">mergeAndAlignVars()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00808">mlir::computeSliceUnion()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2662045a8d845c7cf9aa9516af6ea914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2662045a8d845c7cf9aa9516af6ea914">&#9670;&nbsp;</a></span>values</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt;, 8&gt; mlir::FlatAffineValueConstraints::values</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Values corresponding to the (column) non-local variables of this constraint system appearing in the order the variables correspond to columns. </p>
<p>Variables that aren't associated with any <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> are set to None. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00509">509</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01284">addSliceBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01386">clearAndCopyFrom()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01631">mlir::FlatAffineRelation::compose()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01228">computeAlignedMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01339">containsVar()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01327">findVar()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00152">FlatAffineValueConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01399">fourierMotzkinEliminate()</a>, <a class="el" href="AffineStructures_8h_source.html#l00431">getAllValues()</a>, <a class="el" href="AffineStructures_8h_source.html#l00435">getMaybeValues()</a>, <a class="el" href="AffineStructures_8h_source.html#l00405">getValue()</a>, <a class="el" href="AffineStructures_8h_source.html#l00422">getValues()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00707">hasConsistentState()</a>, <a class="el" href="AffineStructures_8h_source.html#l00412">hasValue()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00321">hasValues()</a>, <a class="el" href="AffineStructures_8h_source.html#l00447">setValue()</a>, <a class="el" href="AffineStructures_8h_source.html#l00454">setValues()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01345">swapVar()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/Dialect/Affine/Analysis/<a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a></li>
<li>lib/Dialect/Affine/Analysis/<a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 17 2022 20:37:48 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
