<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::scf Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">16.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1scf.html">scf</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::scf Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1scf_1_1LoopNest.html">LoopNest</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1scf_1_1ForLoopPipeliningPattern.html">ForLoopPipeliningPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a pipelined version of the scf.for loop based on the schedule given as option.  <a href="classmlir_1_1scf_1_1ForLoopPipeliningPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html">SCFTilingOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to use to control tiling.  <a href="structmlir_1_1scf_1_1SCFTilingOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1scf_1_1SCFTilingResult.html">SCFTilingResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation information returned after tiling.  <a href="structmlir_1_1scf_1_1SCFTilingResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1scf_1_1SCFTileAndFuseOptions.html">SCFTileAndFuseOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options used to control tile + fuse.  <a href="structmlir_1_1scf_1_1SCFTileAndFuseOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1scf_1_1SCFTileAndFuseResult.html">SCFTileAndFuseResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation information returned after tile and fuse.  <a href="structmlir_1_1scf_1_1SCFTileAndFuseResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1scf_1_1SCFReductionTilingResult.html">SCFReductionTilingResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation information returned after reduction tiling.  <a href="structmlir_1_1scf_1_1SCFReductionTilingResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1scf_1_1PipeliningOption.html">PipeliningOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to dictate how loops should be pipelined.  <a href="structmlir_1_1scf_1_1PipeliningOption.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a82927bf8dc031e20dbe7f1437c1fa7da"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">ValueVector</a> = std::vector&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td></tr>
<tr class="memdesc:a82927bf8dc031e20dbe7f1437c1fa7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">An owning vector of values, handy to return from functions.  <a href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">More...</a><br /></td></tr>
<tr class="separator:a82927bf8dc031e20dbe7f1437c1fa7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac570c5cc67cd9a97e8abf8da08815dae"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#ac570c5cc67cd9a97e8abf8da08815dae">LoopVector</a> = std::vector&lt; scf::ForOp &gt;</td></tr>
<tr class="separator:ac570c5cc67cd9a97e8abf8da08815dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac096a5c42de8c50d86a1615f03c43770"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#ac096a5c42de8c50d86a1615f03c43770">SCFTileSizeComputationFunction</a> = std::function&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td></tr>
<tr class="separator:ac096a5c42de8c50d86a1615f03c43770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6c2254ed26543c85602925d8007821"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#abb6c2254ed26543c85602925d8007821">LoopMatcherFn</a> = <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &amp;, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &amp;, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &amp;)&gt;</td></tr>
<tr class="memdesc:abb6c2254ed26543c85602925d8007821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match "for loop"-like operations: If the first parameter is an iteration variable, return lower/upper bounds via the second/third parameter and the step size via the last parameter.  <a href="namespacemlir_1_1scf.html#abb6c2254ed26543c85602925d8007821">More...</a><br /></td></tr>
<tr class="separator:abb6c2254ed26543c85602925d8007821"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a601f846f06f5959b1a052e975eae8ec1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a601f846f06f5959b1a052e975eae8ec1">buildTerminatedBody</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a601f846f06f5959b1a052e975eae8ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default callback for IfOp builders. Inserts a yield without arguments.  <a href="namespacemlir_1_1scf.html#a601f846f06f5959b1a052e975eae8ec1">More...</a><br /></td></tr>
<tr class="separator:a601f846f06f5959b1a052e975eae8ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888e692b007039a6d2172e34bb0bc429"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a888e692b007039a6d2172e34bb0bc429">ensureLoopTerminator</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="separator:a888e692b007039a6d2172e34bb0bc429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4957ac11a0c4d95f6a1494c808b392"><td class="memItemLeft" align="right" valign="top">ForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a7e4957ac11a0c4d95f6a1494c808b392">getForInductionVarOwner</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a7e4957ac11a0c4d95f6a1494c808b392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the loop parent of an induction variable.  <a href="namespacemlir_1_1scf.html#a7e4957ac11a0c4d95f6a1494c808b392">More...</a><br /></td></tr>
<tr class="separator:a7e4957ac11a0c4d95f6a1494c808b392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13caec83d2c9665221580ea507c6e68b"><td class="memItemLeft" align="right" valign="top">ParallelOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a13caec83d2c9665221580ea507c6e68b">getParallelForInductionVarOwner</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a13caec83d2c9665221580ea507c6e68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parallel loop parent of an induction variable.  <a href="namespacemlir_1_1scf.html#a13caec83d2c9665221580ea507c6e68b">More...</a><br /></td></tr>
<tr class="separator:a13caec83d2c9665221580ea507c6e68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21aa5bfdf43f819b6bf4094f53c6e67"><td class="memItemLeft" align="right" valign="top">ForeachThreadOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#af21aa5bfdf43f819b6bf4094f53c6e67">getForeachThreadOpThreadIndexOwner</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:af21aa5bfdf43f819b6bf4094f53c6e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ForeachThreadOp parent of an thread index variable.  <a href="namespacemlir_1_1scf.html#af21aa5bfdf43f819b6bf4094f53c6e67">More...</a><br /></td></tr>
<tr class="separator:af21aa5bfdf43f819b6bf4094f53c6e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68717bb14a63ffb8d9266322283d253f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a68717bb14a63ffb8d9266322283d253f">insideMutuallyExclusiveBranches</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *a, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *b)</td></tr>
<tr class="memdesc:a68717bb14a63ffb8d9266322283d253f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if ops a and b (or their ancestors) are in mutually exclusive regions/blocks of an IfOp.  <a href="namespacemlir_1_1scf.html#a68717bb14a63ffb8d9266322283d253f">More...</a><br /></td></tr>
<tr class="separator:a68717bb14a63ffb8d9266322283d253f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d89db573aefd9edf2c31fe8e7d5fe1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1scf_1_1LoopNest.html">LoopNest</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a63d89db573aefd9edf2c31fe8e7d5fe1">buildLoopNest</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> steps, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> iterArgs, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">ValueVector</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilder=nullptr)</td></tr>
<tr class="memdesc:a63d89db573aefd9edf2c31fe8e7d5fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a perfect nest of "for" loops, i.e.  <a href="namespacemlir_1_1scf.html#a63d89db573aefd9edf2c31fe8e7d5fe1">More...</a><br /></td></tr>
<tr class="separator:a63d89db573aefd9edf2c31fe8e7d5fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6304a6715d1cc43d3035323cfb4cd78a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1scf_1_1LoopNest.html">LoopNest</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a6304a6715d1cc43d3035323cfb4cd78a">buildLoopNest</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> steps, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilder=nullptr)</td></tr>
<tr class="memdesc:a6304a6715d1cc43d3035323cfb4cd78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience version for building loop nests without iteration arguments (like for reductions).  <a href="namespacemlir_1_1scf.html#a6304a6715d1cc43d3035323cfb4cd78a">More...</a><br /></td></tr>
<tr class="separator:a6304a6715d1cc43d3035323cfb4cd78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131df27a14db6c8a12e643fa2a0a5603"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a131df27a14db6c8a12e643fa2a0a5603">registerTransformDialectExtension</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a131df27a14db6c8a12e643fa2a0a5603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30aa77e8423a12af795fd7c5fcbc562"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#af30aa77e8423a12af795fd7c5fcbc562">registerBufferizableOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:af30aa77e8423a12af795fd7c5fcbc562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc0d8bddd6ca8cbfbde8bdef46228f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1scf_1_1SCFTilingResult.html">SCFTilingResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#addc0d8bddd6ca8cbfbde8bdef46228f0">tileUsingSCFForOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, TilingInterface op, const <a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html">SCFTilingOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:addc0d8bddd6ca8cbfbde8bdef46228f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to tile an op that implements the <code>TilingInterface</code> using <code>scf.for</code> for iterating over the tiles.  <a href="namespacemlir_1_1scf.html#addc0d8bddd6ca8cbfbde8bdef46228f0">More...</a><br /></td></tr>
<tr class="separator:addc0d8bddd6ca8cbfbde8bdef46228f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d9e17330fb4a1d9cca3c928993d9cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1scf_1_1SCFTileAndFuseResult.html">SCFTileAndFuseResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#ae6d9e17330fb4a1d9cca3c928993d9cb">tileConsumerAndFuseProducerGreedilyUsingSCFForOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, TilingInterface consumer, const <a class="el" href="structmlir_1_1scf_1_1SCFTileAndFuseOptions.html">SCFTileAndFuseOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:ae6d9e17330fb4a1d9cca3c928993d9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to tile and fuse a sequence of operations, by tiling the consumer and fusing its producers.  <a href="namespacemlir_1_1scf.html#ae6d9e17330fb4a1d9cca3c928993d9cb">More...</a><br /></td></tr>
<tr class="separator:ae6d9e17330fb4a1d9cca3c928993d9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923f55dccab8af632622d7efa517f6d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; scf::ForOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a923f55dccab8af632622d7efa517f6d2">lowerToLoopsUsingSCFForOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, TilingInterface op)</td></tr>
<tr class="memdesc:a923f55dccab8af632622d7efa517f6d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to lower an <code>op</code> that implements the <code>TilingInterface</code> to loops/scalars.  <a href="namespacemlir_1_1scf.html#a923f55dccab8af632622d7efa517f6d2">More...</a><br /></td></tr>
<tr class="separator:a923f55dccab8af632622d7efa517f6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62bee43950095773c360f1a4a59de818"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1scf_1_1SCFReductionTilingResult.html">scf::SCFReductionTilingResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a62bee43950095773c360f1a4a59de818">tileReductionUsingScf</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;b, PartialReductionOpInterface op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSize)</td></tr>
<tr class="memdesc:a62bee43950095773c360f1a4a59de818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to tile a reduction and generate a parallel op within a serial loop.  <a href="namespacemlir_1_1scf.html#a62bee43950095773c360f1a4a59de818">More...</a><br /></td></tr>
<tr class="separator:a62bee43950095773c360f1a4a59de818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac316a00289a9c7b41712aa0a0de2ea0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#ac316a00289a9c7b41712aa0a0de2ea0c">naivelyFuseParallelOps</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region)</td></tr>
<tr class="memdesc:ac316a00289a9c7b41712aa0a0de2ea0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuses all adjacent scf.parallel operations with identical bounds and step into one scf.parallel operations.  <a href="namespacemlir_1_1scf.html#ac316a00289a9c7b41712aa0a0de2ea0c">More...</a><br /></td></tr>
<tr class="separator:ac316a00289a9c7b41712aa0a0de2ea0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c1901dd11dac0edafe28fb81a765b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a16c1901dd11dac0edafe28fb81a765b0">peelAndCanonicalizeForLoop</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, ForOp forOp, scf::ForOp &amp;partialIteration)</td></tr>
<tr class="memdesc:a16c1901dd11dac0edafe28fb81a765b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite a for loop with bounds/step that potentially do not divide evenly into a for loop where the step divides the iteration space evenly, followed by another scf.for for the last (partial) iteration (if any; returned via <code>partialIteration</code>).  <a href="namespacemlir_1_1scf.html#a16c1901dd11dac0edafe28fb81a765b0">More...</a><br /></td></tr>
<tr class="separator:a16c1901dd11dac0edafe28fb81a765b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac87521511b3088f00423de46226c32c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; ParallelOp, ParallelOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#aac87521511b3088f00423de46226c32c">tileParallelLoop</a> (ParallelOp op, <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; int64_t &gt; tileSizes, bool noMinMaxBounds)</td></tr>
<tr class="memdesc:aac87521511b3088f00423de46226c32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile a parallel loop of the form scf.parallel (i0, i1) = (arg0, arg1) to (arg2, arg3) step (arg4, arg5)  <a href="namespacemlir_1_1scf.html#aac87521511b3088f00423de46226c32c">More...</a><br /></td></tr>
<tr class="separator:aac87521511b3088f00423de46226c32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699a6b066e35f218deec9bf3b59f25c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a699a6b066e35f218deec9bf3b59f25c2">populateSCFStructuralTypeConversionsAndLegality</a> (<a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:a699a6b066e35f218deec9bf3b59f25c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns for SCF structural type conversions and sets up the provided <a class="el" href="classmlir_1_1ConversionTarget.html" title="This class describes a specific conversion target.">ConversionTarget</a> with the appropriate legality configuration for the ops to get converted properly.  <a href="namespacemlir_1_1scf.html#a699a6b066e35f218deec9bf3b59f25c2">More...</a><br /></td></tr>
<tr class="separator:a699a6b066e35f218deec9bf3b59f25c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331c5d2ebecbdc149e0d0637ce2a65c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a331c5d2ebecbdc149e0d0637ce2a65c7">populateSCFLoopPipeliningPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="structmlir_1_1scf_1_1PipeliningOption.html">PipeliningOption</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a331c5d2ebecbdc149e0d0637ce2a65c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns for SCF software pipelining transformation.  <a href="namespacemlir_1_1scf.html#a331c5d2ebecbdc149e0d0637ce2a65c7">More...</a><br /></td></tr>
<tr class="separator:a331c5d2ebecbdc149e0d0637ce2a65c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd982adcd3c785d3417107be92fee3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#acbd982adcd3c785d3417107be92fee3a">populateSCFForLoopCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:acbd982adcd3c785d3417107be92fee3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns for canonicalizing operations inside SCF loop bodies.  <a href="namespacemlir_1_1scf.html#acbd982adcd3c785d3417107be92fee3a">More...</a><br /></td></tr>
<tr class="separator:acbd982adcd3c785d3417107be92fee3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6282e21b62c3efa8abbb78324718e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a8d6282e21b62c3efa8abbb78324718e8">canonicalizeMinMaxOpInLoop</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands, bool isMin, <a class="el" href="namespacemlir_1_1scf.html#abb6c2254ed26543c85602925d8007821">LoopMatcherFn</a> loopMatcher)</td></tr>
<tr class="memdesc:a8d6282e21b62c3efa8abbb78324718e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to canonicalize an min/max operations in the context of for <code>loops</code> with a known range.  <a href="namespacemlir_1_1scf.html#a8d6282e21b62c3efa8abbb78324718e8">More...</a><br /></td></tr>
<tr class="separator:a8d6282e21b62c3efa8abbb78324718e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29fffdd8c409fd79382ab78c38657b73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a29fffdd8c409fd79382ab78c38657b73">rewritePeeledMinMaxOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands, bool isMin, <a class="el" href="classmlir_1_1Value.html">Value</a> iv, <a class="el" href="classmlir_1_1Value.html">Value</a> ub, <a class="el" href="classmlir_1_1Value.html">Value</a> step, bool insideLoop)</td></tr>
<tr class="memdesc:a29fffdd8c409fd79382ab78c38657b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to simplify a min/max operation <code>op</code> after loop peeling.  <a href="namespacemlir_1_1scf.html#a29fffdd8c409fd79382ab78c38657b73">More...</a><br /></td></tr>
<tr class="separator:a29fffdd8c409fd79382ab78c38657b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="abb6c2254ed26543c85602925d8007821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6c2254ed26543c85602925d8007821">&#9670;&nbsp;</a></span>LoopMatcherFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1scf.html#abb6c2254ed26543c85602925d8007821">mlir::scf::LoopMatcherFn</a> = typedef <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>( <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &amp;, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &amp;, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Match "for loop"-like operations: If the first parameter is an iteration variable, return lower/upper bounds via the second/third parameter and the step size via the last parameter. </p>
<p>The function should return <code>success</code> in that case. If the first parameter is not an iteration variable, return <code>failure</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineCanonicalizationUtils_8h_source.html#l00036">36</a> of file <a class="el" href="AffineCanonicalizationUtils_8h_source.html">AffineCanonicalizationUtils.h</a>.</p>

</div>
</div>
<a id="ac570c5cc67cd9a97e8abf8da08815dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac570c5cc67cd9a97e8abf8da08815dae">&#9670;&nbsp;</a></span>LoopVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1scf.html#ac570c5cc67cd9a97e8abf8da08815dae">mlir::scf::LoopVector</a> = typedef std::vector&lt;scf::ForOp&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2SCF_2IR_2SCF_8h_source.html#l00065">65</a> of file <a class="el" href="mlir_2Dialect_2SCF_2IR_2SCF_8h_source.html">SCF.h</a>.</p>

</div>
</div>
<a id="ac096a5c42de8c50d86a1615f03c43770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac096a5c42de8c50d86a1615f03c43770">&#9670;&nbsp;</a></span>SCFTileSizeComputationFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1scf.html#ac096a5c42de8c50d86a1615f03c43770">mlir::scf::SCFTileSizeComputationFunction</a> = typedef std::function&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8h_source.html#l00028">28</a> of file <a class="el" href="TileUsingInterface_8h_source.html">TileUsingInterface.h</a>.</p>

</div>
</div>
<a id="a82927bf8dc031e20dbe7f1437c1fa7da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82927bf8dc031e20dbe7f1437c1fa7da">&#9670;&nbsp;</a></span>ValueVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">mlir::scf::ValueVector</a> = typedef std::vector&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An owning vector of values, handy to return from functions. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2SCF_2IR_2SCF_8h_source.html#l00064">64</a> of file <a class="el" href="mlir_2Dialect_2SCF_2IR_2SCF_8h_source.html">SCF.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6304a6715d1cc43d3035323cfb4cd78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6304a6715d1cc43d3035323cfb4cd78a">&#9670;&nbsp;</a></span>buildLoopNest() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1scf_1_1LoopNest.html">LoopNest</a> mlir::scf::buildLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;&#160;</td>
          <td class="paramname"><em>bodyBuilder</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience version for building loop nests without iteration arguments (like for reductions). </p>
<p>Does not take the initial value of reductions or expect the body building functions to return their current value. The built nested scf::For are captured in <code>capturedLoops</code> when non-null. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00581">581</a> of file <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00508">buildLoopNest()</a>.</p>

</div>
</div>
<a id="a63d89db573aefd9edf2c31fe8e7d5fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d89db573aefd9edf2c31fe8e7d5fe1">&#9670;&nbsp;</a></span>buildLoopNest() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1scf_1_1LoopNest.html">LoopNest</a> mlir::scf::buildLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>iterArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">ValueVector</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;&#160;</td>
          <td class="paramname"><em>bodyBuilder</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a perfect nest of "for" loops, i.e. </p>
<p>all loops but the innermost contain only another loop and a terminator. The lower, upper bounds and steps are provided as <code>lbs</code>, <code>ubs</code> and <code>steps</code>, which are expected to be of the same size. <code>iterArgs</code> points to the initial values of the loop iteration arguments, which will be forwarded through the nest to the innermost loop. The body of the loop is populated using <code>bodyBuilder</code>, which accepts an ordered list of induction variables of all loops, followed by a list of iteration arguments of the innermost loop, in the same order as provided to <code>iterArgs</code>. This function is expected to return as many values as <code>iterArgs</code>, of the same type and in the same order, that will be treated as yielded from the loop body and forwarded back through the loop nest. If the function is not provided, the loop nest is not expected to have iteration arguments, the body of the innermost loop will be left empty, containing only the zero-operand terminator. Returns the <a class="el" href="structmlir_1_1scf_1_1LoopNest.html">LoopNest</a> containing the list of perfectly nest scf::ForOp build during the call. If bound arrays are empty, the body builder will be called once to construct the IR outside of the loop with an empty list of induction variables. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00508">508</a> of file <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8h_source.html#l00388">mlir::OpBuilder::setInsertionPointToEnd()</a>, and <a class="el" href="Builders_8h_source.html#l00383">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00581">buildLoopNest()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00468">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00968">mlir::sparse_tensor::genDenseTensorOrSparseConstantIterLoop()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00563">mlir::linalg::generateParallelLoopNest()</a>, <a class="el" href="MemoryPromotion_8cpp_source.html#l00032">insertCopyLoops()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00748">tilePadOp()</a>.</p>

</div>
</div>
<a id="a601f846f06f5959b1a052e975eae8ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601f846f06f5959b1a052e975eae8ec1">&#9670;&nbsp;</a></span>buildTerminatedBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::scf::buildTerminatedBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default callback for IfOp builders. Inserts a yield without arguments. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00078">78</a> of file <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>.</p>

</div>
</div>
<a id="a8d6282e21b62c3efa8abbb78324718e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d6282e21b62c3efa8abbb78324718e8">&#9670;&nbsp;</a></span>canonicalizeMinMaxOpInLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::scf::canonicalizeMinMaxOpInLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1scf.html#abb6c2254ed26543c85602925d8007821">LoopMatcherFn</a>&#160;</td>
          <td class="paramname"><em>loopMatcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to canonicalize an min/max operations in the context of for <code>loops</code> with a known range. </p>
<p>Canonicalize min/max operations in the context of for loops with a known range.</p>
<p><code>map</code> is the body of the min/max operation and <code>operands</code> are the SSA values that the dimensions and symbols are bound to; dimensions are listed first. If <code>isMin</code>, the operation is a min operation; otherwise, a max operation. <code>loopMatcher</code> is used to retrieve loop bounds and the step size for a given iteration variable.</p>
<p>Note: <code>loopMatcher</code> allows this function to be used with any "for loop"-like operation (scf.for, scf.parallel and even ops defined in other dialects).</p>
<p>Call <code>canonicalizeMinMaxOp</code> and add the following constraints to the constraint system (along with the missing dimensions):</p>
<ul>
<li>iv &gt;= lb</li>
<li>iv &lt; lb + step * ((ub - lb - 1) floorDiv step) + 1</li>
</ul>
<p>Note: Due to limitations of IntegerPolyhedron, only constant step sizes are currently supported. </p>

<p class="definition">Definition at line <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00272">272</a> of file <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html">AffineCanonicalizationUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00203">addLoopRangeConstraints()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00104">canonicalizeMinMaxOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>.</p>

</div>
</div>
<a id="a888e692b007039a6d2172e34bb0bc429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a888e692b007039a6d2172e34bb0bc429">&#9670;&nbsp;</a></span>ensureLoopTerminator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::scf::ensureLoopTerminator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af21aa5bfdf43f819b6bf4094f53c6e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af21aa5bfdf43f819b6bf4094f53c6e67">&#9670;&nbsp;</a></span>getForeachThreadOpThreadIndexOwner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ForeachThreadOp mlir::scf::getForeachThreadOpThreadIndexOwner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ForeachThreadOp parent of an thread index variable. </p>
<p>If the provided value is not a thread index variable, then return nullptr. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l01317">1317</a> of file <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00095">mlir::Value::dyn_cast()</a>.</p>

</div>
</div>
<a id="a7e4957ac11a0c4d95f6a1494c808b392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e4957ac11a0c4d95f6a1494c808b392">&#9670;&nbsp;</a></span>getForInductionVarOwner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ForOp mlir::scf::getForInductionVarOwner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the loop parent of an induction variable. </p>
<p>If the provided value is not an induction variable, then return nullptr. </p>

<p class="reference">Referenced by <a class="el" href="HoistPadding_8cpp_source.html#l00397">mlir::linalg::hoistPaddingOnTensors()</a>.</p>

</div>
</div>
<a id="a13caec83d2c9665221580ea507c6e68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13caec83d2c9665221580ea507c6e68b">&#9670;&nbsp;</a></span>getParallelForInductionVarOwner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParallelOp mlir::scf::getParallelForInductionVarOwner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the parallel loop parent of an induction variable. </p>
<p>If the provided value is not an induction variable, then return nullptr. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l02414">2414</a> of file <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00095">mlir::Value::dyn_cast()</a>.</p>

</div>
</div>
<a id="a68717bb14a63ffb8d9266322283d253f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68717bb14a63ffb8d9266322283d253f">&#9670;&nbsp;</a></span>insideMutuallyExclusiveBranches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::scf::insideMutuallyExclusiveBranches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if ops a and b (or their ancestors) are in mutually exclusive regions/blocks of an IfOp. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l01407">1407</a> of file <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00169">mlir::Operation::getParentOfType()</a>.</p>

</div>
</div>
<a id="a923f55dccab8af632622d7efa517f6d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923f55dccab8af632622d7efa517f6d2">&#9670;&nbsp;</a></span>lowerToLoopsUsingSCFForOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; scf::ForOp &gt; &gt; mlir::scf::lowerToLoopsUsingSCFForOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TilingInterface&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to lower an <code>op</code> that implements the <code>TilingInterface</code> to loops/scalars. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00695">695</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00053">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00517">mlir::RewriterBase::notifyMatchFailure()</a>, and <a class="el" href="Builders_8h_source.html#l00350">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="ac316a00289a9c7b41712aa0a0de2ea0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac316a00289a9c7b41712aa0a0de2ea0c">&#9670;&nbsp;</a></span>naivelyFuseParallelOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::scf::naivelyFuseParallelOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fuses all adjacent scf.parallel operations with identical bounds and step into one scf.parallel operations. </p>
<p>Uses a naive aliasing and dependency analysis. </p>

<p class="definition">Definition at line <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00139">139</a> of file <a class="el" href="ParallelLoopFusion_8cpp_source.html">ParallelLoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00124">fuseIfLegal()</a>, and <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00158">mlir::isMemoryEffectFree()</a>.</p>

</div>
</div>
<a id="a16c1901dd11dac0edafe28fb81a765b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c1901dd11dac0edafe28fb81a765b0">&#9670;&nbsp;</a></span>peelAndCanonicalizeForLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::scf::peelAndCanonicalizeForLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForOp &amp;&#160;</td>
          <td class="paramname"><em>partialIteration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite a for loop with bounds/step that potentially do not divide evenly into a for loop where the step divides the iteration space evenly, followed by another scf.for for the last (partial) iteration (if any; returned via <code>partialIteration</code>). </p>
<p>This transformation is called "loop peeling".</p>
<p>This transformation is beneficial for a wide range of transformations such as vectorization or loop tiling: It enables additional canonicalizations inside the peeled loop body such as rewriting masked loads into unmaked loads.</p>
<p>E.g., assuming a lower bound of 0 (for illustration purposes): </p><div class="fragment"><div class="line">scf.for %iv = %c0 to %ub step %c4 {</div>
<div class="line">  (loop body)</div>
<div class="line">}</div>
</div><!-- fragment --><p> is rewritten into the following pseudo IR: </p><div class="fragment"><div class="line">%newUb = %ub - (%ub <a class="code" href="namespacemlir.html#afca33cad5b0cd935568ea0fc0a439abd">mod</a> %c4)</div>
<div class="line">scf.for %iv = %c0 to %newUb step %c4 {</div>
<div class="line">  (loop body)</div>
<div class="line">}</div>
<div class="line">scf.for %iv2 = %newUb to %ub {</div>
<div class="line">  (loop body)</div>
<div class="line">}</div>
<div class="ttc" id="anamespacemlir_html_afca33cad5b0cd935568ea0fc0a439abd"><div class="ttname"><a href="namespacemlir.html#afca33cad5b0cd935568ea0fc0a439abd">mlir::mod</a></div><div class="ttdeci">int64_t mod(int64_t lhs, int64_t rhs)</div><div class="ttdoc">Returns MLIR's mod operation on constants.</div><div class="ttdef"><b>Definition:</b> <a href="MathExtras_8h_source.html#l00045">MathExtras.h:45</a></div></div>
</div><!-- fragment --><p>After loop peeling, this function tries to simplify/canonicalize affine.min and affine.max ops in the body of the peeled loop and in the body of the partial iteration loop, taking advantage of the fact that the peeled loop has only "full" iterations. This canonicalization is expected to enable further canonicalization opportunities through other patterns.</p>
<p>The return value indicates whether the loop was rewritten or not. Loops are not rewritten if:</p><ul>
<li>Loop step size is 1 or</li>
<li>Loop bounds and step size are static, and step already divides the iteration space evenly.</li>
</ul>
<p>Note: This function rewrites the given scf.for loop in-place and creates a new scf.for operation for the last iteration. It replaces all uses of the unpeeled loop with the results of the newly generated scf.for. </p>

<p class="reference">Referenced by <a class="el" href="Transforms_8cpp_source.html#l00221">mlir::linalg::peelLoop()</a>.</p>

</div>
</div>
<a id="acbd982adcd3c785d3417107be92fee3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd982adcd3c785d3417107be92fee3a">&#9670;&nbsp;</a></span>populateSCFForLoopCanonicalizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::scf::populateSCFForLoopCanonicalizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns for canonicalizing operations inside SCF loop bodies. </p>
<p>At the moment, only affine.min/max computations with iteration variables, loop bounds and loop steps are canonicalized. </p>

<p class="definition">Definition at line <a class="el" href="LoopCanonicalization_8cpp_source.html#l00213">213</a> of file <a class="el" href="LoopCanonicalization_8cpp_source.html">LoopCanonicalization.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01587">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01563">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a331c5d2ebecbdc149e0d0637ce2a65c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331c5d2ebecbdc149e0d0637ce2a65c7">&#9670;&nbsp;</a></span>populateSCFLoopPipeliningPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::scf::populateSCFLoopPipeliningPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1scf_1_1PipeliningOption.html">PipeliningOption</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns for SCF software pipelining transformation. </p>
<p>See the <a class="el" href="classmlir_1_1scf_1_1ForLoopPipeliningPattern.html" title="Generate a pipelined version of the scf.for loop based on the schedule given as option.">ForLoopPipeliningPattern</a> for the transformation details. </p>

<p class="definition">Definition at line <a class="el" href="LoopPipelining_8cpp_source.html#l00575">575</a> of file <a class="el" href="LoopPipelining_8cpp_source.html">LoopPipelining.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01587">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l01563">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

</div>
</div>
<a id="a699a6b066e35f218deec9bf3b59f25c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699a6b066e35f218deec9bf3b59f25c2">&#9670;&nbsp;</a></span>populateSCFStructuralTypeConversionsAndLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::scf::populateSCFStructuralTypeConversionsAndLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates patterns for SCF structural type conversions and sets up the provided <a class="el" href="classmlir_1_1ConversionTarget.html" title="This class describes a specific conversion target.">ConversionTarget</a> with the appropriate legality configuration for the ops to get converted properly. </p>
<p>A "structural" type conversion is one where the underlying ops are completely agnostic to the actual types involved and simply need to update their types. An example of this is scf.if &ndash; the scf.if op and the corresponding scf.yield ops need to update their types accordingly to the <a class="el" href="classmlir_1_1TypeConverter.html" title="Type conversion class.">TypeConverter</a>, but otherwise don't care what type conversions are happening. </p>

<p class="definition">Definition at line <a class="el" href="StructuralTypeConversions_8cpp_source.html#l00250">250</a> of file <a class="el" href="StructuralTypeConversions_8cpp_source.html">StructuralTypeConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01587">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8h_source.html#l00716">mlir::ConversionTarget::addDynamicallyLegalOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l01563">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="DialectConversion_8cpp_source.html#l02999">mlir::TypeConverter::isLegal()</a>.</p>

</div>
</div>
<a id="af30aa77e8423a12af795fd7c5fcbc562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30aa77e8423a12af795fd7c5fcbc562">&#9670;&nbsp;</a></span>registerBufferizableOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::scf::registerBufferizableOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SCF_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l01208">1208</a> of file <a class="el" href="SCF_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html">BufferizableOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00179">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllDialects_8h_source.html#l00075">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a131df27a14db6c8a12e643fa2a0a5603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a131df27a14db6c8a12e643fa2a0a5603">&#9670;&nbsp;</a></span>registerTransformDialectExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::scf::registerTransformDialectExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SCFTransformOps_8cpp_source.html#l00255">255</a> of file <a class="el" href="SCFTransformOps_8cpp_source.html">SCFTransformOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00185">mlir::DialectRegistry::addExtensions()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllDialects_8h_source.html#l00075">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a29fffdd8c409fd79382ab78c38657b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29fffdd8c409fd79382ab78c38657b73">&#9670;&nbsp;</a></span>rewritePeeledMinMaxOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::scf::rewritePeeledMinMaxOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>insideLoop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to simplify a min/max operation <code>op</code> after loop peeling. </p>
<p>This function can simplify min/max operations such as (ub is the previous upper bound of the unpeeled loop): </p><div class="fragment"><div class="line"><span class="preprocessor">#map = affine_map&lt;(d0)[s0, s1] -&gt; (s0, -d0 + s1)&gt;</span></div>
<div class="line"><span class="preprocessor">%r = affine.min #affine.min #map(%iv)[%step, %ub]</span></div>
</div><!-- fragment --><p> and rewrites them into (in the case the peeled loop): </p><div class="fragment"><div class="line">%r = %step</div>
</div><!-- fragment --><p> min/max operations inside the partial iteration are rewritten in a similar way.</p>
<p>This function can simplify min/max operations such as (ub is the previous upper bound of the unpeeled loop): </p><div class="fragment"><div class="line"><span class="preprocessor">#map = affine_map&lt;(d0)[s0, s1] -&gt; (s0, -d0 + s1)&gt;</span></div>
<div class="line"><span class="preprocessor">%r = affine.min #affine.min #map(%iv)[%step, %ub]</span></div>
</div><!-- fragment --><p> and rewrites them into (in the case the peeled loop): </p><div class="fragment"><div class="line">%r = %step</div>
</div><!-- fragment --><p> min/max operations inside the partial iteration are rewritten in a similar way.</p>
<p>This function builds up a set of constraints, capable of proving that:</p><ul>
<li>Inside the peeled loop: min(step, ub - iv) == step</li>
<li>Inside the partial iteration: min(step, ub - iv) == ub - iv</li>
</ul>
<p>Returns <code>success</code> if the given operation was replaced by a new operation; <code>failure</code> otherwise.</p>
<p>Note: <code>ub</code> is the previous upper bound of the loop (before peeling). <code>insideLoop</code> must be true for min/max ops inside the loop and false for affine.min ops inside the partial iteration. For an explanation of the other parameters, see comment of <code>canonicalizeMinMaxOpInLoop</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00326">326</a> of file <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html">AffineCanonicalizationUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01170">mlir::FlatAffineValueConstraints::addBound()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00282">mlir::presburger::IntegerRelation::addInequality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00272">mlir::FlatAffineValueConstraints::appendDimVar()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00104">canonicalizeMinMaxOp()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00398">mlir::presburger::IntegerRelation::EQ</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00096">mlir::getConstantIntValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopSpecialization_8cpp_source.html#l00158">rewriteAffineOpAfterPeeling()</a>.</p>

</div>
</div>
<a id="ae6d9e17330fb4a1d9cca3c928993d9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d9e17330fb4a1d9cca3c928993d9cb">&#9670;&nbsp;</a></span>tileConsumerAndFuseProducerGreedilyUsingSCFForOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1scf_1_1SCFTileAndFuseResult.html">scf::SCFTileAndFuseResult</a> &gt; mlir::scf::tileConsumerAndFuseProducerGreedilyUsingSCFForOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TilingInterface&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1scf_1_1SCFTileAndFuseOptions.html">SCFTileAndFuseOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to tile and fuse a sequence of operations, by tiling the consumer and fusing its producers. </p>
<p>Implementation of tile consumer and fuse producer greedily.</p>
<p>Note that this assumes that it is valid to tile+fuse the producer into the innermost tiled loop. Its up to the caller to ensure that the tile sizes provided make this fusion valid.</p>
<p>For example, for the following sequence</p>
<div class="fragment"><div class="line">%0 =</div>
<div class="line">%1 = linalg.fill ... outs(%0 : ... )</div>
<div class="line">%2 = linalg.matmul ... outs(%1 : ...) ...</div>
</div><!-- fragment --><p>it is legal to fuse the fill with the matmul only if the matmul is tiled along the parallel dimensions and not the reduction dimension, i.e. the tile size for the reduction dimension should be 0. The resulting fused transformation is</p>
<div class="fragment"><div class="line">%1 = scf.for ... iter_args(%arg0 = %0)</div>
<div class="line">  %2 = tensor.extract_slice %arg0</div>
<div class="line">  %3 = linalg.fill .. outs(%2 : ... )</div>
<div class="line">  %4 = linalg.matmul .. outs(%3 : ...)</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00535">535</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00230">mlir::detail::enumerate()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00295">mlir::Operation::getOperands()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00517">getUntiledProducerFromSliceSource()</a>, <a class="el" href="TileUsingInterface_8h_source.html#l00101">mlir::scf::SCFTileAndFuseResult::loops</a>, <a class="el" href="PatternMatch_8h_source.html#l00517">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, <a class="el" href="SwapExtractSliceWithProducerPatterns_8cpp_source.html#l00023">mlir::tensor::replaceExtractSliceWithTiledProducer()</a>, <a class="el" href="TileUsingInterface_8h_source.html#l00103">mlir::scf::SCFTileAndFuseResult::replacements</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00261">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="Builders_8h_source.html#l00350">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="TileUsingInterface_8h_source.html#l00099">mlir::scf::SCFTileAndFuseResult::tiledAndFusedOps</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00278">tileUsingSCFForOp()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00264">updateDestinationOperandsForTiledOp()</a>.</p>

</div>
</div>
<a id="aac87521511b3088f00423de46226c32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac87521511b3088f00423de46226c32c">&#9670;&nbsp;</a></span>tileParallelLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; ParallelOp, ParallelOp &gt; mlir::scf::tileParallelLoop </td>
          <td>(</td>
          <td class="paramtype">ParallelOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noMinMaxBounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile a parallel loop of the form scf.parallel (i0, i1) = (arg0, arg1) to (arg2, arg3) step (arg4, arg5) </p>
<p>into scf.parallel (i0, i1) = (arg0, arg1) to (arg2, arg3) step (arg4*tileSize[0], arg5*tileSize[1]) scf.parallel (j0, j1) = (0, 0) to (min(tileSize[0], arg2-j0) min(tileSize[1], arg3-j1)) step (arg4, arg5) The old loop is replaced with the new one.</p>
<p>The function returns the resulting ParallelOps, i.e. {outer_loop_op, inner_loop_op}.</p>
<p>into scf.parallel (i0, i1) = (arg0, arg1) to (arg2, arg3) step (arg4*tileSize[0], arg5*tileSize[1]) scf.parallel (j0, j1) = (0, 0) to (min(arg4*tileSize[0], arg2-i0) min(arg5*tileSize[1], arg3-i1)) step (arg4, arg5)</p>
<p>or, when no-min-max-bounds is true, into scf.parallel (i0, i1) = (arg0, arg1) to (arg2, arg3) step (arg4*tileSize[0], arg5*tileSize[1]) scf.parallel (j0, j1) = (0, 0) to (arg4*tileSize[0], arg5*tileSize[1]) step (arg4, arg5) inbound = (j0 * arg4 + i0 &lt; arg2) &amp;&amp; (j1 * arg5 + i1 &lt; arg3) scf.if (inbound) ....</p>
<p>where the uses of i0 and i1 in the loop body are replaced by i0 + j0 and i1 + j1.</p>
<p>The old loop is replaced with the new one. </p>

<p class="definition">Definition at line <a class="el" href="ParallelLoopTiling_8cpp_source.html#l00058">58</a> of file <a class="el" href="ParallelLoopTiling_8cpp_source.html">ParallelLoopTiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="Matchers_8h_source.html#l00230">mlir::detail::enumerate()</a>, <a class="el" href="Block_8cpp_source.html#l00189">mlir::Block::eraseArguments()</a>, <a class="el" href="Block_8h_source.html#l00142">mlir::Block::front()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01043">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00488">mlir::getAffineDimExpr()</a>, <a class="el" href="Block_8h_source.html#l00118">mlir::Block::getArgument()</a>, <a class="el" href="Builders_8h_source.html#l00054">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00056">mlir::Builder::getIndexType()</a>, <a class="el" href="Builders_8cpp_source.html#l00072">mlir::Builder::getIntegerType()</a>, <a class="el" href="Block_8h_source.html#l00117">mlir::Block::getNumArguments()</a>, <a class="el" href="Value_8cpp_source.html#l00061">mlir::Value::replaceAllUsesExcept()</a>, and <a class="el" href="Builders_8h_source.html#l00383">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

</div>
</div>
<a id="a62bee43950095773c360f1a4a59de818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62bee43950095773c360f1a4a59de818">&#9670;&nbsp;</a></span>tileReductionUsingScf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1scf_1_1SCFReductionTilingResult.html">scf::SCFReductionTilingResult</a> &gt; mlir::scf::tileReductionUsingScf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PartialReductionOpInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to tile a reduction and generate a parallel op within a serial loop. </p>
<p>Each of the partial reductions are calculated in parallel. Then after the loop all the partial reduction are merged into a final reduction. For example for the following sequence</p>
<div class="fragment"><div class="line">%0 = linalg.generic %in [&quot;parallel&quot;, &quot;reduction&quot;]</div>
<div class="line">  : tensor&lt;7x9xf32&gt; -&gt; tensor&lt;7xf32&gt;</div>
</div><!-- fragment --><p>into:</p>
<div class="fragment"><div class="line">%0 = linalg.fill ... : tensor&lt;7x4xf32&gt;</div>
<div class="line">%1 = scf.for ... iter_args(%arg0 = %0)</div>
<div class="line">  %2 = tensor.extract_slice %arg0 : tensor&lt;7x4xf32&gt; -&gt; tensor&lt;7x?xf32&gt;</div>
<div class="line">  %3 = tensor.extract_slice %in : tensor&lt;7x9xf32&gt; -&gt; tensor&lt;7x?xf32&gt;</div>
<div class="line">  %4 = linalg.generic %2, %3 [&quot;parallel&quot;, &quot;parallel&quot;]</div>
<div class="line">    : tensor&lt;7x?xf32&gt; -&gt; tensor&lt;7x?xf32&gt;</div>
<div class="line">  %5 = tensor.insert_slice %3, %0[0, 0] : tensor&lt;7x4xf32&gt;</div>
<div class="line">}</div>
<div class="line">%6 = linalg.generic %1 [&quot;parallel&quot;, &quot;reduction&quot;]</div>
<div class="line">  : tensor&lt;7x4xf32&gt; -&gt; tensor&lt;7xf32&gt;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00424">424</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8h_source.html#l00472">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Matchers_8h_source.html#l00230">mlir::detail::enumerate()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00140">generateTileLoopNest()</a>, <a class="el" href="Builders_8cpp_source.html#l00109">mlir::Builder::getIndexAttr()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00324">mlir::Operation::getResult()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00332">mlir::Operation::getResults()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00053">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="TileUsingInterface_8h_source.html#l00148">mlir::scf::SCFReductionTilingResult::initialOp</a>, <a class="el" href="TileUsingInterface_8h_source.html#l00150">mlir::scf::SCFReductionTilingResult::loops</a>, <a class="el" href="TileUsingInterface_8h_source.html#l00146">mlir::scf::SCFReductionTilingResult::mergeOp</a>, <a class="el" href="PatternMatch_8h_source.html#l00517">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="TileUsingInterface_8h_source.html#l00144">mlir::scf::SCFReductionTilingResult::parallelTiledOp</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00261">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="Builders_8h_source.html#l00350">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="Builders_8h_source.html#l00364">mlir::OpBuilder::setInsertionPointAfter()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00264">updateDestinationOperandsForTiledOp()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00204">yieldTiledValues()</a>.</p>

</div>
</div>
<a id="addc0d8bddd6ca8cbfbde8bdef46228f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addc0d8bddd6ca8cbfbde8bdef46228f0">&#9670;&nbsp;</a></span>tileUsingSCFForOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1scf_1_1SCFTilingResult.html">scf::SCFTilingResult</a> &gt; mlir::scf::tileUsingSCFForOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TilingInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html">SCFTilingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to tile an op that implements the <code>TilingInterface</code> using <code>scf.for</code> for iterating over the tiles. </p>
<p>Implementation of tiling transformation of <code>op</code> that implements the <code>TilingInterface</code> using <code>scf.for</code> to iterate over the tiles. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00278">278</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8h_source.html#l00039">mlir::applyPermutationToVector()</a>, <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="Matchers_8h_source.html#l00230">mlir::detail::enumerate()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00050">fillInterchangeVector()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00140">generateTileLoopNest()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00097">mlir::tensor::getOrCreateDestinations()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00665">mlir::inversePermutation()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00072">invertPermutationVector()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00080">isPermutation()</a>, <a class="el" href="TileUsingInterface_8h_source.html#l00070">mlir::scf::SCFTilingResult::loops</a>, <a class="el" href="PatternMatch_8h_source.html#l00517">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, <a class="el" href="TileUsingInterface_8h_source.html#l00073">mlir::scf::SCFTilingResult::replacements</a>, <a class="el" href="Builders_8h_source.html#l00350">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="Builders_8h_source.html#l00364">mlir::OpBuilder::setInsertionPointAfter()</a>, <a class="el" href="TileUsingInterface_8h_source.html#l00068">mlir::scf::SCFTilingResult::tiledOps</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00264">updateDestinationOperandsForTiledOp()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00204">yieldTiledValues()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00535">tileConsumerAndFuseProducerGreedilyUsingSCFForOp()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 17 2022 20:37:51 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
