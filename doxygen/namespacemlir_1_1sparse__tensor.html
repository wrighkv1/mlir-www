<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::sparse_tensor Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">16.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1sparse__tensor.html">sparse_tensor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::sparse_tensor Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1sparse__tensor_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1sparse__tensor_1_1SparseCompilerOptions.html">SparseCompilerOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for the "sparse-compiler" pipeline.  <a href="structmlir_1_1sparse__tensor_1_1SparseCompilerOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1sparse__tensor_1_1Children.html">Children</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1sparse__tensor_1_1Children.html" title="Children subexpressions of tensor operations.">Children</a> subexpressions of tensor operations.  <a href="structmlir_1_1sparse__tensor_1_1Children.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1sparse__tensor_1_1TensorExp.html">TensorExp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor expression. Represents a MLIR expression in tensor index notation.  <a href="structmlir_1_1sparse__tensor_1_1TensorExp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1sparse__tensor_1_1LatPoint.html">LatPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lattice point.  <a href="structmlir_1_1sparse__tensor_1_1LatPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1Merger.html">Merger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to handle all iteration lattice operations.  <a href="classmlir_1_1sparse__tensor_1_1Merger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1sparse__tensor_1_1Element.html">Element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An element of a sparse tensor in coordinate-scheme representation (i.e., a pair of indices and value).  <a href="structmlir_1_1sparse__tensor_1_1Element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1sparse__tensor_1_1ElementLT.html">ElementLT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closure object for <code>operator&lt;</code> on <code><a class="el" href="structmlir_1_1sparse__tensor_1_1Element.html" title="An element of a sparse tensor in coordinate-scheme representation (i.e., a pair of indices and value)...">Element</a></code> with a given rank.  <a href="structmlir_1_1sparse__tensor_1_1ElementLT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorCOO.html">SparseTensorCOO</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memory-resident sparse tensor in coordinate-scheme representation (a collection of <code><a class="el" href="structmlir_1_1sparse__tensor_1_1Element.html" title="An element of a sparse tensor in coordinate-scheme representation (i.e., a pair of indices and value)...">Element</a></code>s).  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorCOO.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorReader.html">SparseTensorReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class abstracts over the information stored in file headers, as well as providing the buffers and methods for parsing those headers.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorEnumeratorBase.html">SparseTensorEnumeratorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (higher-order) function object for enumerating the elements of some <code><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html" title="A memory-resident sparse tensor using a storage scheme based on per-dimension sparse/dense annotation...">SparseTensorStorage</a></code> under a permutation.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorEnumeratorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html">SparseTensorStorageBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for <code><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html" title="A memory-resident sparse tensor using a storage scheme based on per-dimension sparse/dense annotation...">SparseTensorStorage</a>&lt;P,I,V&gt;</code>.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorEnumerator.html">SparseTensorEnumerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html">SparseTensorStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memory-resident sparse tensor using a storage scheme based on per-dimension sparse/dense annotations.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorNNZ.html">SparseTensorNNZ</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics regarding the number of nonzero subtensors in a source tensor, for direct sparse=&gt;sparse conversion a la <a href="https://arxiv.org/abs/2001.02609">https://arxiv.org/abs/2001.02609</a>.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorNNZ.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorLoopEmitter.html">SparseTensorLoopEmitter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1BufferizeDenseOpsPass.html">BufferizeDenseOpsPass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pass that bufferizes only dense tensor ops and ignores all sparse tensor ops.  <a href="classmlir_1_1sparse__tensor_1_1BufferizeDenseOpsPass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9ae79c9f12ec66ff6b11cbd106730028"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a9ae79c9f12ec66ff6b11cbd106730028">index_type</a> = uint64_t</td></tr>
<tr class="memdesc:a9ae79c9f12ec66ff6b11cbd106730028"><td class="mdescLeft">&#160;</td><td class="mdescRight">This type is used in the public API at all places where MLIR expects values with the built-in type "index".  <a href="namespacemlir_1_1sparse__tensor.html#a9ae79c9f12ec66ff6b11cbd106730028">More...</a><br /></td></tr>
<tr class="separator:a9ae79c9f12ec66ff6b11cbd106730028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00af5771ba3ad826897458cda0b6fbde"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a00af5771ba3ad826897458cda0b6fbde">complex64</a> = std::complex&lt; double &gt;</td></tr>
<tr class="separator:a00af5771ba3ad826897458cda0b6fbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d22ed3f513f0693e476e464aad74007"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a6d22ed3f513f0693e476e464aad74007">complex32</a> = std::complex&lt; float &gt;</td></tr>
<tr class="separator:a6d22ed3f513f0693e476e464aad74007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399fe87fe98fac2976f2d4a5222d24b1"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a399fe87fe98fac2976f2d4a5222d24b1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a399fe87fe98fac2976f2d4a5222d24b1">ElementConsumer</a> = const std::function&lt; void(const std::vector&lt; uint64_t &gt; &amp;, V)&gt; &amp;</td></tr>
<tr class="memdesc:a399fe87fe98fac2976f2d4a5222d24b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of callback functions which receive an element.  <a href="namespacemlir_1_1sparse__tensor.html#a399fe87fe98fac2976f2d4a5222d24b1">More...</a><br /></td></tr>
<tr class="separator:a399fe87fe98fac2976f2d4a5222d24b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a32a597cffeb76da76443c157781e9d60"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60">OverheadType</a> : uint32_t { <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473faaaa1335fda1c8d46b88c83f27e161967">kIndex</a> = 0
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60a6256cfbcd370939b8454d9eca86b9d2a">kU64</a> = 1
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60a4f2abe781a12702f9fbaea79fb6ba042">kU32</a> = 2
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60a9070b7eed719acaf36119d4a2835a230">kU16</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60aeda0b712c7690a5c8921fa54baad333e">kU8</a> = 4
<br />
 }</td></tr>
<tr class="memdesc:a32a597cffeb76da76443c157781e9d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encoding of overhead types (both pointer overhead and indices overhead), for "overloading" @newSparseTensor.  <a href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60">More...</a><br /></td></tr>
<tr class="separator:a32a597cffeb76da76443c157781e9d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7f4629fd99e5db6d08448472c904ab"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904ab">PrimaryType</a> : uint32_t { <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904aba5234930e162acb53b17e178221057319">kF64</a> = 1
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904aba941c992a0e3d2eb28203202730996ba2">kF32</a> = 2
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904aba13a852aa20c7c1030c7d2588b5d799b6">kF16</a> = 3
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904aba7b2caf2ed7b5f4f177fe3207cd198791">kBF16</a> = 4
, <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904aba6601e7b0f7c0f03d9ffa9f222c82e6a0">kI64</a> = 5
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904aba0a0ecdb4eded286c722877578774a293">kI32</a> = 6
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904aba1201e21104cbb7ea3a7c362efcb325a3">kI16</a> = 7
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904aba6c86e764d5c427a8339c3920a3c08603">kI8</a> = 8
, <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904abab669ff1c81c4c96d8631985f992cb07c">kC64</a> = 9
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904abaec949612bf882299f31abe2c9e57fe3b">kC32</a> = 10
<br />
 }</td></tr>
<tr class="memdesc:a6a7f4629fd99e5db6d08448472c904ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encoding of the elemental type, for "overloading" @newSparseTensor.  <a href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904ab">More...</a><br /></td></tr>
<tr class="separator:a6a7f4629fd99e5db6d08448472c904ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381f27e8f48be9793332d997f81ebecb"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a381f27e8f48be9793332d997f81ebecb">Action</a> : uint32_t { <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1sparse__tensor.html#a381f27e8f48be9793332d997f81ebecba65d0c57fb98927f91459ad92c864def8">kEmpty</a> = 0
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a381f27e8f48be9793332d997f81ebecba448114fe5d01bb8b9762d455823218cb">kFromFile</a> = 1
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a381f27e8f48be9793332d997f81ebecba1d496f347acad67edc9d6dac4a59a61c">kFromCOO</a> = 2
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a381f27e8f48be9793332d997f81ebecba316dceb03f204e8cfa616cfc497f107e">kSparseToSparse</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1sparse__tensor.html#a381f27e8f48be9793332d997f81ebecbae5795f0f2d65cc34484b9d1ee5560355">kEmptyCOO</a> = 4
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a381f27e8f48be9793332d997f81ebecbacb46e8dcc6f75ae21696ae715dd8915d">kToCOO</a> = 5
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a381f27e8f48be9793332d997f81ebecbac38414adc2b2d3b1e06a909f8a7b3b76">kToIterator</a> = 6
<br />
 }</td></tr>
<tr class="memdesc:a381f27e8f48be9793332d997f81ebecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actions performed by @newSparseTensor.  <a href="namespacemlir_1_1sparse__tensor.html#a381f27e8f48be9793332d997f81ebecb">More...</a><br /></td></tr>
<tr class="separator:a381f27e8f48be9793332d997f81ebecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09f02b16598f192895bfa41d8032a95"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95a6bf5613f65a74a7f8388b26adefaef2b">Undef</a> = 0
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95a9a71a13863c84ba34fc41595fc2ee0c6">Dense</a> = 4
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95a4d602abc0c0f2f7c1a5156d964517e4e">Compressed</a> = 8
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95a562632a70ad5a0b18dc4f9906de54253">CompressedNu</a> = 9
, <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95a8da13245daa135f56df9e0f92b5d22c5">CompressedNo</a> = 10
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95a04fd51749f0663ff642b8450e7165121">CompressedNuNo</a> = 11
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95a6ff5f73c8b5ebd311406568c8ef50bfd">Singleton</a> = 16
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95adca8973f87378bd3149fb9a6eca586fa">SingletonNu</a> = 17
, <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95a942ed5aa2dca9dfc250da72a338b1c71">SingletonNo</a> = 18
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95a114102a8e33ed979a0da383c49b215ed">SingletonNuNo</a> = 19
<br />
 }</td></tr>
<tr class="memdesc:aa09f02b16598f192895bfa41d8032a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enum defines all the sparse representations supportable by the SparseTensor dialect.  <a href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">More...</a><br /></td></tr>
<tr class="separator:aa09f02b16598f192895bfa41d8032a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab3a6a8f6871198b20d1e93409a473f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473f">Kind</a> { <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fab15d67d80801ec6c96d229847aa4507f">kTensor</a> = 0
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa0dad027d1a3ae9e8b421e99443ec4506">kInvariant</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa564bd6edb3f5dbe871faa2c145e36790">kIndex</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473faaaa1335fda1c8d46b88c83f27e161967">kIndex</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fae446424dcbca886a4232526e6865bc86">kAbsF</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fad89785a0e047524d79f6dc6e33dc697f">kAbsC</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fae3ea4147268a5b11fd14808025e03121">kAbsI</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa32cfd22bc608b55cb3cc404f8a1be87a">kCeilF</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa6c43e29963859385bd2d92c9023b7689">kFloorF</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fab226f363eecae3747869314ebfab84fe">kSqrtF</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fac40a698d21108f1c0b188990f25227b1">kSqrtC</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa1cd8718dbe0a0ffa20d9dfc62e51b992">kExpm1F</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa9cfb6436f95a29c2faa1284fc5a6f473">kExpm1C</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473faa82e599d247b111d7ec234e151bb074e">kLog1pF</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fab99b42569b87e1f6a83114b5b4983c10">kLog1pC</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa1293be53c127fa36bfc58a9c793495ad">kSinF</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fab4afeb2d7ae89f7262eed382affea889">kSinC</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473faebc711d47ff5be1c252504d9c9ae2331">kTanhF</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa179bba8dde7ea15b09eba8b42012f140">kTanhC</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa26224c7d9c615460553d533be63b5826">kNegF</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fad6d145601512af47bd1ddbca628dbb20">kNegC</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fac00e9da99623b62364783e7d610519ba">kNegI</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473faf90d34cb35c6883df080dd03054402d1">kTruncF</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa622f146e3bc5ba1bf4f4f3ffb15841b3">kExtF</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa9f18947d2c19c47e0f71e3a52cd47f68">kCastFS</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa5362d334aeb504f33b1ecf702e3af0f2">kCastFU</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473faa3d024040e8d017004b1d6b03b800249">kCastSF</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473faa1472c2468bb45bc016ded6f7421f656">kCastUF</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa2339a935a0013fe6f7c6cec4744f321e">kCastS</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fac6082a5a571997a15889a46d38f6fbe5">kCastU</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa2b948b86a786f7a160087d725233c0be">kCastIdx</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa224bd99009853cf7ef74b09c65734559">kTruncI</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fab148b7730518be2c0507716ac375239b">kCIm</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fabe669208044fe021b30a3a9e161c2c71">kCRe</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa0b5838435ba246753f5e7a659c6d6cf2">kBitCast</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa6ae54f6f44b9430c0a2520062efc0df5">kBinaryBranch</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa0404bfcfac34897366a8b27b15cf3cfc">kUnary</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fac354943a8aa7f784f1c595fcd011df88">kSelect</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa2ce9ab16af1ff17d5ce97aaeac25000e">kMulF</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa4283f386a777415d9c12cfb13fb2ab1f">kMulC</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa4115c96415ac84fc8209f94da4f86c0a">kMulI</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473faeef35e5eb247c144277f9240ee09c284">kDivF</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fab0105b6265c9c2d1aa72d744b897dda3">kDivC</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa005a371c5ee45bb28e4b912fdbc547cd">kDivS</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473facf6645fdc82730c8d0287511b4a445f5">kDivU</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa31016f4ebccd93c3dd80e8e04f554726">kAddF</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa8dc1eb52b7523c1b2bf7427b6edd3990">kAddC</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fad74e308af000953c9a9c54c131c96e4e">kAddI</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa513b8a419c15653052ea801f6e6d02d7">kSubF</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa54b6ed4559e68f69c08a4c77088d142b">kSubC</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa0b60bf24a69f158c49eec6b64abbc203">kSubI</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fab55827336f3893743d80e8c7e42985b4">kAndI</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa785dbbb184d9ea3f71f5928d416ac7e2">kOrI</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473facbd0b073776a159cdb3cae7bc8cd884b">kXorI</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa6191183cedfbcb9393d84168e30c29a2">kShrS</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa475c7b7b44c4500e84108c305827cca8">kShrU</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fac48a99a57f90e42db19b77661e8e7cdd">kShlI</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fae1d767de5e7279ef7fea56db7a941965">kBinary</a>
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473fa8edcd92441bd8a185a8be124b8b033be">kReduce</a>
<br />
 }</td></tr>
<tr class="memdesc:a1ab3a6a8f6871198b20d1e93409a473f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor expression kind.  <a href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473f">More...</a><br /></td></tr>
<tr class="separator:a1ab3a6a8f6871198b20d1e93409a473f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ede6e23dd46be42eac24e06b29b2a2"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#af7ede6e23dd46be42eac24e06b29b2a2">EmitCInterface</a> : bool { <a class="el" href="namespacemlir_1_1sparse__tensor.html#af7ede6e23dd46be42eac24e06b29b2a2ad15305d7a4e34e02489c74a5ef542f36">Off</a> = false
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#af7ede6e23dd46be42eac24e06b29b2a2a521c36a31c2762741cf0f8890cbe05e3">On</a> = true
 }</td></tr>
<tr class="memdesc:af7ede6e23dd46be42eac24e06b29b2a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand aliases for the <code>emitCInterface</code> argument to <code><a class="el" href="namespacemlir_1_1sparse__tensor.html#a058ca7dd4f94a17037092388673ba6b4" title="Returns a function reference (first hit also inserts into module).">getFunc()</a></code>, <code><a class="el" href="namespacemlir_1_1sparse__tensor.html#aceb551c7fe08d4e0f1d6ac0cec343785" title="Creates a CallOp to the function reference returned by getFunc() in the builder&#39;s module.">createFuncCall()</a></code>, and <code>replaceOpWithFuncCall()</code>.  <a href="namespacemlir_1_1sparse__tensor.html#af7ede6e23dd46be42eac24e06b29b2a2">More...</a><br /></td></tr>
<tr class="separator:af7ede6e23dd46be42eac24e06b29b2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acc4b831ac079c00b1124139b41316daa"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#acc4b831ac079c00b1124139b41316daa">isFloatingPrimaryType</a> (<a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904ab">PrimaryType</a> valTy)</td></tr>
<tr class="separator:acc4b831ac079c00b1124139b41316daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f67eed0d8c6d3445a01e5d7cbf9068"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a50f67eed0d8c6d3445a01e5d7cbf9068">isIntegralPrimaryType</a> (<a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904ab">PrimaryType</a> valTy)</td></tr>
<tr class="separator:a50f67eed0d8c6d3445a01e5d7cbf9068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88824d5d3c576623954852dba07e8c1b"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a88824d5d3c576623954852dba07e8c1b">isRealPrimaryType</a> (<a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904ab">PrimaryType</a> valTy)</td></tr>
<tr class="separator:a88824d5d3c576623954852dba07e8c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaffa80c421bd3e4c5953057725e54d7e"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#aaffa80c421bd3e4c5953057725e54d7e">isComplexPrimaryType</a> (<a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904ab">PrimaryType</a> valTy)</td></tr>
<tr class="separator:aaffa80c421bd3e4c5953057725e54d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35657d6b2ffc036a0c4a5b2e598d78e4"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a35657d6b2ffc036a0c4a5b2e598d78e4">isValidDLT</a> (<a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a> dlt)</td></tr>
<tr class="memdesc:a35657d6b2ffc036a0c4a5b2e598d78e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the <code>DimLevelType</code> contains a valid (possibly undefined) value.  <a href="namespacemlir_1_1sparse__tensor.html#a35657d6b2ffc036a0c4a5b2e598d78e4">More...</a><br /></td></tr>
<tr class="separator:a35657d6b2ffc036a0c4a5b2e598d78e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758b2c5a8ac259342564d782aa92468f"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a758b2c5a8ac259342564d782aa92468f">isUndefDLT</a> (<a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a> dlt)</td></tr>
<tr class="memdesc:a758b2c5a8ac259342564d782aa92468f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the <code>DimLevelType</code> is the special undefined value.  <a href="namespacemlir_1_1sparse__tensor.html#a758b2c5a8ac259342564d782aa92468f">More...</a><br /></td></tr>
<tr class="separator:a758b2c5a8ac259342564d782aa92468f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53da6b21ba86f146f692f68f8aebd179"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a53da6b21ba86f146f692f68f8aebd179">isDenseDLT</a> (<a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a> dlt)</td></tr>
<tr class="memdesc:a53da6b21ba86f146f692f68f8aebd179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the <code>DimLevelType</code> is dense.  <a href="namespacemlir_1_1sparse__tensor.html#a53da6b21ba86f146f692f68f8aebd179">More...</a><br /></td></tr>
<tr class="separator:a53da6b21ba86f146f692f68f8aebd179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55329be9bb21947094bd053a2b6f4ce"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ac55329be9bb21947094bd053a2b6f4ce">isCompressedDLT</a> (<a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a> dlt)</td></tr>
<tr class="memdesc:ac55329be9bb21947094bd053a2b6f4ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the <code>DimLevelType</code> is compressed (regardless of properties).  <a href="namespacemlir_1_1sparse__tensor.html#ac55329be9bb21947094bd053a2b6f4ce">More...</a><br /></td></tr>
<tr class="separator:ac55329be9bb21947094bd053a2b6f4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385e5085ee3fe65734e12c584da4b0e3"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a385e5085ee3fe65734e12c584da4b0e3">isSingletonDLT</a> (<a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a> dlt)</td></tr>
<tr class="memdesc:a385e5085ee3fe65734e12c584da4b0e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the <code>DimLevelType</code> is singleton (regardless of properties).  <a href="namespacemlir_1_1sparse__tensor.html#a385e5085ee3fe65734e12c584da4b0e3">More...</a><br /></td></tr>
<tr class="separator:a385e5085ee3fe65734e12c584da4b0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c34ecc544ddda5c59e20acff90a0f6"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#af7c34ecc544ddda5c59e20acff90a0f6">isOrderedDLT</a> (<a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a> dlt)</td></tr>
<tr class="memdesc:af7c34ecc544ddda5c59e20acff90a0f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the <code>DimLevelType</code> is ordered (regardless of storage format).  <a href="namespacemlir_1_1sparse__tensor.html#af7c34ecc544ddda5c59e20acff90a0f6">More...</a><br /></td></tr>
<tr class="separator:af7c34ecc544ddda5c59e20acff90a0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e088056a0b56f5542c0fb2c0ece84b7"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a3e088056a0b56f5542c0fb2c0ece84b7">isUniqueDLT</a> (<a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a> dlt)</td></tr>
<tr class="memdesc:a3e088056a0b56f5542c0fb2c0ece84b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the <code>DimLevelType</code> is unique (regardless of storage format).  <a href="namespacemlir_1_1sparse__tensor.html#a3e088056a0b56f5542c0fb2c0ece84b7">More...</a><br /></td></tr>
<tr class="separator:a3e088056a0b56f5542c0fb2c0ece84b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cf107e240044ac0fbeb952ea3ae0f0"><td class="memItemLeft" align="right" valign="top">SparseTensorEncodingAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a90cf107e240044ac0fbeb952ea3ae0f0">getSparseTensorEncoding</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="memdesc:a90cf107e240044ac0fbeb952ea3ae0f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method to get a sparse encoding attribute from a type.  <a href="namespacemlir_1_1sparse__tensor.html#a90cf107e240044ac0fbeb952ea3ae0f0">More...</a><br /></td></tr>
<tr class="separator:a90cf107e240044ac0fbeb952ea3ae0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4bf0e37a029bc47aec78e748e3d720"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#add4bf0e37a029bc47aec78e748e3d720">isUniqueCOOType</a> (RankedTensorType tp)</td></tr>
<tr class="memdesc:add4bf0e37a029bc47aec78e748e3d720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the given type is a type for a COO tensor with the last dimension level type being unique.  <a href="namespacemlir_1_1sparse__tensor.html#add4bf0e37a029bc47aec78e748e3d720">More...</a><br /></td></tr>
<tr class="separator:add4bf0e37a029bc47aec78e748e3d720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19e75a0d0fefd242c0b11a78e4e9aff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ab19e75a0d0fefd242c0b11a78e4e9aff">getDimLevelType</a> (const SparseTensorEncodingAttr &amp;enc, uint64_t d)</td></tr>
<tr class="separator:ab19e75a0d0fefd242c0b11a78e4e9aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fcdd432ac6e307fe16e7313c1e7bef0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a6fcdd432ac6e307fe16e7313c1e7bef0">getDimLevelType</a> (RankedTensorType type, uint64_t d)</td></tr>
<tr class="separator:a6fcdd432ac6e307fe16e7313c1e7bef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ede73c7e40d63418b061d43915fa2ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a6ede73c7e40d63418b061d43915fa2ad">isDenseDim</a> (RankedTensorType type, uint64_t d)</td></tr>
<tr class="memdesc:a6ede73c7e40d63418b061d43915fa2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to test for dense dimension (0 &lt;= d &lt; rank).  <a href="namespacemlir_1_1sparse__tensor.html#a6ede73c7e40d63418b061d43915fa2ad">More...</a><br /></td></tr>
<tr class="separator:a6ede73c7e40d63418b061d43915fa2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fd46b792d78d65a5cc6e9c32de45c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a41fd46b792d78d65a5cc6e9c32de45c9">isCompressedDim</a> (RankedTensorType type, uint64_t d)</td></tr>
<tr class="memdesc:a41fd46b792d78d65a5cc6e9c32de45c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to test for compressed dimension (0 &lt;= d &lt; rank).  <a href="namespacemlir_1_1sparse__tensor.html#a41fd46b792d78d65a5cc6e9c32de45c9">More...</a><br /></td></tr>
<tr class="separator:a41fd46b792d78d65a5cc6e9c32de45c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ed2d091f69fe257113c8e33ea3965f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ae7ed2d091f69fe257113c8e33ea3965f">isSingletonDim</a> (RankedTensorType type, uint64_t d)</td></tr>
<tr class="memdesc:ae7ed2d091f69fe257113c8e33ea3965f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to test for singleton dimension (0 &lt;= d &lt; rank).  <a href="namespacemlir_1_1sparse__tensor.html#ae7ed2d091f69fe257113c8e33ea3965f">More...</a><br /></td></tr>
<tr class="separator:ae7ed2d091f69fe257113c8e33ea3965f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099004ece60c014439943a65128c6a53"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a099004ece60c014439943a65128c6a53">isOrderedDim</a> (RankedTensorType type, uint64_t d)</td></tr>
<tr class="memdesc:a099004ece60c014439943a65128c6a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to test for ordered property in the given dimension (0 &lt;= d &lt; rank).  <a href="namespacemlir_1_1sparse__tensor.html#a099004ece60c014439943a65128c6a53">More...</a><br /></td></tr>
<tr class="separator:a099004ece60c014439943a65128c6a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f63a6540c3dc161f78a48b28d4cfb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a60f63a6540c3dc161f78a48b28d4cfb6">isUniqueDim</a> (RankedTensorType type, uint64_t d)</td></tr>
<tr class="memdesc:a60f63a6540c3dc161f78a48b28d4cfb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to test for unique property in the given dimension (0 &lt;= d &lt; rank).  <a href="namespacemlir_1_1sparse__tensor.html#a60f63a6540c3dc161f78a48b28d4cfb6">More...</a><br /></td></tr>
<tr class="separator:a60f63a6540c3dc161f78a48b28d4cfb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcfdd4dbf441be82f8f9e041389befad"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#afcfdd4dbf441be82f8f9e041389befad">toOrigDim</a> (const SparseTensorEncodingAttr &amp;enc, uint64_t d)</td></tr>
<tr class="separator:afcfdd4dbf441be82f8f9e041389befad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c28abb51adf08fbddf9438bb065b9f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a44c28abb51adf08fbddf9438bb065b9f">toStoredDim</a> (const SparseTensorEncodingAttr &amp;enc, uint64_t d)</td></tr>
<tr class="separator:a44c28abb51adf08fbddf9438bb065b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b360a25d718e3192af7b9b6b127265"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a94b360a25d718e3192af7b9b6b127265">toOrigDim</a> (RankedTensorType type, uint64_t d)</td></tr>
<tr class="memdesc:a94b360a25d718e3192af7b9b6b127265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method to translate the given stored dimension to the original dimension (0 &lt;= d &lt; rank).  <a href="namespacemlir_1_1sparse__tensor.html#a94b360a25d718e3192af7b9b6b127265">More...</a><br /></td></tr>
<tr class="separator:a94b360a25d718e3192af7b9b6b127265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8026875808e383149220916e5ec95a3"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ae8026875808e383149220916e5ec95a3">toStoredDim</a> (RankedTensorType type, uint64_t d)</td></tr>
<tr class="memdesc:ae8026875808e383149220916e5ec95a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method to translate the given original dimension to the stored dimension (0 &lt;= d &lt; rank).  <a href="namespacemlir_1_1sparse__tensor.html#ae8026875808e383149220916e5ec95a3">More...</a><br /></td></tr>
<tr class="separator:ae8026875808e383149220916e5ec95a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace31d87d56cd565e14e7a81050eb5476"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ace31d87d56cd565e14e7a81050eb5476">buildSparseCompiler</a> (<a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;pm, const <a class="el" href="structmlir_1_1sparse__tensor_1_1SparseCompilerOptions.html">SparseCompilerOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:ace31d87d56cd565e14e7a81050eb5476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the "sparse-compiler" pipeline to the <code><a class="el" href="classmlir_1_1OpPassManager.html" title="This class represents a pass manager that runs passes on either a specific operation type,...">OpPassManager</a></code>.  <a href="namespacemlir_1_1sparse__tensor.html#ace31d87d56cd565e14e7a81050eb5476">More...</a><br /></td></tr>
<tr class="separator:ace31d87d56cd565e14e7a81050eb5476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4da76a5082524bd625e709b005d93d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#aa4da76a5082524bd625e709b005d93d7">registerSparseTensorPipelines</a> ()</td></tr>
<tr class="memdesc:aa4da76a5082524bd625e709b005d93d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers all pipelines for the <code><a class="el" href="namespacemlir_1_1sparse__tensor.html">sparse_tensor</a></code> dialect.  <a href="namespacemlir_1_1sparse__tensor.html#aa4da76a5082524bd625e709b005d93d7">More...</a><br /></td></tr>
<tr class="separator:aa4da76a5082524bd625e709b005d93d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ca39df6906707b01c4265328cd9679"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a06ca39df6906707b01c4265328cd9679">registerBufferizableOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a06ca39df6906707b01c4265328cd9679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5d36728b86ed186caf97cf89d6436f"><td class="memTemplParams" colspan="2">template&lt;typename P , typename I , typename V &gt; </td></tr>
<tr class="memitem:a7e5d36728b86ed186caf97cf89d6436f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html">SparseTensorStorage</a>&lt; P, I, V &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a7e5d36728b86ed186caf97cf89d6436f">openSparseTensor</a> (uint64_t dimRank, const uint64_t *dimShape, uint64_t lvlRank, const <a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a> *lvlTypes, const uint64_t *lvl2dim, const uint64_t *dim2lvl, const char *filename, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904ab">PrimaryType</a> valTp)</td></tr>
<tr class="memdesc:a7e5d36728b86ed186caf97cf89d6436f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a sparse tensor with the given filename into a memory-resident sparse tensor.  <a href="namespacemlir_1_1sparse__tensor.html#a7e5d36728b86ed186caf97cf89d6436f">More...</a><br /></td></tr>
<tr class="separator:a7e5d36728b86ed186caf97cf89d6436f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7594193c77060167b3c47d127f131194"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a7594193c77060167b3c47d127f131194"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a7594193c77060167b3c47d127f131194">writeExtFROSTT</a> (const <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorCOO.html">SparseTensorCOO</a>&lt; V &gt; &amp;coo, const char *filename)</td></tr>
<tr class="memdesc:a7594193c77060167b3c47d127f131194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the sparse tensor to <code>filename</code> in extended FROSTT format.  <a href="namespacemlir_1_1sparse__tensor.html#a7594193c77060167b3c47d127f131194">More...</a><br /></td></tr>
<tr class="separator:a7594193c77060167b3c47d127f131194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5913d5a1d9ef325b2c8c2a8b70843714"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60">OverheadType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a5913d5a1d9ef325b2c8c2a8b70843714">overheadTypeEncoding</a> (unsigned width)</td></tr>
<tr class="memdesc:a5913d5a1d9ef325b2c8c2a8b70843714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an overhead storage bitwidth to its internal type-encoding.  <a href="namespacemlir_1_1sparse__tensor.html#a5913d5a1d9ef325b2c8c2a8b70843714">More...</a><br /></td></tr>
<tr class="separator:a5913d5a1d9ef325b2c8c2a8b70843714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb02cd2b1f8b3829133f8e05456ece9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60">OverheadType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a9cb02cd2b1f8b3829133f8e05456ece9">overheadTypeEncoding</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> tp)</td></tr>
<tr class="memdesc:a9cb02cd2b1f8b3829133f8e05456ece9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an overhead storage type to its internal type-encoding.  <a href="namespacemlir_1_1sparse__tensor.html#a9cb02cd2b1f8b3829133f8e05456ece9">More...</a><br /></td></tr>
<tr class="separator:a9cb02cd2b1f8b3829133f8e05456ece9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f37309e9664d3b46e3ecac113e2fb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ae5f37309e9664d3b46e3ecac113e2fb1">getOverheadType</a> (<a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;builder, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60">OverheadType</a> ot)</td></tr>
<tr class="memdesc:ae5f37309e9664d3b46e3ecac113e2fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the internal type-encoding for overhead storage to an <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">mlir::Type</a>.  <a href="namespacemlir_1_1sparse__tensor.html#ae5f37309e9664d3b46e3ecac113e2fb1">More...</a><br /></td></tr>
<tr class="separator:ae5f37309e9664d3b46e3ecac113e2fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2dedb0a54f00537cf8ce6577617f311"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60">OverheadType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ac2dedb0a54f00537cf8ce6577617f311">pointerOverheadTypeEncoding</a> (const SparseTensorEncodingAttr &amp;enc)</td></tr>
<tr class="memdesc:ac2dedb0a54f00537cf8ce6577617f311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the OverheadType for pointer overhead storage.  <a href="namespacemlir_1_1sparse__tensor.html#ac2dedb0a54f00537cf8ce6577617f311">More...</a><br /></td></tr>
<tr class="separator:ac2dedb0a54f00537cf8ce6577617f311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5076532ad03d2dc7f8c6cbb4acc7900"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60">OverheadType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ad5076532ad03d2dc7f8c6cbb4acc7900">indexOverheadTypeEncoding</a> (const SparseTensorEncodingAttr &amp;enc)</td></tr>
<tr class="memdesc:ad5076532ad03d2dc7f8c6cbb4acc7900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the OverheadType for index overhead storage.  <a href="namespacemlir_1_1sparse__tensor.html#ad5076532ad03d2dc7f8c6cbb4acc7900">More...</a><br /></td></tr>
<tr class="separator:ad5076532ad03d2dc7f8c6cbb4acc7900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f52010819157c60b6dfd993b425ee4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a40f52010819157c60b6dfd993b425ee4">getPointerOverheadType</a> (<a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;builder, const SparseTensorEncodingAttr &amp;enc)</td></tr>
<tr class="memdesc:a40f52010819157c60b6dfd993b425ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">mlir::Type</a> for pointer overhead storage.  <a href="namespacemlir_1_1sparse__tensor.html#a40f52010819157c60b6dfd993b425ee4">More...</a><br /></td></tr>
<tr class="separator:a40f52010819157c60b6dfd993b425ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829bf299dd13613f7e6542d6846e01a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a829bf299dd13613f7e6542d6846e01a4">getIndexOverheadType</a> (<a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;builder, const SparseTensorEncodingAttr &amp;enc)</td></tr>
<tr class="memdesc:a829bf299dd13613f7e6542d6846e01a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">mlir::Type</a> for index overhead storage.  <a href="namespacemlir_1_1sparse__tensor.html#a829bf299dd13613f7e6542d6846e01a4">More...</a><br /></td></tr>
<tr class="separator:a829bf299dd13613f7e6542d6846e01a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68fb99cb0b7e9f6787952299a59609a7"><td class="memItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a68fb99cb0b7e9f6787952299a59609a7">overheadTypeFunctionSuffix</a> (<a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60">OverheadType</a> ot)</td></tr>
<tr class="memdesc:a68fb99cb0b7e9f6787952299a59609a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert OverheadType to its function-name suffix.  <a href="namespacemlir_1_1sparse__tensor.html#a68fb99cb0b7e9f6787952299a59609a7">More...</a><br /></td></tr>
<tr class="separator:a68fb99cb0b7e9f6787952299a59609a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afebb2dcb33c43b890cb719a500d22077"><td class="memItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#afebb2dcb33c43b890cb719a500d22077">overheadTypeFunctionSuffix</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> overheadTp)</td></tr>
<tr class="memdesc:afebb2dcb33c43b890cb719a500d22077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an overhead storage type to its function-name suffix.  <a href="namespacemlir_1_1sparse__tensor.html#afebb2dcb33c43b890cb719a500d22077">More...</a><br /></td></tr>
<tr class="separator:afebb2dcb33c43b890cb719a500d22077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d245959cdf73b056ffaefe11aee733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904ab">PrimaryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a79d245959cdf73b056ffaefe11aee733">primaryTypeEncoding</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> elemTp)</td></tr>
<tr class="memdesc:a79d245959cdf73b056ffaefe11aee733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a primary storage type to its internal type-encoding.  <a href="namespacemlir_1_1sparse__tensor.html#a79d245959cdf73b056ffaefe11aee733">More...</a><br /></td></tr>
<tr class="separator:a79d245959cdf73b056ffaefe11aee733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb262d6ac8ec2bb016263171b219d769"><td class="memItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#adb262d6ac8ec2bb016263171b219d769">primaryTypeFunctionSuffix</a> (<a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904ab">PrimaryType</a> pt)</td></tr>
<tr class="memdesc:adb262d6ac8ec2bb016263171b219d769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert PrimaryType to its function-name suffix.  <a href="namespacemlir_1_1sparse__tensor.html#adb262d6ac8ec2bb016263171b219d769">More...</a><br /></td></tr>
<tr class="separator:adb262d6ac8ec2bb016263171b219d769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d775351105b6d20ac0ec4712b14c4ab"><td class="memItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a1d775351105b6d20ac0ec4712b14c4ab">primaryTypeFunctionSuffix</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> elemTp)</td></tr>
<tr class="memdesc:a1d775351105b6d20ac0ec4712b14c4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a primary storage type to its function-name suffix.  <a href="namespacemlir_1_1sparse__tensor.html#a1d775351105b6d20ac0ec4712b14c4ab">More...</a><br /></td></tr>
<tr class="separator:a1d775351105b6d20ac0ec4712b14c4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040aa1c78bc3c44cd56447a1c43fdba8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a040aa1c78bc3c44cd56447a1c43fdba8">getOneAttr</a> (<a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;builder, <a class="el" href="classmlir_1_1Type.html">Type</a> tp)</td></tr>
<tr class="memdesc:a040aa1c78bc3c44cd56447a1c43fdba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a 1-valued attribute of the given type.  <a href="namespacemlir_1_1sparse__tensor.html#a040aa1c78bc3c44cd56447a1c43fdba8">More...</a><br /></td></tr>
<tr class="separator:a040aa1c78bc3c44cd56447a1c43fdba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e5fa1625ec77aeb54ef34e01f02019"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a95e5fa1625ec77aeb54ef34e01f02019">genIsNonzero</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> v)</td></tr>
<tr class="memdesc:a95e5fa1625ec77aeb54ef34e01f02019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the comparison <code>v != 0</code> where <code>v</code> is of numeric type.  <a href="namespacemlir_1_1sparse__tensor.html#a95e5fa1625ec77aeb54ef34e01f02019">More...</a><br /></td></tr>
<tr class="separator:a95e5fa1625ec77aeb54ef34e01f02019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd93e7b9fd12439226f7d344892a23e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#adbd93e7b9fd12439226f7d344892a23e">genReshapeDstShape</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;dstShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; srcShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; staticDstShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; reassociation)</td></tr>
<tr class="memdesc:adbd93e7b9fd12439226f7d344892a23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the shape of destination tensor of a reshape operator.  <a href="namespacemlir_1_1sparse__tensor.html#adbd93e7b9fd12439226f7d344892a23e">More...</a><br /></td></tr>
<tr class="separator:adbd93e7b9fd12439226f7d344892a23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05178ffe7b3e43fbafdc8a7ad544f98f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a05178ffe7b3e43fbafdc8a7ad544f98f">translateIndicesArray</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; reassociation, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> srcIndices, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; srcShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; dstShape, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;dstIndices)</td></tr>
<tr class="memdesc:a05178ffe7b3e43fbafdc8a7ad544f98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate indices during a reshaping operation.  <a href="namespacemlir_1_1sparse__tensor.html#a05178ffe7b3e43fbafdc8a7ad544f98f">More...</a><br /></td></tr>
<tr class="separator:a05178ffe7b3e43fbafdc8a7ad544f98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058ca7dd4f94a17037092388673ba6b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FlatSymbolRefAttr.html">FlatSymbolRefAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a058ca7dd4f94a17037092388673ba6b4">getFunc</a> (ModuleOp module, StringRef name, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> resultType, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands, <a class="el" href="namespacemlir_1_1sparse__tensor.html#af7ede6e23dd46be42eac24e06b29b2a2">EmitCInterface</a> emitCInterface)</td></tr>
<tr class="memdesc:a058ca7dd4f94a17037092388673ba6b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a function reference (first hit also inserts into module).  <a href="namespacemlir_1_1sparse__tensor.html#a058ca7dd4f94a17037092388673ba6b4">More...</a><br /></td></tr>
<tr class="separator:a058ca7dd4f94a17037092388673ba6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb551c7fe08d4e0f1d6ac0cec343785"><td class="memItemLeft" align="right" valign="top">func::CallOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#aceb551c7fe08d4e0f1d6ac0cec343785">createFuncCall</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, StringRef name, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> resultType, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands, <a class="el" href="namespacemlir_1_1sparse__tensor.html#af7ede6e23dd46be42eac24e06b29b2a2">EmitCInterface</a> emitCInterface)</td></tr>
<tr class="memdesc:aceb551c7fe08d4e0f1d6ac0cec343785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code>CallOp</code> to the function reference returned by <code><a class="el" href="namespacemlir_1_1sparse__tensor.html#a058ca7dd4f94a17037092388673ba6b4" title="Returns a function reference (first hit also inserts into module).">getFunc()</a></code> in the builder's module.  <a href="namespacemlir_1_1sparse__tensor.html#aceb551c7fe08d4e0f1d6ac0cec343785">More...</a><br /></td></tr>
<tr class="separator:aceb551c7fe08d4e0f1d6ac0cec343785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1bee8cae4c2533f4a3d8d9d019e988"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a9c1bee8cae4c2533f4a3d8d9d019e988">getOpaquePointerType</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="memdesc:a9c1bee8cae4c2533f4a3d8d9d019e988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the equivalent of <code>void*</code> for opaque arguments to the execution engine.  <a href="namespacemlir_1_1sparse__tensor.html#a9c1bee8cae4c2533f4a3d8d9d019e988">More...</a><br /></td></tr>
<tr class="separator:a9c1bee8cae4c2533f4a3d8d9d019e988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45d3869f353db49776cf0b9dc4df1e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ab45d3869f353db49776cf0b9dc4df1e4">genAlloca</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> sz, <a class="el" href="classmlir_1_1Type.html">Type</a> tp)</td></tr>
<tr class="memdesc:ab45d3869f353db49776cf0b9dc4df1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an uninitialized temporary buffer of the given size and type, but returns it as type <code>memref&lt;? x $tp&gt;</code> (rather than as type <code>memref&lt;$sz x $tp&gt;</code>).  <a href="namespacemlir_1_1sparse__tensor.html#ab45d3869f353db49776cf0b9dc4df1e4">More...</a><br /></td></tr>
<tr class="separator:ab45d3869f353db49776cf0b9dc4df1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead03953e707ee79cc4758660b4a3270"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#aead03953e707ee79cc4758660b4a3270">genAlloca</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, unsigned sz, <a class="el" href="classmlir_1_1Type.html">Type</a> tp)</td></tr>
<tr class="memdesc:aead03953e707ee79cc4758660b4a3270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an uninitialized temporary buffer of the given size and type, but returns it as type <code>memref&lt;? x $tp&gt;</code> (rather than as type <code>memref&lt;$sz x $tp&gt;</code>).  <a href="namespacemlir_1_1sparse__tensor.html#aead03953e707ee79cc4758660b4a3270">More...</a><br /></td></tr>
<tr class="separator:aead03953e707ee79cc4758660b4a3270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e0fa74abcc8be1da4aa0790f20f9bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a07e0fa74abcc8be1da4aa0790f20f9bc">genAllocaScalar</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Type.html">Type</a> tp)</td></tr>
<tr class="memdesc:a07e0fa74abcc8be1da4aa0790f20f9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an uninitialized temporary buffer with room for one value of the given type, and returns the <code>memref&lt;$tp&gt;</code>.  <a href="namespacemlir_1_1sparse__tensor.html#a07e0fa74abcc8be1da4aa0790f20f9bc">More...</a><br /></td></tr>
<tr class="separator:a07e0fa74abcc8be1da4aa0790f20f9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af809e07ab59de56afba2b40b3fe317a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#af809e07ab59de56afba2b40b3fe317a8">allocDenseTensor</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, RankedTensorType tensorTp, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> sizes)</td></tr>
<tr class="memdesc:af809e07ab59de56afba2b40b3fe317a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates code to allocate a buffer of the given type, and zero initialize it.  <a href="namespacemlir_1_1sparse__tensor.html#af809e07ab59de56afba2b40b3fe317a8">More...</a><br /></td></tr>
<tr class="separator:af809e07ab59de56afba2b40b3fe317a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6d589527be4ee54cb4452354afe6f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#aaf6d589527be4ee54cb4452354afe6f9">deallocDenseTensor</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> buffer)</td></tr>
<tr class="memdesc:aaf6d589527be4ee54cb4452354afe6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates code to deallocate a dense buffer.  <a href="namespacemlir_1_1sparse__tensor.html#aaf6d589527be4ee54cb4452354afe6f9">More...</a><br /></td></tr>
<tr class="separator:aaf6d589527be4ee54cb4452354afe6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8bbe5cf94f1a5fde6da83eb1604c81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a4c8bbe5cf94f1a5fde6da83eb1604c81">genValueForDense</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> tensor, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ivs)</td></tr>
<tr class="memdesc:a4c8bbe5cf94f1a5fde6da83eb1604c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the code to read the value from tensor[ivs].  <a href="namespacemlir_1_1sparse__tensor.html#a4c8bbe5cf94f1a5fde6da83eb1604c81">More...</a><br /></td></tr>
<tr class="separator:a4c8bbe5cf94f1a5fde6da83eb1604c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c3a25f128140fcfb2356b9d58ac58c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a82c3a25f128140fcfb2356b9d58ac58c">genDenseTensorOrSparseConstantIterLoop</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> src, unsigned rank, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilder)</td></tr>
<tr class="memdesc:a82c3a25f128140fcfb2356b9d58ac58c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the loop structure to iterate over a dense tensor or a sparse tensor constant to support the lowering of dense-to-sparse convert operator.  <a href="namespacemlir_1_1sparse__tensor.html#a82c3a25f128140fcfb2356b9d58ac58c">More...</a><br /></td></tr>
<tr class="separator:a82c3a25f128140fcfb2356b9d58ac58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5700bf1db7b95b281f7c320acd94d06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ae5700bf1db7b95b281f7c320acd94d06">sizesFromSrc</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;sizes, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> src)</td></tr>
<tr class="memdesc:ae5700bf1db7b95b281f7c320acd94d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates given sizes array from dense tensor or sparse tensor constant.  <a href="namespacemlir_1_1sparse__tensor.html#ae5700bf1db7b95b281f7c320acd94d06">More...</a><br /></td></tr>
<tr class="separator:ae5700bf1db7b95b281f7c320acd94d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82016f51c5f51422120acc4ac5143d91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a82016f51c5f51422120acc4ac5143d91">getTop</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a82016f51c5f51422120acc4ac5143d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans to top of generated loop.  <a href="namespacemlir_1_1sparse__tensor.html#a82016f51c5f51422120acc4ac5143d91">More...</a><br /></td></tr>
<tr class="separator:a82016f51c5f51422120acc4ac5143d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ccea01103720ec989b8bf527f3ba07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ac8ccea01103720ec989b8bf527f3ba07">foreachInSparseConstant</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, SparseElementsAttr attr, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt; callback)</td></tr>
<tr class="memdesc:ac8ccea01103720ec989b8bf527f3ba07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over a sparse constant, generates constantOp for value and indices.  <a href="namespacemlir_1_1sparse__tensor.html#ac8ccea01103720ec989b8bf527f3ba07">More...</a><br /></td></tr>
<tr class="separator:ac8ccea01103720ec989b8bf527f3ba07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc22f44748f0f59b4a61893c5d144e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a0fc22f44748f0f59b4a61893c5d144e9">constantZero</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Type.html">Type</a> tp)</td></tr>
<tr class="memdesc:a0fc22f44748f0f59b4a61893c5d144e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a 0-valued constant of the given type.  <a href="namespacemlir_1_1sparse__tensor.html#a0fc22f44748f0f59b4a61893c5d144e9">More...</a><br /></td></tr>
<tr class="separator:a0fc22f44748f0f59b4a61893c5d144e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31882503d2770c14e8fc599f3540c364"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a31882503d2770c14e8fc599f3540c364">constantOne</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Type.html">Type</a> tp)</td></tr>
<tr class="memdesc:a31882503d2770c14e8fc599f3540c364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a 1-valued constant of the given type.  <a href="namespacemlir_1_1sparse__tensor.html#a31882503d2770c14e8fc599f3540c364">More...</a><br /></td></tr>
<tr class="separator:a31882503d2770c14e8fc599f3540c364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0afca7b5c11b6824d49d422a154323d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a0afca7b5c11b6824d49d422a154323d7">constantIndex</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, int64_t i)</td></tr>
<tr class="memdesc:a0afca7b5c11b6824d49d422a154323d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a constant of <code>index</code> type.  <a href="namespacemlir_1_1sparse__tensor.html#a0afca7b5c11b6824d49d422a154323d7">More...</a><br /></td></tr>
<tr class="separator:a0afca7b5c11b6824d49d422a154323d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24cf7c247f3ed10a02ecb5c4884a3c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ae24cf7c247f3ed10a02ecb5c4884a3c1">constantI32</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, int32_t i)</td></tr>
<tr class="memdesc:ae24cf7c247f3ed10a02ecb5c4884a3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a constant of <code>i32</code> type.  <a href="namespacemlir_1_1sparse__tensor.html#ae24cf7c247f3ed10a02ecb5c4884a3c1">More...</a><br /></td></tr>
<tr class="separator:ae24cf7c247f3ed10a02ecb5c4884a3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f31d19a3deeff30f1ffdf9da90b1e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ac9f31d19a3deeff30f1ffdf9da90b1e4">constantI16</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, int16_t i)</td></tr>
<tr class="memdesc:ac9f31d19a3deeff30f1ffdf9da90b1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a constant of <code>i16</code> type.  <a href="namespacemlir_1_1sparse__tensor.html#ac9f31d19a3deeff30f1ffdf9da90b1e4">More...</a><br /></td></tr>
<tr class="separator:ac9f31d19a3deeff30f1ffdf9da90b1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e94d104c16a3cba747e3da258e0d5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a32e94d104c16a3cba747e3da258e0d5d">constantI8</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, int8_t i)</td></tr>
<tr class="memdesc:a32e94d104c16a3cba747e3da258e0d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a constant of <code>i8</code> type.  <a href="namespacemlir_1_1sparse__tensor.html#a32e94d104c16a3cba747e3da258e0d5d">More...</a><br /></td></tr>
<tr class="separator:a32e94d104c16a3cba747e3da258e0d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f64fbd97b3789823a56e49a293e1e6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a5f64fbd97b3789823a56e49a293e1e6e">constantI1</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, bool b)</td></tr>
<tr class="memdesc:a5f64fbd97b3789823a56e49a293e1e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a constant of <code>i1</code> type.  <a href="namespacemlir_1_1sparse__tensor.html#a5f64fbd97b3789823a56e49a293e1e6e">More...</a><br /></td></tr>
<tr class="separator:a5f64fbd97b3789823a56e49a293e1e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f7e5d153806f1c9506e6c4b38e8507"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a63f7e5d153806f1c9506e6c4b38e8507">constantAction</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a381f27e8f48be9793332d997f81ebecb">Action</a> action)</td></tr>
<tr class="memdesc:a63f7e5d153806f1c9506e6c4b38e8507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a constant of the given <code>Action</code>.  <a href="namespacemlir_1_1sparse__tensor.html#a63f7e5d153806f1c9506e6c4b38e8507">More...</a><br /></td></tr>
<tr class="separator:a63f7e5d153806f1c9506e6c4b38e8507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f6c538a7e434c02147d7d95a0ceb34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ab8f6c538a7e434c02147d7d95a0ceb34">constantOverheadTypeEncoding</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, unsigned width)</td></tr>
<tr class="memdesc:ab8f6c538a7e434c02147d7d95a0ceb34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a constant of the internal type-encoding for overhead storage.  <a href="namespacemlir_1_1sparse__tensor.html#ab8f6c538a7e434c02147d7d95a0ceb34">More...</a><br /></td></tr>
<tr class="separator:ab8f6c538a7e434c02147d7d95a0ceb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9728e9a26cdd35a8c1d00a462734d3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ac9728e9a26cdd35a8c1d00a462734d3e">constantPointerTypeEncoding</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, const SparseTensorEncodingAttr &amp;enc)</td></tr>
<tr class="memdesc:ac9728e9a26cdd35a8c1d00a462734d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a constant of the internal type-encoding for pointer overhead storage.  <a href="namespacemlir_1_1sparse__tensor.html#ac9728e9a26cdd35a8c1d00a462734d3e">More...</a><br /></td></tr>
<tr class="separator:ac9728e9a26cdd35a8c1d00a462734d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0544f3c9956472a3f18d7f02c3e62aa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a0544f3c9956472a3f18d7f02c3e62aa2">constantIndexTypeEncoding</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, const SparseTensorEncodingAttr &amp;enc)</td></tr>
<tr class="memdesc:a0544f3c9956472a3f18d7f02c3e62aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a constant of the internal type-encoding for index overhead storage.  <a href="namespacemlir_1_1sparse__tensor.html#a0544f3c9956472a3f18d7f02c3e62aa2">More...</a><br /></td></tr>
<tr class="separator:a0544f3c9956472a3f18d7f02c3e62aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41c3450aa0396748a11b1ce7a4fa8e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ae41c3450aa0396748a11b1ce7a4fa8e3">constantPrimaryTypeEncoding</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Type.html">Type</a> elemTp)</td></tr>
<tr class="memdesc:ae41c3450aa0396748a11b1ce7a4fa8e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a constant of the internal type-encoding for primary storage.  <a href="namespacemlir_1_1sparse__tensor.html#ae41c3450aa0396748a11b1ce7a4fa8e3">More...</a><br /></td></tr>
<tr class="separator:ae41c3450aa0396748a11b1ce7a4fa8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e504928338ed504e51d671e2520127"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#af6e504928338ed504e51d671e2520127">constantDimLevelTypeEncoding</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a> dlt)</td></tr>
<tr class="memdesc:af6e504928338ed504e51d671e2520127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a constant of the internal dimension level type encoding.  <a href="namespacemlir_1_1sparse__tensor.html#af6e504928338ed504e51d671e2520127">More...</a><br /></td></tr>
<tr class="separator:af6e504928338ed504e51d671e2520127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9cfbb689a6cf4c8f4cfdf898cb890d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#aa9cfbb689a6cf4c8f4cfdf898cb890d1">isZeroRankedTensorOrScalar</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="separator:aa9cfbb689a6cf4c8f4cfdf898cb890d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e910b3b9ffdd5d21eb4451787991c8f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a8e910b3b9ffdd5d21eb4451787991c8f">containsSparseTensor</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types)</td></tr>
<tr class="memdesc:a8e910b3b9ffdd5d21eb4451787991c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if one of the given types is a sparse tensor type.  <a href="namespacemlir_1_1sparse__tensor.html#a8e910b3b9ffdd5d21eb4451787991c8f">More...</a><br /></td></tr>
<tr class="separator:a8e910b3b9ffdd5d21eb4451787991c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96ea63ce869d935187f89d784ec278a"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ac96ea63ce869d935187f89d784ec278a">kindToOpSymbol</a> (<a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473f">Kind</a> kind)</td></tr>
<tr class="separator:ac96ea63ce869d935187f89d784ec278a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09520b912c648fa708982dabd05dcbb9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a09520b912c648fa708982dabd05dcbb9">isAdmissibleBranchExp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classmlir_1_1Value.html">Value</a> v)</td></tr>
<tr class="memdesc:a09520b912c648fa708982dabd05dcbb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that sparse compiler can generate code for expression.  <a href="namespacemlir_1_1sparse__tensor.html#a09520b912c648fa708982dabd05dcbb9">More...</a><br /></td></tr>
<tr class="separator:a09520b912c648fa708982dabd05dcbb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59660eda97580c1b4ece30883fb7dd22"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a59660eda97580c1b4ece30883fb7dd22">isAdmissibleBranch</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region)</td></tr>
<tr class="memdesc:a59660eda97580c1b4ece30883fb7dd22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that sparse compiler can generate code for branch.  <a href="namespacemlir_1_1sparse__tensor.html#a59660eda97580c1b4ece30883fb7dd22">More...</a><br /></td></tr>
<tr class="separator:a59660eda97580c1b4ece30883fb7dd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244b410c7a4d3b7a7be2d2e78fe41d85"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a244b410c7a4d3b7a7be2d2e78fe41d85">insertYieldOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> vals)</td></tr>
<tr class="separator:a244b410c7a4d3b7a7be2d2e78fe41d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430168327a6b66763c6c1427541591f6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a430168327a6b66763c6c1427541591f6">buildUnaryPresent</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Value.html">Value</a> v0)</td></tr>
<tr class="separator:a430168327a6b66763c6c1427541591f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f243601897f46d07d7241bca9bc491"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a54f243601897f46d07d7241bca9bc491">buildBinaryOverlap</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Value.html">Value</a> v0, <a class="el" href="classmlir_1_1Value.html">Value</a> v1)</td></tr>
<tr class="separator:a54f243601897f46d07d7241bca9bc491"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a6d22ed3f513f0693e476e464aad74007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d22ed3f513f0693e476e464aad74007">&#9670;&nbsp;</a></span>complex32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1sparse__tensor.html#a6d22ed3f513f0693e476e464aad74007">mlir::sparse_tensor::complex32</a> = typedef std::complex&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Enums_8h_source.html#l00077">77</a> of file <a class="el" href="Enums_8h_source.html">Enums.h</a>.</p>

</div>
</div>
<a id="a00af5771ba3ad826897458cda0b6fbde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00af5771ba3ad826897458cda0b6fbde">&#9670;&nbsp;</a></span>complex64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1sparse__tensor.html#a00af5771ba3ad826897458cda0b6fbde">mlir::sparse_tensor::complex64</a> = typedef std::complex&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Enums_8h_source.html#l00076">76</a> of file <a class="el" href="Enums_8h_source.html">Enums.h</a>.</p>

</div>
</div>
<a id="a399fe87fe98fac2976f2d4a5222d24b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399fe87fe98fac2976f2d4a5222d24b1">&#9670;&nbsp;</a></span>ElementConsumer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1sparse__tensor.html#a399fe87fe98fac2976f2d4a5222d24b1">mlir::sparse_tensor::ElementConsumer</a> = typedef const std::function&lt;void(const std::vector&lt;uint64_t&gt; &amp;, V)&gt; &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of callback functions which receive an element. </p>
<p>We avoid packaging the coordinates and value together as an <code><a class="el" href="structmlir_1_1sparse__tensor_1_1Element.html" title="An element of a sparse tensor in coordinate-scheme representation (i.e., a pair of indices and value)...">Element</a></code> object because this helps keep code somewhat cleaner. </p>

<p class="definition">Definition at line <a class="el" href="COO_8h_source.html#l00075">75</a> of file <a class="el" href="COO_8h_source.html">COO.h</a>.</p>

</div>
</div>
<a id="a9ae79c9f12ec66ff6b11cbd106730028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae79c9f12ec66ff6b11cbd106730028">&#9670;&nbsp;</a></span>index_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1sparse__tensor.html#a9ae79c9f12ec66ff6b11cbd106730028">mlir::sparse_tensor::index_type</a> = typedef uint64_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This type is used in the public API at all places where MLIR expects values with the built-in type "index". </p>
<p>For now, we simply assume that type is 64-bit, but targets with different "index" bit widths should link with an alternatively built runtime support library. </p>

<p class="definition">Definition at line <a class="el" href="Enums_8h_source.html#l00045">45</a> of file <a class="el" href="Enums_8h_source.html">Enums.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a381f27e8f48be9793332d997f81ebecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381f27e8f48be9793332d997f81ebecb">&#9670;&nbsp;</a></span>Action</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1sparse__tensor.html#a381f27e8f48be9793332d997f81ebecb">mlir::sparse_tensor::Action</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The actions performed by @newSparseTensor. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a381f27e8f48be9793332d997f81ebecba65d0c57fb98927f91459ad92c864def8"></a>kEmpty&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a381f27e8f48be9793332d997f81ebecba448114fe5d01bb8b9762d455823218cb"></a>kFromFile&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a381f27e8f48be9793332d997f81ebecba1d496f347acad67edc9d6dac4a59a61c"></a>kFromCOO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a381f27e8f48be9793332d997f81ebecba316dceb03f204e8cfa616cfc497f107e"></a>kSparseToSparse&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a381f27e8f48be9793332d997f81ebecbae5795f0f2d65cc34484b9d1ee5560355"></a>kEmptyCOO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a381f27e8f48be9793332d997f81ebecbacb46e8dcc6f75ae21696ae715dd8915d"></a>kToCOO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a381f27e8f48be9793332d997f81ebecbac38414adc2b2d3b1e06a909f8a7b3b76"></a>kToIterator&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Enums_8h_source.html#l00123">123</a> of file <a class="el" href="Enums_8h_source.html">Enums.h</a>.</p>

</div>
</div>
<a id="aa09f02b16598f192895bfa41d8032a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09f02b16598f192895bfa41d8032a95">&#9670;&nbsp;</a></span>DimLevelType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">mlir::sparse_tensor::DimLevelType</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This enum defines all the sparse representations supportable by the SparseTensor dialect. </p>
<p>We use a lightweight encoding to encode both the "format" per se (dense, compressed, singleton) as well as the "properties" (ordered, unique). The encoding is chosen for performance of the runtime library, and thus may change in future versions; consequently, client code should use the predicate functions defined below, rather than relying on knowledge about the particular binary encoding.</p>
<p>The <code>Undef</code> "format" is a special value used internally for cases where we need to store an undefined or indeterminate <code>DimLevelType</code>. It should not be used externally, since it does not indicate an actual/representable format. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa09f02b16598f192895bfa41d8032a95a6bf5613f65a74a7f8388b26adefaef2b"></a>Undef&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa09f02b16598f192895bfa41d8032a95a9a71a13863c84ba34fc41595fc2ee0c6"></a>Dense&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa09f02b16598f192895bfa41d8032a95a4d602abc0c0f2f7c1a5156d964517e4e"></a>Compressed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa09f02b16598f192895bfa41d8032a95a562632a70ad5a0b18dc4f9906de54253"></a>CompressedNu&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa09f02b16598f192895bfa41d8032a95a8da13245daa135f56df9e0f92b5d22c5"></a>CompressedNo&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa09f02b16598f192895bfa41d8032a95a04fd51749f0663ff642b8450e7165121"></a>CompressedNuNo&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa09f02b16598f192895bfa41d8032a95a6ff5f73c8b5ebd311406568c8ef50bfd"></a>Singleton&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa09f02b16598f192895bfa41d8032a95adca8973f87378bd3149fb9a6eca586fa"></a>SingletonNu&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa09f02b16598f192895bfa41d8032a95a942ed5aa2dca9dfc250da72a338b1c71"></a>SingletonNo&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa09f02b16598f192895bfa41d8032a95a114102a8e33ed979a0da383c49b215ed"></a>SingletonNuNo&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Enums_8h_source.html#l00146">146</a> of file <a class="el" href="Enums_8h_source.html">Enums.h</a>.</p>

</div>
</div>
<a id="af7ede6e23dd46be42eac24e06b29b2a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ede6e23dd46be42eac24e06b29b2a2">&#9670;&nbsp;</a></span>EmitCInterface</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1sparse__tensor.html#af7ede6e23dd46be42eac24e06b29b2a2">mlir::sparse_tensor::EmitCInterface</a> : bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shorthand aliases for the <code>emitCInterface</code> argument to <code><a class="el" href="namespacemlir_1_1sparse__tensor.html#a058ca7dd4f94a17037092388673ba6b4" title="Returns a function reference (first hit also inserts into module).">getFunc()</a></code>, <code><a class="el" href="namespacemlir_1_1sparse__tensor.html#aceb551c7fe08d4e0f1d6ac0cec343785" title="Creates a CallOp to the function reference returned by getFunc() in the builder&#39;s module.">createFuncCall()</a></code>, and <code>replaceOpWithFuncCall()</code>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af7ede6e23dd46be42eac24e06b29b2a2ad15305d7a4e34e02489c74a5ef542f36"></a>Off&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af7ede6e23dd46be42eac24e06b29b2a2a521c36a31c2762741cf0f8890cbe05e3"></a>On&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8h_source.html#l00035">35</a> of file <a class="el" href="CodegenUtils_8h_source.html">CodegenUtils.h</a>.</p>

</div>
</div>
<a id="a1ab3a6a8f6871198b20d1e93409a473f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab3a6a8f6871198b20d1e93409a473f">&#9670;&nbsp;</a></span>Kind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473f">mlir::sparse_tensor::Kind</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tensor expression kind. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fab15d67d80801ec6c96d229847aa4507f"></a>kTensor&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa0dad027d1a3ae9e8b421e99443ec4506"></a>kInvariant&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa564bd6edb3f5dbe871faa2c145e36790"></a>kIndex&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473faaaa1335fda1c8d46b88c83f27e161967"></a>kIndex&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fae446424dcbca886a4232526e6865bc86"></a>kAbsF&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fad89785a0e047524d79f6dc6e33dc697f"></a>kAbsC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fae3ea4147268a5b11fd14808025e03121"></a>kAbsI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa32cfd22bc608b55cb3cc404f8a1be87a"></a>kCeilF&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa6c43e29963859385bd2d92c9023b7689"></a>kFloorF&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fab226f363eecae3747869314ebfab84fe"></a>kSqrtF&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fac40a698d21108f1c0b188990f25227b1"></a>kSqrtC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa1cd8718dbe0a0ffa20d9dfc62e51b992"></a>kExpm1F&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa9cfb6436f95a29c2faa1284fc5a6f473"></a>kExpm1C&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473faa82e599d247b111d7ec234e151bb074e"></a>kLog1pF&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fab99b42569b87e1f6a83114b5b4983c10"></a>kLog1pC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa1293be53c127fa36bfc58a9c793495ad"></a>kSinF&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fab4afeb2d7ae89f7262eed382affea889"></a>kSinC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473faebc711d47ff5be1c252504d9c9ae2331"></a>kTanhF&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa179bba8dde7ea15b09eba8b42012f140"></a>kTanhC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa26224c7d9c615460553d533be63b5826"></a>kNegF&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fad6d145601512af47bd1ddbca628dbb20"></a>kNegC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fac00e9da99623b62364783e7d610519ba"></a>kNegI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473faf90d34cb35c6883df080dd03054402d1"></a>kTruncF&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa622f146e3bc5ba1bf4f4f3ffb15841b3"></a>kExtF&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa9f18947d2c19c47e0f71e3a52cd47f68"></a>kCastFS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa5362d334aeb504f33b1ecf702e3af0f2"></a>kCastFU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473faa3d024040e8d017004b1d6b03b800249"></a>kCastSF&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473faa1472c2468bb45bc016ded6f7421f656"></a>kCastUF&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa2339a935a0013fe6f7c6cec4744f321e"></a>kCastS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fac6082a5a571997a15889a46d38f6fbe5"></a>kCastU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa2b948b86a786f7a160087d725233c0be"></a>kCastIdx&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa224bd99009853cf7ef74b09c65734559"></a>kTruncI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fab148b7730518be2c0507716ac375239b"></a>kCIm&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fabe669208044fe021b30a3a9e161c2c71"></a>kCRe&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa0b5838435ba246753f5e7a659c6d6cf2"></a>kBitCast&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa6ae54f6f44b9430c0a2520062efc0df5"></a>kBinaryBranch&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa0404bfcfac34897366a8b27b15cf3cfc"></a>kUnary&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fac354943a8aa7f784f1c595fcd011df88"></a>kSelect&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa2ce9ab16af1ff17d5ce97aaeac25000e"></a>kMulF&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa4283f386a777415d9c12cfb13fb2ab1f"></a>kMulC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa4115c96415ac84fc8209f94da4f86c0a"></a>kMulI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473faeef35e5eb247c144277f9240ee09c284"></a>kDivF&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fab0105b6265c9c2d1aa72d744b897dda3"></a>kDivC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa005a371c5ee45bb28e4b912fdbc547cd"></a>kDivS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473facf6645fdc82730c8d0287511b4a445f5"></a>kDivU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa31016f4ebccd93c3dd80e8e04f554726"></a>kAddF&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa8dc1eb52b7523c1b2bf7427b6edd3990"></a>kAddC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fad74e308af000953c9a9c54c131c96e4e"></a>kAddI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa513b8a419c15653052ea801f6e6d02d7"></a>kSubF&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa54b6ed4559e68f69c08a4c77088d142b"></a>kSubC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa0b60bf24a69f158c49eec6b64abbc203"></a>kSubI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fab55827336f3893743d80e8c7e42985b4"></a>kAndI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa785dbbb184d9ea3f71f5928d416ac7e2"></a>kOrI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473facbd0b073776a159cdb3cae7bc8cd884b"></a>kXorI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa6191183cedfbcb9393d84168e30c29a2"></a>kShrS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa475c7b7b44c4500e84108c305827cca8"></a>kShrU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fac48a99a57f90e42db19b77661e8e7cdd"></a>kShlI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fae1d767de5e7279ef7fea56db7a941965"></a>kBinary&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473fa8edcd92441bd8a185a8be124b8b033be"></a>kReduce&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Merger_8h_source.html#l00025">25</a> of file <a class="el" href="Merger_8h_source.html">Merger.h</a>.</p>

</div>
</div>
<a id="a32a597cffeb76da76443c157781e9d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a597cffeb76da76443c157781e9d60">&#9670;&nbsp;</a></span>OverheadType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60">mlir::sparse_tensor::OverheadType</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encoding of overhead types (both pointer overhead and indices overhead), for "overloading" @newSparseTensor. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1ab3a6a8f6871198b20d1e93409a473faaaa1335fda1c8d46b88c83f27e161967"></a>kIndex&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a32a597cffeb76da76443c157781e9d60a6256cfbcd370939b8454d9eca86b9d2a"></a>kU64&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a32a597cffeb76da76443c157781e9d60a4f2abe781a12702f9fbaea79fb6ba042"></a>kU32&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a32a597cffeb76da76443c157781e9d60a9070b7eed719acaf36119d4a2835a230"></a>kU16&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a32a597cffeb76da76443c157781e9d60aeda0b712c7690a5c8921fa54baad333e"></a>kU8&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Enums_8h_source.html#l00049">49</a> of file <a class="el" href="Enums_8h_source.html">Enums.h</a>.</p>

</div>
</div>
<a id="a6a7f4629fd99e5db6d08448472c904ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7f4629fd99e5db6d08448472c904ab">&#9670;&nbsp;</a></span>PrimaryType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904ab">mlir::sparse_tensor::PrimaryType</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encoding of the elemental type, for "overloading" @newSparseTensor. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6a7f4629fd99e5db6d08448472c904aba5234930e162acb53b17e178221057319"></a>kF64&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6a7f4629fd99e5db6d08448472c904aba941c992a0e3d2eb28203202730996ba2"></a>kF32&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6a7f4629fd99e5db6d08448472c904aba13a852aa20c7c1030c7d2588b5d799b6"></a>kF16&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6a7f4629fd99e5db6d08448472c904aba7b2caf2ed7b5f4f177fe3207cd198791"></a>kBF16&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6a7f4629fd99e5db6d08448472c904aba6601e7b0f7c0f03d9ffa9f222c82e6a0"></a>kI64&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6a7f4629fd99e5db6d08448472c904aba0a0ecdb4eded286c722877578774a293"></a>kI32&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6a7f4629fd99e5db6d08448472c904aba1201e21104cbb7ea3a7c362efcb325a3"></a>kI16&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6a7f4629fd99e5db6d08448472c904aba6c86e764d5c427a8339c3920a3c08603"></a>kI8&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6a7f4629fd99e5db6d08448472c904abab669ff1c81c4c96d8631985f992cb07c"></a>kC64&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6a7f4629fd99e5db6d08448472c904abaec949612bf882299f31abe2c9e57fe3b"></a>kC32&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Enums_8h_source.html#l00080">80</a> of file <a class="el" href="Enums_8h_source.html">Enums.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af809e07ab59de56afba2b40b3fe317a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af809e07ab59de56afba2b40b3fe317a8">&#9670;&nbsp;</a></span>allocDenseTensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::sparse_tensor::allocDenseTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RankedTensorType&#160;</td>
          <td class="paramname"><em>tensorTp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates code to allocate a buffer of the given type, and zero initialize it. </p>
<p>If the buffer type has any dynamic sizes, then the <code>sizes</code> parameter should be as filled by sizesFromPtr(); that way we can reuse the genDimSizeCall() results generated by sizesFromPtr(). </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l00934">934</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="CodegenUtils_8h_source.html#l00223">constantZero()</a>, and <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>.</p>

</div>
</div>
<a id="a54f243601897f46d07d7241bca9bc491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f243601897f46d07d7241bca9bc491">&#9670;&nbsp;</a></span>buildBinaryOverlap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Value.html">Value</a> mlir::sparse_tensor::buildBinaryOverlap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Merger_8cpp_source.html#l01108">1108</a> of file <a class="el" href="Merger_8cpp_source.html">Merger.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00060">mlir::Region::empty()</a>, and <a class="el" href="Merger_8cpp_source.html#l01077">insertYieldOp()</a>.</p>

</div>
</div>
<a id="ace31d87d56cd565e14e7a81050eb5476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace31d87d56cd565e14e7a81050eb5476">&#9670;&nbsp;</a></span>buildSparseCompiler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::sparse_tensor::buildSparseCompiler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1sparse__tensor_1_1SparseCompilerOptions.html">SparseCompilerOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the "sparse-compiler" pipeline to the <code><a class="el" href="classmlir_1_1OpPassManager.html" title="This class represents a pass manager that runs passes on either a specific operation type,...">OpPassManager</a></code>. </p>
<p>This is the standard pipeline for taking sparsity-agnostic IR using the sparse-tensor type and lowering it to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR with concrete representations and algorithms for sparse tensors. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00052">52</a> of file <a class="el" href="SparseTensorPipelines_8cpp_source.html">SparseTensorPipelines.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManager_8h_source.html#l00121">mlir::OpPassManager::addNestedPass()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00332">mlir::OpPassManager::addPass()</a>, <a class="el" href="Arith_2Transforms_2ExpandOps_8cpp_source.html#l00249">mlir::arith::createArithExpandOpsPass()</a>, <a class="el" href="Canonicalizer_8cpp_source.html#l00066">mlir::createCanonicalizerPass()</a>, <a class="el" href="ComplexToLibm_8cpp_source.html#l00146">mlir::createConvertComplexToLibmPass()</a>, <a class="el" href="ComplexToLLVM_8cpp_source.html#l00344">mlir::createConvertComplexToLLVMPass()</a>, <a class="el" href="ComplexToStandard_8cpp_source.html#l01106">mlir::createConvertComplexToStandardPass()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00757">mlir::createConvertFuncToLLVMPass()</a>, <a class="el" href="Loops_8cpp_source.html#l00352">mlir::createConvertLinalgToLoopsPass()</a>, <a class="el" href="MathToLibm_8cpp_source.html#l00222">mlir::createConvertMathToLibmPass()</a>, <a class="el" href="MathToLLVM_8cpp_source.html#l00333">mlir::createConvertMathToLLVMPass()</a>, <a class="el" href="SCFToControlFlow_8cpp_source.html#l00705">mlir::createConvertSCFToCFPass()</a>, <a class="el" href="ConvertVectorToLLVMPass_8cpp_source.html#l00121">mlir::createConvertVectorToLLVMPass()</a>, <a class="el" href="VectorToSCF_8cpp_source.html#l01322">mlir::createConvertVectorToSCFPass()</a>, <a class="el" href="DenseBufferizationPass_8cpp_source.html#l00070">mlir::createDenseBufferizationPass()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00309">mlir::bufferization::createFinalizingBufferizePass()</a>, <a class="el" href="Generalization_8cpp_source.html#l00094">mlir::createLinalgGeneralizationPass()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00568">mlir::createLowerAffinePass()</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00288">mlir::createPostSparsificationRewritePass()</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00275">mlir::createPreSparsificationRewritePass()</a>, <a class="el" href="ReconcileUnrealizedCasts_8cpp_source.html#l00132">mlir::createReconcileUnrealizedCastsPass()</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00317">mlir::createSparseBufferRewritePass()</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00308">mlir::createSparseTensorCodegenPass()</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00299">mlir::createSparseTensorConversionPass()</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00279">mlir::createSparsificationPass()</a>, <a class="el" href="TensorCopyInsertion_8cpp_source.html#l00198">mlir::bufferization::createTensorCopyInsertionPass()</a>, <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00028">getBufferizationOptions()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00099">registerSparseTensorPipelines()</a>.</p>

</div>
</div>
<a id="a430168327a6b66763c6c1427541591f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a430168327a6b66763c6c1427541591f6">&#9670;&nbsp;</a></span>buildUnaryPresent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Value.html">Value</a> mlir::sparse_tensor::buildUnaryPresent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>v0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Merger_8cpp_source.html#l01094">1094</a> of file <a class="el" href="Merger_8cpp_source.html">Merger.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00060">mlir::Region::empty()</a>, and <a class="el" href="Merger_8cpp_source.html#l01077">insertYieldOp()</a>.</p>

</div>
</div>
<a id="a63f7e5d153806f1c9506e6c4b38e8507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f7e5d153806f1c9506e6c4b38e8507">&#9670;&nbsp;</a></span>constantAction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::sparse_tensor::constantAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a381f27e8f48be9793332d997f81ebecb">Action</a>&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a constant of the given <code>Action</code>. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8h_source.html#l00270">270</a> of file <a class="el" href="CodegenUtils_8h_source.html">CodegenUtils.h</a>.</p>

<p class="reference">References <a class="el" href="CodegenUtils_8h_source.html#l00250">constantI32()</a>.</p>

</div>
</div>
<a id="af6e504928338ed504e51d671e2520127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e504928338ed504e51d671e2520127">&#9670;&nbsp;</a></span>constantDimLevelTypeEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::sparse_tensor::constantDimLevelTypeEncoding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a>&#160;</td>
          <td class="paramname"><em>dlt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a constant of the internal dimension level type encoding. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8h_source.html#l00303">303</a> of file <a class="el" href="CodegenUtils_8h_source.html">CodegenUtils.h</a>.</p>

<p class="reference">References <a class="el" href="CodegenUtils_8h_source.html#l00260">constantI8()</a>.</p>

</div>
</div>
<a id="a5f64fbd97b3789823a56e49a293e1e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f64fbd97b3789823a56e49a293e1e6e">&#9670;&nbsp;</a></span>constantI1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::sparse_tensor::constantI1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a constant of <code>i1</code> type. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8h_source.html#l00265">265</a> of file <a class="el" href="CodegenUtils_8h_source.html">CodegenUtils.h</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseBufferRewriting_8cpp_source.html#l00208">createEqCompare()</a>, <a class="el" href="SparseBufferRewriting_8cpp_source.html#l00252">createLessThanCompare()</a>, and <a class="el" href="Sparsification_8cpp_source.html#l01018">genIf()</a>.</p>

</div>
</div>
<a id="ac9f31d19a3deeff30f1ffdf9da90b1e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f31d19a3deeff30f1ffdf9da90b1e4">&#9670;&nbsp;</a></span>constantI16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::sparse_tensor::constantI16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a constant of <code>i16</code> type. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8h_source.html#l00255">255</a> of file <a class="el" href="CodegenUtils_8h_source.html">CodegenUtils.h</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>.</p>

</div>
</div>
<a id="ae24cf7c247f3ed10a02ecb5c4884a3c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae24cf7c247f3ed10a02ecb5c4884a3c1">&#9670;&nbsp;</a></span>constantI32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::sparse_tensor::constantI32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a constant of <code>i32</code> type. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8h_source.html#l00250">250</a> of file <a class="el" href="CodegenUtils_8h_source.html">CodegenUtils.h</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenUtils_8h_source.html#l00270">constantAction()</a>, <a class="el" href="CodegenUtils_8h_source.html#l00275">constantOverheadTypeEncoding()</a>, and <a class="el" href="CodegenUtils_8h_source.html#l00296">constantPrimaryTypeEncoding()</a>.</p>

</div>
</div>
<a id="a32e94d104c16a3cba747e3da258e0d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32e94d104c16a3cba747e3da258e0d5d">&#9670;&nbsp;</a></span>constantI8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::sparse_tensor::constantI8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a constant of <code>i8</code> type. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8h_source.html#l00260">260</a> of file <a class="el" href="CodegenUtils_8h_source.html">CodegenUtils.h</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenUtils_8h_source.html#l00303">constantDimLevelTypeEncoding()</a>.</p>

</div>
</div>
<a id="a0afca7b5c11b6824d49d422a154323d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0afca7b5c11b6824d49d422a154323d7">&#9670;&nbsp;</a></span>constantIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::sparse_tensor::constantIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a constant of <code>index</code> type. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8h_source.html#l00245">245</a> of file <a class="el" href="CodegenUtils_8h_source.html">CodegenUtils.h</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseBufferRewriting_8cpp_source.html#l00324">createBinarySearchFunc()</a>, <a class="el" href="SparseBufferRewriting_8cpp_source.html#l00475">createPartitionFunc()</a>, <a class="el" href="SparseBufferRewriting_8cpp_source.html#l00393">createScanLoop()</a>, <a class="el" href="SparseBufferRewriting_8cpp_source.html#l00589">createSortNonstableFunc()</a>, <a class="el" href="SparseBufferRewriting_8cpp_source.html#l00642">createSortStableFunc()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00219">mlir::sparse_tensor::SparseTensorLoopEmitter::enterLoopOverTensorAtDim()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00207">mlir::sparse_tensor::SparseTensorLoopEmitter::enterNewLoopSeq()</a>, <a class="el" href="SparseBufferRewriting_8cpp_source.html#l00105">forEachIJPairInXs()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00492">genAffine()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00918">genAlloca()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00968">genDenseTensorOrSparseConstantIterLoop()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00061">genIndexAndValueForSparse()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00780">genReshapeDstShape()</a>, <a class="el" href="SparseBufferRewriting_8cpp_source.html#l00714">matchAndRewriteSortOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00516">parseGEPIndices()</a>, <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00116">sizesForTensor()</a>, <a class="el" href="LoopSpecialization_8cpp_source.html#l00082">specializeForLoopForUnrolling()</a>, <a class="el" href="LoopSpecialization_8cpp_source.html#l00044">specializeParallelLoopForUnrolling()</a>, and <a class="el" href="CodegenUtils_8cpp_source.html#l00836">translateIndicesArray()</a>.</p>

</div>
</div>
<a id="a0544f3c9956472a3f18d7f02c3e62aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0544f3c9956472a3f18d7f02c3e62aa2">&#9670;&nbsp;</a></span>constantIndexTypeEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::sparse_tensor::constantIndexTypeEncoding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparseTensorEncodingAttr &amp;&#160;</td>
          <td class="paramname"><em>enc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a constant of the internal type-encoding for index overhead storage. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8h_source.html#l00290">290</a> of file <a class="el" href="CodegenUtils_8h_source.html">CodegenUtils.h</a>.</p>

<p class="reference">References <a class="el" href="CodegenUtils_8h_source.html#l00275">constantOverheadTypeEncoding()</a>.</p>

</div>
</div>
<a id="a31882503d2770c14e8fc599f3540c364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31882503d2770c14e8fc599f3540c364">&#9670;&nbsp;</a></span>constantOne()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::sparse_tensor::constantOne </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>tp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a 1-valued constant of the given type. </p>
<p>This supports all the same types as <code>constantZero</code>. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8h_source.html#l00234">234</a> of file <a class="el" href="CodegenUtils_8h_source.html">CodegenUtils.h</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2Types_8h_source.html#l00270">mlir::Type::dyn_cast()</a>, <a class="el" href="Builders_8cpp_source.html#l00247">mlir::Builder::getArrayAttr()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00750">getOneAttr()</a>, and <a class="el" href="Builders_8cpp_source.html#l00306">mlir::Builder::getZeroAttr()</a>.</p>

</div>
</div>
<a id="ab8f6c538a7e434c02147d7d95a0ceb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f6c538a7e434c02147d7d95a0ceb34">&#9670;&nbsp;</a></span>constantOverheadTypeEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::sparse_tensor::constantOverheadTypeEncoding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a constant of the internal type-encoding for overhead storage. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8h_source.html#l00275">275</a> of file <a class="el" href="CodegenUtils_8h_source.html">CodegenUtils.h</a>.</p>

<p class="reference">References <a class="el" href="CodegenUtils_8h_source.html#l00250">constantI32()</a>, and <a class="el" href="CodegenUtils_8cpp_source.html#l00623">overheadTypeEncoding()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenUtils_8h_source.html#l00290">constantIndexTypeEncoding()</a>, and <a class="el" href="CodegenUtils_8h_source.html#l00283">constantPointerTypeEncoding()</a>.</p>

</div>
</div>
<a id="ac9728e9a26cdd35a8c1d00a462734d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9728e9a26cdd35a8c1d00a462734d3e">&#9670;&nbsp;</a></span>constantPointerTypeEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::sparse_tensor::constantPointerTypeEncoding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparseTensorEncodingAttr &amp;&#160;</td>
          <td class="paramname"><em>enc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a constant of the internal type-encoding for pointer overhead storage. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8h_source.html#l00283">283</a> of file <a class="el" href="CodegenUtils_8h_source.html">CodegenUtils.h</a>.</p>

<p class="reference">References <a class="el" href="CodegenUtils_8h_source.html#l00275">constantOverheadTypeEncoding()</a>.</p>

</div>
</div>
<a id="ae41c3450aa0396748a11b1ce7a4fa8e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41c3450aa0396748a11b1ce7a4fa8e3">&#9670;&nbsp;</a></span>constantPrimaryTypeEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::sparse_tensor::constantPrimaryTypeEncoding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>elemTp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a constant of the internal type-encoding for primary storage. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8h_source.html#l00296">296</a> of file <a class="el" href="CodegenUtils_8h_source.html">CodegenUtils.h</a>.</p>

<p class="reference">References <a class="el" href="CodegenUtils_8h_source.html#l00250">constantI32()</a>, and <a class="el" href="CodegenUtils_8cpp_source.html#l00704">primaryTypeEncoding()</a>.</p>

</div>
</div>
<a id="a0fc22f44748f0f59b4a61893c5d144e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc22f44748f0f59b4a61893c5d144e9">&#9670;&nbsp;</a></span>constantZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::sparse_tensor::constantZero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>tp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a 0-valued constant of the given type. </p>
<p>In addition to the scalar types (<code>ComplexType</code>, `<code><a class="el" href="classmlir_1_1FloatType.html">FloatType</a></code>, <code>IndexType</code>, <code>IntegerType</code>), this also works for <code>RankedTensorType</code> and <code>VectorType</code> (for which it generates a constant <code><a class="el" href="classmlir_1_1DenseElementsAttr.html" title="An attribute that represents a reference to a dense vector or tensor object.">DenseElementsAttr</a></code> of zeros). </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8h_source.html#l00223">223</a> of file <a class="el" href="CodegenUtils_8h_source.html">CodegenUtils.h</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2Types_8h_source.html#l00270">mlir::Type::dyn_cast()</a>, <a class="el" href="Builders_8cpp_source.html#l00247">mlir::Builder::getArrayAttr()</a>, and <a class="el" href="Builders_8cpp_source.html#l00306">mlir::Builder::getZeroAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenUtils_8cpp_source.html#l00934">allocDenseTensor()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00556">genInsertionLoad()</a>, and <a class="el" href="CodegenUtils_8cpp_source.html#l00765">genIsNonzero()</a>.</p>

</div>
</div>
<a id="a8e910b3b9ffdd5d21eb4451787991c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e910b3b9ffdd5d21eb4451787991c8f">&#9670;&nbsp;</a></span>containsSparseTensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::sparse_tensor::containsSparseTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>types</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if one of the given types is a sparse tensor type. </p>

<p class="definition">Definition at line <a class="el" href="DenseBufferizationPass_8cpp_source.html#l00024">24</a> of file <a class="el" href="DenseBufferizationPass_8cpp_source.html">DenseBufferizationPass.cpp</a>.</p>

<p class="reference">References <a class="el" href="SparseTensorDialect_8cpp_source.html#l00261">getSparseTensorEncoding()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DenseBufferizationPass_8cpp_source.html#l00041">mlir::sparse_tensor::BufferizeDenseOpsPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="aceb551c7fe08d4e0f1d6ac0cec343785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb551c7fe08d4e0f1d6ac0cec343785">&#9670;&nbsp;</a></span>createFuncCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">func::CallOp mlir::sparse_tensor::createFuncCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>resultType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#af7ede6e23dd46be42eac24e06b29b2a2">EmitCInterface</a>&#160;</td>
          <td class="paramname"><em>emitCInterface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <code>CallOp</code> to the function reference returned by <code><a class="el" href="namespacemlir_1_1sparse__tensor.html#a058ca7dd4f94a17037092388673ba6b4" title="Returns a function reference (first hit also inserts into module).">getFunc()</a></code> in the builder's module. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l00905">905</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8h_source.html#l00400">mlir::OpBuilder::getBlock()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00885">getFunc()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00169">mlir::Operation::getParentOfType()</a>, and <a class="el" href="Block_8cpp_source.html#l00030">mlir::Block::getParentOp()</a>.</p>

</div>
</div>
<a id="aaf6d589527be4ee54cb4452354afe6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6d589527be4ee54cb4452354afe6f9">&#9670;&nbsp;</a></span>deallocDenseTensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::sparse_tensor::deallocDenseTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates code to deallocate a dense buffer. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l00951">951</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>.</p>

</div>
</div>
<a id="ac8ccea01103720ec989b8bf527f3ba07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ccea01103720ec989b8bf527f3ba07">&#9670;&nbsp;</a></span>foreachInSparseConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::sparse_tensor::foreachInSparseConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparseElementsAttr&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over a sparse constant, generates constantOp for value and indices. </p>
<p>E.g., sparse&lt;[ [0], [28], [31] ], [ (-5.13, 2.0), (3.0, 4.0), (5.0, 6.0) ] &gt; =&gt; c1 = arith.constant 0 v1 = complex.constant (5.13, 2.0) callback({c1}, v1)</p>
<p>c2 = arith.constant 28 v2 = complex.constant (3.0, 4.0) callback({c2}, v2)</p>
<p>c3 = arith.constant 31 v3 = complex.constant (5.0, 6.0) callback({c3}, v3) </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l01028">1028</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00415">mlir::DenseElementsAttr::getValues()</a>, and <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00602">mlir::DenseElementsAttr::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00173">genForeachOnSparseConstant()</a>.</p>

</div>
</div>
<a id="aead03953e707ee79cc4758660b4a3270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead03953e707ee79cc4758660b4a3270">&#9670;&nbsp;</a></span>genAlloca() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::sparse_tensor::genAlloca </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>tp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates an uninitialized temporary buffer of the given size and type, but returns it as type <code>memref&lt;? x $tp&gt;</code> (rather than as type <code>memref&lt;$sz x $tp&gt;</code>). </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l00918">918</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="CodegenUtils_8h_source.html#l00245">constantIndex()</a>, and <a class="el" href="CodegenUtils_8cpp_source.html#l00923">genAlloca()</a>.</p>

</div>
</div>
<a id="ab45d3869f353db49776cf0b9dc4df1e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45d3869f353db49776cf0b9dc4df1e4">&#9670;&nbsp;</a></span>genAlloca() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::sparse_tensor::genAlloca </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>tp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates an uninitialized temporary buffer of the given size and type, but returns it as type <code>memref&lt;? x $tp&gt;</code> (rather than as type <code>memref&lt;$sz x $tp&gt;</code>). </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l00923">923</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenUtils_8cpp_source.html#l00918">genAlloca()</a>.</p>

</div>
</div>
<a id="a07e0fa74abcc8be1da4aa0790f20f9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e0fa74abcc8be1da4aa0790f20f9bc">&#9670;&nbsp;</a></span>genAllocaScalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::sparse_tensor::genAllocaScalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>tp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates an uninitialized temporary buffer with room for one value of the given type, and returns the <code>memref&lt;$tp&gt;</code>. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l00929">929</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>.</p>

</div>
</div>
<a id="a82c3a25f128140fcfb2356b9d58ac58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c3a25f128140fcfb2356b9d58ac58c">&#9670;&nbsp;</a></span>genDenseTensorOrSparseConstantIterLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::sparse_tensor::genDenseTensorOrSparseConstantIterLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;&#160;</td>
          <td class="paramname"><em>bodyBuilder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the loop structure to iterate over a dense tensor or a sparse tensor constant to support the lowering of dense-to-sparse convert operator. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l00968">968</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00508">mlir::scf::buildLoopNest()</a>, <a class="el" href="CodegenUtils_8h_source.html#l00245">constantIndex()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00199">mlir::linalg::createOrFoldDimOp()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00084">genIndexAndValueForDense()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00061">genIndexAndValueForSparse()</a>, and <a class="el" href="CodegenUtils_8cpp_source.html#l00046">genSplitSparseConstant()</a>.</p>

</div>
</div>
<a id="a95e5fa1625ec77aeb54ef34e01f02019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e5fa1625ec77aeb54ef34e01f02019">&#9670;&nbsp;</a></span>genIsNonzero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::sparse_tensor::genIsNonzero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">mlir::Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the comparison <code>v != 0</code> where <code>v</code> is of numeric type. </p>
<p>For floating types, we use the "unordered" comparator (i.e., returns true if <code>v</code> is NaN). </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l00765">765</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="CodegenUtils_8h_source.html#l00223">constantZero()</a>, <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2Types_8h_source.html#l00270">mlir::Type::dyn_cast()</a>, <a class="el" href="Value_8h_source.html#l00114">mlir::Value::getType()</a>, <a class="el" href="IR_2Types_8h_source.html#l00260">mlir::Type::isa()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00087">mlir::Type::isIntOrIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenUtils_8cpp_source.html#l00956">genValueForDense()</a>.</p>

</div>
</div>
<a id="adbd93e7b9fd12439226f7d344892a23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd93e7b9fd12439226f7d344892a23e">&#9670;&nbsp;</a></span>genReshapeDstShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::sparse_tensor::genReshapeDstShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dstShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>srcShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>staticDstShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the shape of destination tensor of a reshape operator. </p>
<p>This is only used when operands have dynamic shape. The shape of the destination is stored into dstShape. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l00780">780</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="CodegenUtils_8h_source.html#l00245">constantIndex()</a>, <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, and <a class="el" href="Matchers_8h_source.html#l00230">mlir::detail::enumerate()</a>.</p>

</div>
</div>
<a id="a4c8bbe5cf94f1a5fde6da83eb1604c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8bbe5cf94f1a5fde6da83eb1604c81">&#9670;&nbsp;</a></span>genValueForDense()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::sparse_tensor::genValueForDense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ivs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the code to read the value from tensor[ivs]. </p>
<p>The generated code looks like the following and the insertion point after this routine is inside the if-then branch behind the assignment to ind. if (tensor[ivs] != 0) insert_point </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l00956">956</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00765">genIsNonzero()</a>, and <a class="el" href="Builders_8h_source.html#l00383">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenUtils_8cpp_source.html#l00084">genIndexAndValueForDense()</a>.</p>

</div>
</div>
<a id="ab19e75a0d0fefd242c0b11a78e4e9aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19e75a0d0fefd242c0b11a78e4e9aff">&#9670;&nbsp;</a></span>getDimLevelType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a> mlir::sparse_tensor::getDimLevelType </td>
          <td>(</td>
          <td class="paramtype">const SparseTensorEncodingAttr &amp;&#160;</td>
          <td class="paramname"><em>enc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00049">49</a> of file <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html">SparseTensor.h</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95a9a71a13863c84ba34fc41595fc2ee0c6">Dense</a>.</p>

<p class="reference">Referenced by <a class="el" href="Sparsification_8cpp_source.html#l00163">findSparseAnnotations()</a>, <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00059">getDimLevelType()</a>, <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00069">isCompressedDim()</a>, <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00064">isDenseDim()</a>, <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00084">isOrderedDim()</a>, <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00074">isSingletonDim()</a>, <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00090">isUniqueDim()</a>, <a class="el" href="SparseTensor_8cpp_source.html#l00077">mlirSparseTensorEncodingAttrGetDimLevelType()</a>, and <a class="el" href="SparseTensor_8cpp_source.html#l00072">mlirSparseTensorEncodingGetNumDimLevelTypes()</a>.</p>

</div>
</div>
<a id="a6fcdd432ac6e307fe16e7313c1e7bef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fcdd432ac6e307fe16e7313c1e7bef0">&#9670;&nbsp;</a></span>getDimLevelType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a> mlir::sparse_tensor::getDimLevelType </td>
          <td>(</td>
          <td class="paramtype">RankedTensorType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00059">59</a> of file <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html">SparseTensor.h</a>.</p>

<p class="reference">References <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00049">getDimLevelType()</a>, and <a class="el" href="SparseTensorDialect_8cpp_source.html#l00261">getSparseTensorEncoding()</a>.</p>

</div>
</div>
<a id="a058ca7dd4f94a17037092388673ba6b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058ca7dd4f94a17037092388673ba6b4">&#9670;&nbsp;</a></span>getFunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FlatSymbolRefAttr.html">FlatSymbolRefAttr</a> mlir::sparse_tensor::getFunc </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>resultType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#af7ede6e23dd46be42eac24e06b29b2a2">EmitCInterface</a>&#160;</td>
          <td class="paramname"><em>emitCInterface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a function reference (first hit also inserts into module). </p>
<p>Sets the "_emit_c_interface" on the function declaration when requested, so that <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> lowering generates a wrapper function that takes care of ABI complications with passing in and returning MemRefs to C functions. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l00885">885</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="classmlir_1_1ValueRange.html#ab8f3a1aeea4da0acfaad1bc71b072017">mlir::ValueRange::getTypes()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00395">mlir::Operation::setAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenUtils_8cpp_source.html#l00905">createFuncCall()</a>.</p>

</div>
</div>
<a id="a829bf299dd13613f7e6542d6846e01a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829bf299dd13613f7e6542d6846e01a4">&#9670;&nbsp;</a></span>getIndexOverheadType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::sparse_tensor::getIndexOverheadType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparseTensorEncodingAttr &amp;&#160;</td>
          <td class="paramname"><em>enc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">mlir::Type</a> for index overhead storage. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l00678">678</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="CodegenUtils_8cpp_source.html#l00647">getOverheadType()</a>, and <a class="el" href="CodegenUtils_8cpp_source.html#l00668">indexOverheadTypeEncoding()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenUtils_8cpp_source.html#l00131">mlir::sparse_tensor::SparseTensorLoopEmitter::initializeLoopEmit()</a>.</p>

</div>
</div>
<a id="a040aa1c78bc3c44cd56447a1c43fdba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040aa1c78bc3c44cd56447a1c43fdba8">&#9670;&nbsp;</a></span>getOneAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">mlir::Attribute</a> mlir::sparse_tensor::getOneAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>tp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a 1-valued attribute of the given type. </p>
<p>This supports all the same types as <code>getZeroAttr</code>; however, unlike <code>getZeroAttr</code>, for unsupported types we raise <code>llvm_unreachable</code> rather than returning a null attribute. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l00750">750</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00280">mlir::Type::cast()</a>, <a class="el" href="IR_2Types_8h_source.html#l00270">mlir::Type::dyn_cast()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00938">mlir::DenseElementsAttr::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00235">mlir::Builder::getFloatAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00109">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00212">mlir::Builder::getIntegerAttr()</a>, and <a class="el" href="IR_2Types_8h_source.html#l00260">mlir::Type::isa()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenUtils_8h_source.html#l00234">constantOne()</a>.</p>

</div>
</div>
<a id="a9c1bee8cae4c2533f4a3d8d9d019e988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1bee8cae4c2533f4a3d8d9d019e988">&#9670;&nbsp;</a></span>getOpaquePointerType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::sparse_tensor::getOpaquePointerType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the equivalent of <code>void*</code> for opaque arguments to the execution engine. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l00914">914</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00064">mlir::Builder::getI8Type()</a>.</p>

</div>
</div>
<a id="ae5f37309e9664d3b46e3ecac113e2fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f37309e9664d3b46e3ecac113e2fb1">&#9670;&nbsp;</a></span>getOverheadType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::sparse_tensor::getOverheadType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60">OverheadType</a>&#160;</td>
          <td class="paramname"><em>ot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the internal type-encoding for overhead storage to an <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">mlir::Type</a>. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l00647">647</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00056">mlir::Builder::getIndexType()</a>, <a class="el" href="Builders_8cpp_source.html#l00072">mlir::Builder::getIntegerType()</a>, <a class="el" href="Merger_8h_source.html#l00029">kIndex</a>, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60a9070b7eed719acaf36119d4a2835a230">kU16</a>, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60a4f2abe781a12702f9fbaea79fb6ba042">kU32</a>, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60a6256cfbcd370939b8454d9eca86b9d2a">kU64</a>, and <a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60aeda0b712c7690a5c8921fa54baad333e">kU8</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenUtils_8cpp_source.html#l00678">getIndexOverheadType()</a>, and <a class="el" href="CodegenUtils_8cpp_source.html#l00673">getPointerOverheadType()</a>.</p>

</div>
</div>
<a id="a40f52010819157c60b6dfd993b425ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f52010819157c60b6dfd993b425ee4">&#9670;&nbsp;</a></span>getPointerOverheadType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::sparse_tensor::getPointerOverheadType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparseTensorEncodingAttr &amp;&#160;</td>
          <td class="paramname"><em>enc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">mlir::Type</a> for pointer overhead storage. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l00673">673</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="CodegenUtils_8cpp_source.html#l00647">getOverheadType()</a>, and <a class="el" href="CodegenUtils_8cpp_source.html#l00663">pointerOverheadTypeEncoding()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenUtils_8cpp_source.html#l00131">mlir::sparse_tensor::SparseTensorLoopEmitter::initializeLoopEmit()</a>.</p>

</div>
</div>
<a id="a90cf107e240044ac0fbeb952ea3ae0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90cf107e240044ac0fbeb952ea3ae0f0">&#9670;&nbsp;</a></span>getSparseTensorEncoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparseTensorEncodingAttr mlir::sparse_tensor::getSparseTensorEncoding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to get a sparse encoding attribute from a type. </p>
<p>Returns null-attribute for any type without an encoding. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorDialect_8cpp_source.html#l00261">261</a> of file <a class="el" href="SparseTensorDialect_8cpp_source.html">SparseTensorDialect.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00270">mlir::Type::dyn_cast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Sparsification_8cpp_source.html#l00253">computeIterationGraph()</a>, <a class="el" href="DenseBufferizationPass_8cpp_source.html#l00024">containsSparseTensor()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00295">mlir::sparse_tensor::SparseTensorLoopEmitter::enterCoIterationOverTensorsAtDims()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00219">mlir::sparse_tensor::SparseTensorLoopEmitter::enterLoopOverTensorAtDim()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00163">findSparseAnnotations()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00447">genBuffers()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00521">genIndex()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00801">genInvariants()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00531">genSubscript()</a>, <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00059">getDimLevelType()</a>, <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00131">getUnorderedCOOFromType()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00131">mlir::sparse_tensor::SparseTensorLoopEmitter::initializeLoopEmit()</a>, <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00043">isSparseTensor()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00267">isUniqueCOOType()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00097">mlir::sparse_tensor::SparseTensorLoopEmitter::SparseTensorLoopEmitter()</a>, <a class="el" href="SparseTensorCodegen_8cpp_source.html#l01015">mlir::SparseTensorTypeToBufferConverter::SparseTensorTypeToBufferConverter()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00309">toOrigDim()</a>, and <a class="el" href="SparseTensorDialect_8cpp_source.html#l00314">toStoredDim()</a>.</p>

</div>
</div>
<a id="a82016f51c5f51422120acc4ac5143d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82016f51c5f51422120acc4ac5143d91">&#9670;&nbsp;</a></span>getTop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * mlir::sparse_tensor::getTop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scans to top of generated loop. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l01018">1018</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00165">mlir::Operation::getParentOp()</a>.</p>

</div>
</div>
<a id="ad5076532ad03d2dc7f8c6cbb4acc7900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5076532ad03d2dc7f8c6cbb4acc7900">&#9670;&nbsp;</a></span>indexOverheadTypeEncoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60">OverheadType</a> mlir::sparse_tensor::indexOverheadTypeEncoding </td>
          <td>(</td>
          <td class="paramtype">const SparseTensorEncodingAttr &amp;&#160;</td>
          <td class="paramname"><em>enc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the OverheadType for index overhead storage. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l00668">668</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="CodegenUtils_8cpp_source.html#l00623">overheadTypeEncoding()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenUtils_8cpp_source.html#l00678">getIndexOverheadType()</a>.</p>

</div>
</div>
<a id="a244b410c7a4d3b7a7be2d2e78fe41d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244b410c7a4d3b7a7be2d2e78fe41d85">&#9670;&nbsp;</a></span>insertYieldOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Value.html">Value</a> mlir::sparse_tensor::insertYieldOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Merger_8cpp_source.html#l01077">1077</a> of file <a class="el" href="Merger_8cpp_source.html">Merger.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00055">mlir::Region::begin()</a>, <a class="el" href="IR_2Region_8cpp_source.html#l00070">mlir::Region::cloneInto()</a>, <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00275">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="Block_8cpp_source.html#l00232">mlir::Block::getTerminator()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00322">mlir::RewriterBase::mergeBlockBefore()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Merger_8cpp_source.html#l01108">buildBinaryOverlap()</a>, and <a class="el" href="Merger_8cpp_source.html#l01094">buildUnaryPresent()</a>.</p>

</div>
</div>
<a id="a59660eda97580c1b4ece30883fb7dd22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59660eda97580c1b4ece30883fb7dd22">&#9670;&nbsp;</a></span>isAdmissibleBranch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::sparse_tensor::isAdmissibleBranch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that sparse compiler can generate code for branch. </p>

<p class="definition">Definition at line <a class="el" href="Merger_8cpp_source.html#l00892">892</a> of file <a class="el" href="Merger_8cpp_source.html">Merger.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00060">mlir::Region::empty()</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00267">mlir::Operation::getOperand()</a>, <a class="el" href="Block_8cpp_source.html#l00232">mlir::Block::getTerminator()</a>, and <a class="el" href="Merger_8cpp_source.html#l00872">isAdmissibleBranchExp()</a>.</p>

</div>
</div>
<a id="a09520b912c648fa708982dabd05dcbb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09520b912c648fa708982dabd05dcbb9">&#9670;&nbsp;</a></span>isAdmissibleBranchExp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::sparse_tensor::isAdmissibleBranchExp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that sparse compiler can generate code for expression. </p>

<p class="definition">Definition at line <a class="el" href="Merger_8cpp_source.html#l00872">872</a> of file <a class="el" href="Merger_8cpp_source.html">Merger.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00095">mlir::Value::dyn_cast()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00144">mlir::Operation::getBlock()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00263">mlir::Operation::getNumOperands()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00267">mlir::Operation::getOperand()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Merger_8cpp_source.html#l00892">isAdmissibleBranch()</a>.</p>

</div>
</div>
<a id="aaffa80c421bd3e4c5953057725e54d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaffa80c421bd3e4c5953057725e54d7e">&#9670;&nbsp;</a></span>isComplexPrimaryType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool mlir::sparse_tensor::isComplexPrimaryType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904ab">PrimaryType</a>&#160;</td>
          <td class="paramname"><em>valTy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Enums_8h_source.html#l00118">118</a> of file <a class="el" href="Enums_8h_source.html">Enums.h</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904abaec949612bf882299f31abe2c9e57fe3b">kC32</a>, and <a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904abab669ff1c81c4c96d8631985f992cb07c">kC64</a>.</p>

<p class="reference">Referenced by <a class="el" href="File_8cpp_source.html#l00092">mlir::sparse_tensor::SparseTensorReader::canReadAs()</a>.</p>

</div>
</div>
<a id="a41fd46b792d78d65a5cc6e9c32de45c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41fd46b792d78d65a5cc6e9c32de45c9">&#9670;&nbsp;</a></span>isCompressedDim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::isCompressedDim </td>
          <td>(</td>
          <td class="paramtype">RankedTensorType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function to test for compressed dimension (0 &lt;= d &lt; rank). </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00069">69</a> of file <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html">SparseTensor.h</a>.</p>

<p class="reference">References <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00049">getDimLevelType()</a>, and <a class="el" href="Enums_8h_source.html#l00184">isCompressedDLT()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorDialect_8cpp_source.html#l00267">isUniqueCOOType()</a>.</p>

</div>
</div>
<a id="ac55329be9bb21947094bd053a2b6f4ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac55329be9bb21947094bd053a2b6f4ce">&#9670;&nbsp;</a></span>isCompressedDLT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool mlir::sparse_tensor::isCompressedDLT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a>&#160;</td>
          <td class="paramname"><em>dlt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the <code>DimLevelType</code> is compressed (regardless of properties). </p>

<p class="definition">Definition at line <a class="el" href="Enums_8h_source.html#l00184">184</a> of file <a class="el" href="Enums_8h_source.html">Enums.h</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95a4d602abc0c0f2f7c1a5156d964517e4e">Compressed</a>.</p>

<p class="reference">Referenced by <a class="el" href="Sparsification_8cpp_source.html#l00253">computeIterationGraph()</a>, <a class="el" href="Merger_8cpp_source.html#l00611">mlir::sparse_tensor::Merger::dumpBits()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00295">mlir::sparse_tensor::SparseTensorLoopEmitter::enterCoIterationOverTensorsAtDims()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00219">mlir::sparse_tensor::SparseTensorLoopEmitter::enterLoopOverTensorAtDim()</a>, <a class="el" href="NNZ_8cpp_source.html#l00056">mlir::sparse_tensor::SparseTensorNNZ::forallIndices()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00927">genFor()</a>, <a class="el" href="Sparsification_8cpp_source.html#l01018">genIf()</a>, <a class="el" href="Merger_8cpp_source.html#l00397">mlir::sparse_tensor::Merger::hasAnySparse()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00131">mlir::sparse_tensor::SparseTensorLoopEmitter::initializeLoopEmit()</a>, <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00069">isCompressedDim()</a>, <a class="el" href="Storage_8h_source.html#l00181">mlir::sparse_tensor::SparseTensorStorageBase::isCompressedLvl()</a>, <a class="el" href="Merger_8cpp_source.html#l00255">mlir::sparse_tensor::Merger::simplifyCond()</a>, <a class="el" href="NNZ_8cpp_source.html#l00024">mlir::sparse_tensor::SparseTensorNNZ::SparseTensorNNZ()</a>, <a class="el" href="Storage_8h_source.html#l00990">mlir::sparse_tensor::SparseTensorStorage&lt; P, I, V &gt;::SparseTensorStorage()</a>, and <a class="el" href="Storage_8cpp_source.html#l00027">mlir::sparse_tensor::SparseTensorStorageBase::SparseTensorStorageBase()</a>.</p>

</div>
</div>
<a id="a6ede73c7e40d63418b061d43915fa2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ede73c7e40d63418b061d43915fa2ad">&#9670;&nbsp;</a></span>isDenseDim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::isDenseDim </td>
          <td>(</td>
          <td class="paramtype">RankedTensorType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function to test for dense dimension (0 &lt;= d &lt; rank). </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00064">64</a> of file <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html">SparseTensor.h</a>.</p>

<p class="reference">References <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00049">getDimLevelType()</a>, and <a class="el" href="Enums_8h_source.html#l00175">isDenseDLT()</a>.</p>

</div>
</div>
<a id="a53da6b21ba86f146f692f68f8aebd179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53da6b21ba86f146f692f68f8aebd179">&#9670;&nbsp;</a></span>isDenseDLT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool mlir::sparse_tensor::isDenseDLT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a>&#160;</td>
          <td class="paramname"><em>dlt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the <code>DimLevelType</code> is dense. </p>

<p class="definition">Definition at line <a class="el" href="Enums_8h_source.html#l00175">175</a> of file <a class="el" href="Enums_8h_source.html">Enums.h</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95a9a71a13863c84ba34fc41595fc2ee0c6">Dense</a>.</p>

<p class="reference">Referenced by <a class="el" href="Sparsification_8cpp_source.html#l00253">computeIterationGraph()</a>, <a class="el" href="Merger_8cpp_source.html#l00611">mlir::sparse_tensor::Merger::dumpBits()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00295">mlir::sparse_tensor::SparseTensorLoopEmitter::enterCoIterationOverTensorsAtDims()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00219">mlir::sparse_tensor::SparseTensorLoopEmitter::enterLoopOverTensorAtDim()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00128">findAffine()</a>, <a class="el" href="Sparsification_8cpp_source.html#l01018">genIf()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00131">mlir::sparse_tensor::SparseTensorLoopEmitter::initializeLoopEmit()</a>, <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00064">isDenseDim()</a>, <a class="el" href="Storage_8h_source.html#l00178">mlir::sparse_tensor::SparseTensorStorageBase::isDenseLvl()</a>, <a class="el" href="Merger_8cpp_source.html#l00255">mlir::sparse_tensor::Merger::simplifyCond()</a>, <a class="el" href="NNZ_8cpp_source.html#l00024">mlir::sparse_tensor::SparseTensorNNZ::SparseTensorNNZ()</a>, <a class="el" href="Storage_8h_source.html#l01046">mlir::sparse_tensor::SparseTensorStorage&lt; P, I, V &gt;::SparseTensorStorage()</a>, <a class="el" href="Storage_8cpp_source.html#l00027">mlir::sparse_tensor::SparseTensorStorageBase::SparseTensorStorageBase()</a>, and <a class="el" href="Sparsification_8cpp_source.html#l01125">translateBitsToTidDimPairs()</a>.</p>

</div>
</div>
<a id="acc4b831ac079c00b1124139b41316daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4b831ac079c00b1124139b41316daa">&#9670;&nbsp;</a></span>isFloatingPrimaryType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool mlir::sparse_tensor::isFloatingPrimaryType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904ab">PrimaryType</a>&#160;</td>
          <td class="paramname"><em>valTy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Enums_8h_source.html#l00106">106</a> of file <a class="el" href="Enums_8h_source.html">Enums.h</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904aba7b2caf2ed7b5f4f177fe3207cd198791">kBF16</a>, and <a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904aba5234930e162acb53b17e178221057319">kF64</a>.</p>

<p class="reference">Referenced by <a class="el" href="File_8cpp_source.html#l00092">mlir::sparse_tensor::SparseTensorReader::canReadAs()</a>.</p>

</div>
</div>
<a id="a50f67eed0d8c6d3445a01e5d7cbf9068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f67eed0d8c6d3445a01e5d7cbf9068">&#9670;&nbsp;</a></span>isIntegralPrimaryType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool mlir::sparse_tensor::isIntegralPrimaryType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904ab">PrimaryType</a>&#160;</td>
          <td class="paramname"><em>valTy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Enums_8h_source.html#l00110">110</a> of file <a class="el" href="Enums_8h_source.html">Enums.h</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904aba6601e7b0f7c0f03d9ffa9f222c82e6a0">kI64</a>, and <a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904aba6c86e764d5c427a8339c3920a3c08603">kI8</a>.</p>

</div>
</div>
<a id="a099004ece60c014439943a65128c6a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099004ece60c014439943a65128c6a53">&#9670;&nbsp;</a></span>isOrderedDim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::isOrderedDim </td>
          <td>(</td>
          <td class="paramtype">RankedTensorType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function to test for ordered property in the given dimension (0 &lt;= d &lt; rank). </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00084">84</a> of file <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html">SparseTensor.h</a>.</p>

<p class="reference">References <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00049">getDimLevelType()</a>, and <a class="el" href="Enums_8h_source.html#l00196">isOrderedDLT()</a>.</p>

</div>
</div>
<a id="af7c34ecc544ddda5c59e20acff90a0f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c34ecc544ddda5c59e20acff90a0f6">&#9670;&nbsp;</a></span>isOrderedDLT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool mlir::sparse_tensor::isOrderedDLT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a>&#160;</td>
          <td class="paramname"><em>dlt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the <code>DimLevelType</code> is ordered (regardless of storage format). </p>

<p class="definition">Definition at line <a class="el" href="Enums_8h_source.html#l00196">196</a> of file <a class="el" href="Enums_8h_source.html">Enums.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Merger_8cpp_source.html#l00611">mlir::sparse_tensor::Merger::dumpBits()</a>, <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00084">isOrderedDim()</a>, and <a class="el" href="Storage_8h_source.html#l00191">mlir::sparse_tensor::SparseTensorStorageBase::isOrderedLvl()</a>.</p>

</div>
</div>
<a id="a88824d5d3c576623954852dba07e8c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88824d5d3c576623954852dba07e8c1b">&#9670;&nbsp;</a></span>isRealPrimaryType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool mlir::sparse_tensor::isRealPrimaryType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904ab">PrimaryType</a>&#160;</td>
          <td class="paramname"><em>valTy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Enums_8h_source.html#l00114">114</a> of file <a class="el" href="Enums_8h_source.html">Enums.h</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904aba5234930e162acb53b17e178221057319">kF64</a>, and <a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904aba6c86e764d5c427a8339c3920a3c08603">kI8</a>.</p>

<p class="reference">Referenced by <a class="el" href="File_8cpp_source.html#l00092">mlir::sparse_tensor::SparseTensorReader::canReadAs()</a>.</p>

</div>
</div>
<a id="ae7ed2d091f69fe257113c8e33ea3965f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ed2d091f69fe257113c8e33ea3965f">&#9670;&nbsp;</a></span>isSingletonDim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::isSingletonDim </td>
          <td>(</td>
          <td class="paramtype">RankedTensorType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function to test for singleton dimension (0 &lt;= d &lt; rank). </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00074">74</a> of file <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html">SparseTensor.h</a>.</p>

<p class="reference">References <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00049">getDimLevelType()</a>, and <a class="el" href="Enums_8h_source.html#l00190">isSingletonDLT()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorDialect_8cpp_source.html#l00267">isUniqueCOOType()</a>.</p>

</div>
</div>
<a id="a385e5085ee3fe65734e12c584da4b0e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385e5085ee3fe65734e12c584da4b0e3">&#9670;&nbsp;</a></span>isSingletonDLT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool mlir::sparse_tensor::isSingletonDLT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a>&#160;</td>
          <td class="paramname"><em>dlt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the <code>DimLevelType</code> is singleton (regardless of properties). </p>

<p class="definition">Definition at line <a class="el" href="Enums_8h_source.html#l00190">190</a> of file <a class="el" href="Enums_8h_source.html">Enums.h</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95a6ff5f73c8b5ebd311406568c8ef50bfd">Singleton</a>.</p>

<p class="reference">Referenced by <a class="el" href="Sparsification_8cpp_source.html#l00253">computeIterationGraph()</a>, <a class="el" href="Merger_8cpp_source.html#l00611">mlir::sparse_tensor::Merger::dumpBits()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00295">mlir::sparse_tensor::SparseTensorLoopEmitter::enterCoIterationOverTensorsAtDims()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00219">mlir::sparse_tensor::SparseTensorLoopEmitter::enterLoopOverTensorAtDim()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00927">genFor()</a>, <a class="el" href="Sparsification_8cpp_source.html#l01018">genIf()</a>, <a class="el" href="Merger_8cpp_source.html#l00397">mlir::sparse_tensor::Merger::hasAnySparse()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00131">mlir::sparse_tensor::SparseTensorLoopEmitter::initializeLoopEmit()</a>, <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00074">isSingletonDim()</a>, <a class="el" href="Storage_8h_source.html#l00186">mlir::sparse_tensor::SparseTensorStorageBase::isSingletonLvl()</a>, <a class="el" href="Merger_8cpp_source.html#l00255">mlir::sparse_tensor::Merger::simplifyCond()</a>, <a class="el" href="NNZ_8cpp_source.html#l00024">mlir::sparse_tensor::SparseTensorNNZ::SparseTensorNNZ()</a>, <a class="el" href="Storage_8h_source.html#l00990">mlir::sparse_tensor::SparseTensorStorage&lt; P, I, V &gt;::SparseTensorStorage()</a>, and <a class="el" href="Storage_8cpp_source.html#l00027">mlir::sparse_tensor::SparseTensorStorageBase::SparseTensorStorageBase()</a>.</p>

</div>
</div>
<a id="a758b2c5a8ac259342564d782aa92468f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a758b2c5a8ac259342564d782aa92468f">&#9670;&nbsp;</a></span>isUndefDLT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool mlir::sparse_tensor::isUndefDLT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a>&#160;</td>
          <td class="paramname"><em>dlt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the <code>DimLevelType</code> is the special undefined value. </p>

<p class="definition">Definition at line <a class="el" href="Enums_8h_source.html#l00170">170</a> of file <a class="el" href="Enums_8h_source.html">Enums.h</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95a6bf5613f65a74a7f8388b26adefaef2b">Undef</a>.</p>

<p class="reference">Referenced by <a class="el" href="Sparsification_8cpp_source.html#l00253">computeIterationGraph()</a>, <a class="el" href="Merger_8cpp_source.html#l00611">mlir::sparse_tensor::Merger::dumpBits()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00128">findAffine()</a>, and <a class="el" href="Sparsification_8cpp_source.html#l01018">genIf()</a>.</p>

</div>
</div>
<a id="add4bf0e37a029bc47aec78e748e3d720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4bf0e37a029bc47aec78e748e3d720">&#9670;&nbsp;</a></span>isUniqueCOOType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::isUniqueCOOType </td>
          <td>(</td>
          <td class="paramtype">RankedTensorType&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff the given type is a type for a COO tensor with the last dimension level type being unique. </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorDialect_8cpp_source.html#l00267">267</a> of file <a class="el" href="SparseTensorDialect_8cpp_source.html">SparseTensorDialect.cpp</a>.</p>

<p class="reference">References <a class="el" href="SparseTensorDialect_8cpp_source.html#l00261">getSparseTensorEncoding()</a>, <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00069">isCompressedDim()</a>, <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00074">isSingletonDim()</a>, and <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00090">isUniqueDim()</a>.</p>

</div>
</div>
<a id="a60f63a6540c3dc161f78a48b28d4cfb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f63a6540c3dc161f78a48b28d4cfb6">&#9670;&nbsp;</a></span>isUniqueDim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::isUniqueDim </td>
          <td>(</td>
          <td class="paramtype">RankedTensorType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function to test for unique property in the given dimension (0 &lt;= d &lt; rank). </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00090">90</a> of file <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html">SparseTensor.h</a>.</p>

<p class="reference">References <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00049">getDimLevelType()</a>, and <a class="el" href="Enums_8h_source.html#l00201">isUniqueDLT()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorDialect_8cpp_source.html#l00267">isUniqueCOOType()</a>.</p>

</div>
</div>
<a id="a3e088056a0b56f5542c0fb2c0ece84b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e088056a0b56f5542c0fb2c0ece84b7">&#9670;&nbsp;</a></span>isUniqueDLT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool mlir::sparse_tensor::isUniqueDLT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a>&#160;</td>
          <td class="paramname"><em>dlt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the <code>DimLevelType</code> is unique (regardless of storage format). </p>

<p class="definition">Definition at line <a class="el" href="Enums_8h_source.html#l00201">201</a> of file <a class="el" href="Enums_8h_source.html">Enums.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Merger_8cpp_source.html#l00611">mlir::sparse_tensor::Merger::dumpBits()</a>, <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00090">isUniqueDim()</a>, and <a class="el" href="Storage_8h_source.html#l00194">mlir::sparse_tensor::SparseTensorStorageBase::isUniqueLvl()</a>.</p>

</div>
</div>
<a id="a35657d6b2ffc036a0c4a5b2e598d78e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35657d6b2ffc036a0c4a5b2e598d78e4">&#9670;&nbsp;</a></span>isValidDLT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool mlir::sparse_tensor::isValidDLT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a>&#160;</td>
          <td class="paramname"><em>dlt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check that the <code>DimLevelType</code> contains a valid (possibly undefined) value. </p>

<p class="definition">Definition at line <a class="el" href="Enums_8h_source.html#l00160">160</a> of file <a class="el" href="Enums_8h_source.html">Enums.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Merger_8h_source.html#l00274">mlir::sparse_tensor::Merger::setDimAndDimLevelType()</a>.</p>

</div>
</div>
<a id="aa9cfbb689a6cf4c8f4cfdf898cb890d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9cfbb689a6cf4c8f4cfdf898cb890d1">&#9670;&nbsp;</a></span>isZeroRankedTensorOrScalar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::isZeroRankedTensorOrScalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8h_source.html#l00308">308</a> of file <a class="el" href="CodegenUtils_8h_source.html">CodegenUtils.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00270">mlir::Type::dyn_cast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenUtils_8cpp_source.html#l00097">mlir::sparse_tensor::SparseTensorLoopEmitter::SparseTensorLoopEmitter()</a>.</p>

</div>
</div>
<a id="ac96ea63ce869d935187f89d784ec278a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96ea63ce869d935187f89d784ec278a">&#9670;&nbsp;</a></span>kindToOpSymbol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char* mlir::sparse_tensor::kindToOpSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a1ab3a6a8f6871198b20d1e93409a473f">Kind</a>&#160;</td>
          <td class="paramname"><em>kind</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Merger_8cpp_source.html#l00411">411</a> of file <a class="el" href="Merger_8cpp_source.html">Merger.cpp</a>.</p>

</div>
</div>
<a id="a7e5d36728b86ed186caf97cf89d6436f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e5d36728b86ed186caf97cf89d6436f">&#9670;&nbsp;</a></span>openSparseTensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P , typename I , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html">SparseTensorStorage</a>&lt;P, I, V&gt;* mlir::sparse_tensor::openSparseTensor </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>dimRank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>dimShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lvlRank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a> *&#160;</td>
          <td class="paramname"><em>lvlTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>lvl2dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>dim2lvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904ab">PrimaryType</a>&#160;</td>
          <td class="paramname"><em>valTp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a sparse tensor with the given filename into a memory-resident sparse tensor. </p>
<p>Preconditions:</p><ul>
<li><code>dimShape</code> and <code>dim2lvl</code> must be valid for <code>dimRank</code>.</li>
<li><code>lvlTypes</code> and <code>lvl2dim</code> must be valid for <code>lvlRank</code>.</li>
<li><code>dim2lvl</code> is the inverse of <code>lvl2dim</code>.</li>
</ul>
<p>Asserts:</p><ul>
<li>the file's actual value type can be read as <code>valTp</code>.</li>
<li>the file's actual dimension-sizes match the expected <code>dimShape</code>.</li>
<li><code>dim2lvl</code> is a permutation, and therefore also <code>dimRank == lvlRank</code>. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="File_8h_source.html#l00235">235</a> of file <a class="el" href="File_8h_source.html">File.h</a>.</p>

<p class="reference">References <a class="el" href="File_8cpp_source.html#l00084">mlir::sparse_tensor::SparseTensorReader::assertMatchesShape()</a>, <a class="el" href="File_8cpp_source.html#l00092">mlir::sparse_tensor::SparseTensorReader::canReadAs()</a>, <a class="el" href="File_8h_source.html#l00158">mlir::sparse_tensor::SparseTensorReader::getDimSizes()</a>, <a class="el" href="File_8h_source.html#l00150">mlir::sparse_tensor::SparseTensorReader::getNNZ()</a>, <a class="el" href="File_8h_source.html#l00138">mlir::sparse_tensor::SparseTensorReader::isSymmetric()</a>, <a class="el" href="ErrorHandling_8h_source.html#l00037">MLIR_SPARSETENSOR_FATAL</a>, <a class="el" href="File_8cpp_source.html#l00034">mlir::sparse_tensor::SparseTensorReader::openFile()</a>, <a class="el" href="PermutationRef_8h_source.html#l00080">mlir::sparse_tensor::detail::PermutationRef::pushforward()</a>, <a class="el" href="File_8h_source.html#l00175">mlir::sparse_tensor::SparseTensorReader::readCOOElement()</a>, <a class="el" href="File_8cpp_source.html#l00071">mlir::sparse_tensor::SparseTensorReader::readHeader()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00160">value</a>.</p>

</div>
</div>
<a id="a9cb02cd2b1f8b3829133f8e05456ece9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb02cd2b1f8b3829133f8e05456ece9">&#9670;&nbsp;</a></span>overheadTypeEncoding() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60">OverheadType</a> mlir::sparse_tensor::overheadTypeEncoding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an overhead storage type to its internal type-encoding. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l00639">639</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00270">mlir::Type::dyn_cast()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00030">mlir::Type::isIndex()</a>, <a class="el" href="Merger_8h_source.html#l00029">kIndex</a>, and <a class="el" href="CodegenUtils_8cpp_source.html#l00623">overheadTypeEncoding()</a>.</p>

</div>
</div>
<a id="a5913d5a1d9ef325b2c8c2a8b70843714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5913d5a1d9ef325b2c8c2a8b70843714">&#9670;&nbsp;</a></span>overheadTypeEncoding() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60">OverheadType</a> mlir::sparse_tensor::overheadTypeEncoding </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an overhead storage bitwidth to its internal type-encoding. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l00623">623</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Merger_8h_source.html#l00029">kIndex</a>, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60a9070b7eed719acaf36119d4a2835a230">kU16</a>, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60a4f2abe781a12702f9fbaea79fb6ba042">kU32</a>, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60a6256cfbcd370939b8454d9eca86b9d2a">kU64</a>, and <a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60aeda0b712c7690a5c8921fa54baad333e">kU8</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenUtils_8h_source.html#l00275">constantOverheadTypeEncoding()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00668">indexOverheadTypeEncoding()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00639">overheadTypeEncoding()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00700">overheadTypeFunctionSuffix()</a>, and <a class="el" href="CodegenUtils_8cpp_source.html#l00663">pointerOverheadTypeEncoding()</a>.</p>

</div>
</div>
<a id="a68fb99cb0b7e9f6787952299a59609a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68fb99cb0b7e9f6787952299a59609a7">&#9670;&nbsp;</a></span>overheadTypeFunctionSuffix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef mlir::sparse_tensor::overheadTypeFunctionSuffix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60">OverheadType</a>&#160;</td>
          <td class="paramname"><em>ot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert OverheadType to its function-name suffix. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l00687">687</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="CodegenUtils_8cpp.html#a074d2f55c1563a936d9fae76b065d837">CASE</a>, <a class="el" href="Merger_8h_source.html#l00029">kIndex</a>, and <a class="el" href="Enums_8h_source.html#l00061">MLIR_SPARSETENSOR_FOREVERY_FIXED_O</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenUtils_8cpp_source.html#l00700">overheadTypeFunctionSuffix()</a>.</p>

</div>
</div>
<a id="afebb2dcb33c43b890cb719a500d22077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afebb2dcb33c43b890cb719a500d22077">&#9670;&nbsp;</a></span>overheadTypeFunctionSuffix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef mlir::sparse_tensor::overheadTypeFunctionSuffix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>overheadTp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an overhead storage type to its function-name suffix. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l00700">700</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="CodegenUtils_8cpp_source.html#l00623">overheadTypeEncoding()</a>, and <a class="el" href="CodegenUtils_8cpp_source.html#l00687">overheadTypeFunctionSuffix()</a>.</p>

</div>
</div>
<a id="ac2dedb0a54f00537cf8ce6577617f311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2dedb0a54f00537cf8ce6577617f311">&#9670;&nbsp;</a></span>pointerOverheadTypeEncoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60">OverheadType</a> mlir::sparse_tensor::pointerOverheadTypeEncoding </td>
          <td>(</td>
          <td class="paramtype">const SparseTensorEncodingAttr &amp;&#160;</td>
          <td class="paramname"><em>enc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the OverheadType for pointer overhead storage. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l00663">663</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="CodegenUtils_8cpp_source.html#l00623">overheadTypeEncoding()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenUtils_8cpp_source.html#l00673">getPointerOverheadType()</a>.</p>

</div>
</div>
<a id="a79d245959cdf73b056ffaefe11aee733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d245959cdf73b056ffaefe11aee733">&#9670;&nbsp;</a></span>primaryTypeEncoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904ab">PrimaryType</a> mlir::sparse_tensor::primaryTypeEncoding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>elemTp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a primary storage type to its internal type-encoding. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l00704">704</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00270">mlir::Type::dyn_cast()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00023">mlir::Type::isBF16()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00024">mlir::Type::isF16()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00025">mlir::Type::isF32()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00026">mlir::Type::isF64()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00033">mlir::Type::isInteger()</a>, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904aba7b2caf2ed7b5f4f177fe3207cd198791">kBF16</a>, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904abaec949612bf882299f31abe2c9e57fe3b">kC32</a>, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904abab669ff1c81c4c96d8631985f992cb07c">kC64</a>, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904aba13a852aa20c7c1030c7d2588b5d799b6">kF16</a>, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904aba941c992a0e3d2eb28203202730996ba2">kF32</a>, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904aba5234930e162acb53b17e178221057319">kF64</a>, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904aba1201e21104cbb7ea3a7c362efcb325a3">kI16</a>, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904aba0a0ecdb4eded286c722877578774a293">kI32</a>, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904aba6601e7b0f7c0f03d9ffa9f222c82e6a0">kI64</a>, and <a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904aba6c86e764d5c427a8339c3920a3c08603">kI8</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenUtils_8h_source.html#l00296">constantPrimaryTypeEncoding()</a>, and <a class="el" href="CodegenUtils_8cpp_source.html#l00742">primaryTypeFunctionSuffix()</a>.</p>

</div>
</div>
<a id="adb262d6ac8ec2bb016263171b219d769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb262d6ac8ec2bb016263171b219d769">&#9670;&nbsp;</a></span>primaryTypeFunctionSuffix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef mlir::sparse_tensor::primaryTypeFunctionSuffix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904ab">PrimaryType</a>&#160;</td>
          <td class="paramname"><em>pt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert PrimaryType to its function-name suffix. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l00731">731</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="CodegenUtils_8cpp.html#a074d2f55c1563a936d9fae76b065d837">CASE</a>, and <a class="el" href="Enums_8h_source.html#l00094">MLIR_SPARSETENSOR_FOREVERY_V</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenUtils_8cpp_source.html#l00742">primaryTypeFunctionSuffix()</a>.</p>

</div>
</div>
<a id="a1d775351105b6d20ac0ec4712b14c4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d775351105b6d20ac0ec4712b14c4ab">&#9670;&nbsp;</a></span>primaryTypeFunctionSuffix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef mlir::sparse_tensor::primaryTypeFunctionSuffix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>elemTp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a primary storage type to its function-name suffix. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l00742">742</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="CodegenUtils_8cpp_source.html#l00704">primaryTypeEncoding()</a>, and <a class="el" href="CodegenUtils_8cpp_source.html#l00731">primaryTypeFunctionSuffix()</a>.</p>

</div>
</div>
<a id="a06ca39df6906707b01c4265328cd9679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ca39df6906707b01c4265328cd9679">&#9670;&nbsp;</a></span>registerBufferizableOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::sparse_tensor::registerBufferizableOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseTensor_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00130">130</a> of file <a class="el" href="SparseTensor_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html">BufferizableOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00179">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllDialects_8h_source.html#l00075">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="aa4da76a5082524bd625e709b005d93d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4da76a5082524bd625e709b005d93d7">&#9670;&nbsp;</a></span>registerSparseTensorPipelines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::sparse_tensor::registerSparseTensorPipelines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers all pipelines for the <code><a class="el" href="namespacemlir_1_1sparse__tensor.html">sparse_tensor</a></code> dialect. </p>
<p>At present, this includes only "sparse-compiler". </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00099">99</a> of file <a class="el" href="SparseTensorPipelines_8cpp_source.html">SparseTensorPipelines.cpp</a>.</p>

<p class="reference">References <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00052">buildSparseCompiler()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllPasses_8h_source.html#l00050">mlir::registerAllPasses()</a>.</p>

</div>
</div>
<a id="ae5700bf1db7b95b281f7c320acd94d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5700bf1db7b95b281f7c320acd94d06">&#9670;&nbsp;</a></span>sizesFromSrc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::sparse_tensor::sizesFromSrc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates given sizes array from dense tensor or sparse tensor constant. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l01010">1010</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00280">mlir::Type::cast()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00199">mlir::linalg::createOrFoldDimOp()</a>, and <a class="el" href="Value_8h_source.html#l00114">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="afcfdd4dbf441be82f8f9e041389befad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcfdd4dbf441be82f8f9e041389befad">&#9670;&nbsp;</a></span>toOrigDim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mlir::sparse_tensor::toOrigDim </td>
          <td>(</td>
          <td class="paramtype">const SparseTensorEncodingAttr &amp;&#160;</td>
          <td class="paramname"><em>enc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseTensorDialect_8cpp_source.html#l00285">285</a> of file <a class="el" href="SparseTensorDialect_8cpp_source.html">SparseTensorDialect.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Sparsification_8cpp_source.html#l00253">computeIterationGraph()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00163">findSparseAnnotations()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00521">genIndex()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00801">genInvariants()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00531">genSubscript()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00131">mlir::sparse_tensor::SparseTensorLoopEmitter::initializeLoopEmit()</a>, and <a class="el" href="SparseTensorDialect_8cpp_source.html#l00309">toOrigDim()</a>.</p>

</div>
</div>
<a id="a94b360a25d718e3192af7b9b6b127265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b360a25d718e3192af7b9b6b127265">&#9670;&nbsp;</a></span>toOrigDim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mlir::sparse_tensor::toOrigDim </td>
          <td>(</td>
          <td class="paramtype">RankedTensorType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to translate the given stored dimension to the original dimension (0 &lt;= d &lt; rank). </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorDialect_8cpp_source.html#l00309">309</a> of file <a class="el" href="SparseTensorDialect_8cpp_source.html">SparseTensorDialect.cpp</a>.</p>

<p class="reference">References <a class="el" href="SparseTensorDialect_8cpp_source.html#l00261">getSparseTensorEncoding()</a>, and <a class="el" href="SparseTensorDialect_8cpp_source.html#l00285">toOrigDim()</a>.</p>

</div>
</div>
<a id="a44c28abb51adf08fbddf9438bb065b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c28abb51adf08fbddf9438bb065b9f">&#9670;&nbsp;</a></span>toStoredDim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mlir::sparse_tensor::toStoredDim </td>
          <td>(</td>
          <td class="paramtype">const SparseTensorEncodingAttr &amp;&#160;</td>
          <td class="paramname"><em>enc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SparseTensorDialect_8cpp_source.html#l00297">297</a> of file <a class="el" href="SparseTensorDialect_8cpp_source.html">SparseTensorDialect.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorDialect_8cpp_source.html#l00314">toStoredDim()</a>.</p>

</div>
</div>
<a id="ae8026875808e383149220916e5ec95a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8026875808e383149220916e5ec95a3">&#9670;&nbsp;</a></span>toStoredDim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mlir::sparse_tensor::toStoredDim </td>
          <td>(</td>
          <td class="paramtype">RankedTensorType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to translate the given original dimension to the stored dimension (0 &lt;= d &lt; rank). </p>

<p class="definition">Definition at line <a class="el" href="SparseTensorDialect_8cpp_source.html#l00314">314</a> of file <a class="el" href="SparseTensorDialect_8cpp_source.html">SparseTensorDialect.cpp</a>.</p>

<p class="reference">References <a class="el" href="SparseTensorDialect_8cpp_source.html#l00261">getSparseTensorEncoding()</a>, and <a class="el" href="SparseTensorDialect_8cpp_source.html#l00297">toStoredDim()</a>.</p>

</div>
</div>
<a id="a05178ffe7b3e43fbafdc8a7ad544f98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05178ffe7b3e43fbafdc8a7ad544f98f">&#9670;&nbsp;</a></span>translateIndicesArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::sparse_tensor::translateIndicesArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>srcIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>srcShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>dstShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dstIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate indices during a reshaping operation. </p>

<p class="definition">Definition at line <a class="el" href="CodegenUtils_8cpp_source.html#l00836">836</a> of file <a class="el" href="CodegenUtils_8cpp_source.html">CodegenUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="CodegenUtils_8h_source.html#l00245">constantIndex()</a>, <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, and <a class="el" href="Matchers_8h_source.html#l00230">mlir::detail::enumerate()</a>.</p>

</div>
</div>
<a id="a7594193c77060167b3c47d127f131194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7594193c77060167b3c47d127f131194">&#9670;&nbsp;</a></span>writeExtFROSTT()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::sparse_tensor::writeExtFROSTT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorCOO.html">SparseTensorCOO</a>&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>coo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the sparse tensor to <code>filename</code> in extended FROSTT format. </p>

<p class="definition">Definition at line <a class="el" href="File_8h_source.html#l00282">282</a> of file <a class="el" href="File_8h_source.html">File.h</a>.</p>

<p class="reference">References <a class="el" href="COO_8h_source.html#l00143">mlir::sparse_tensor::SparseTensorCOO&lt; V &gt;::getDimSizes()</a>, <a class="el" href="COO_8h_source.html#l00146">mlir::sparse_tensor::SparseTensorCOO&lt; V &gt;::getElements()</a>, and <a class="el" href="COO_8h_source.html#l00140">mlir::sparse_tensor::SparseTensorCOO&lt; V &gt;::getRank()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 17 2022 20:37:51 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
