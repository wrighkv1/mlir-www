<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::spirv Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">16.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1spirv.html">spirv</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">mlir::spirv Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1spirv_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1MemorySpaceToStorageClassConverter.html">MemorySpaceToStorageClassConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> converter for converting numeric MemRef memory spaces into SPIR-V symbolic ones.  <a href="classmlir_1_1spirv_1_1MemorySpaceToStorageClassConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1InterfaceVarABIAttr.html">InterfaceVarABIAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that specifies the information regarding the interface variable: descriptor set, binding, storage class.  <a href="classmlir_1_1spirv_1_1InterfaceVarABIAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1VerCapExtAttr.html">VerCapExtAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that specifies the SPIR-V (version, capabilities, extensions) triple.  <a href="classmlir_1_1spirv_1_1VerCapExtAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">TargetEnvAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that specifies the target version, allowed extensions and capabilities, and resource limits.  <a href="classmlir_1_1spirv_1_1TargetEnvAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1SPIRVType.html">SPIRVType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1ScalarType.html">ScalarType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1CompositeType.html">CompositeType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1ArrayType.html">ArrayType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1ImageType.html">ImageType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1PointerType.html">PointerType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1RuntimeArrayType.html">RuntimeArrayType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1SampledImageType.html">SampledImageType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1StructType.html">StructType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPIR-V struct type.  <a href="classmlir_1_1spirv_1_1StructType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1CooperativeMatrixNVType.html">CooperativeMatrixNVType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1JointMatrixINTELType.html">JointMatrixINTELType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1MatrixType.html">MatrixType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1TargetEnv.html">TargetEnv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper class around a <a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html" title="An attribute that specifies the target version, allowed extensions and capabilities,...">spirv::TargetEnvAttr</a> to provide query methods for allowed version/capabilities/extensions.  <a href="classmlir_1_1spirv_1_1TargetEnv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1spirv_1_1SerializationOptions.html">SerializationOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1spirv_1_1ElementwiseOpPattern.html">ElementwiseOpPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts elementwise unary, binary and ternary standard operations to SPIR-V operations.  <a href="structmlir_1_1spirv_1_1ElementwiseOpPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1spirv_1_1BlockMergeInfo.html">BlockMergeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct for containing a header block's merge and continue targets.  <a href="structmlir_1_1spirv_1_1BlockMergeInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1spirv_1_1DebugLine.html">DebugLine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct for containing OpLine instruction information.  <a href="structmlir_1_1spirv_1_1DebugLine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1spirv_1_1DeferredStructTypeInfo.html">DeferredStructTypeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A "deferred struct type" is a struct type with one or more member types not known when the <a class="el" href="classmlir_1_1spirv_1_1Deserializer.html" title="A SPIR-V module serializer.">Deserializer</a> first encounters the struct.  <a href="structmlir_1_1spirv_1_1DeferredStructTypeInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1spirv_1_1SpecConstOperationMaterializationInfo.html">SpecConstOperationMaterializationInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct that collects the info needed to materialize/emit a SpecConstantOperation op.  <a href="structmlir_1_1spirv_1_1SpecConstOperationMaterializationInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1Deserializer.html">Deserializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A SPIR-V module serializer.  <a href="classmlir_1_1spirv_1_1Deserializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1spirv_1_1Serializer.html">Serializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A SPIR-V module serializer.  <a href="classmlir_1_1spirv_1_1Serializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8c7c1526971652a9456ea3fadb73c0af"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a8c7c1526971652a9456ea3fadb73c0af">MemorySpaceToStorageClassMap</a> = std::function&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; spirv::StorageClass &gt;(unsigned)&gt;</td></tr>
<tr class="memdesc:a8c7c1526971652a9456ea3fadb73c0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping from numeric MemRef memory spaces into SPIR-V symbolic ones.  <a href="namespacemlir_1_1spirv.html#a8c7c1526971652a9456ea3fadb73c0af">More...</a><br /></td></tr>
<tr class="separator:a8c7c1526971652a9456ea3fadb73c0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac1b5d87a905e6e58d061fca3c4b9c2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#acac1b5d87a905e6e58d061fca3c4b9c2">SymbolRenameListener</a> = <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(spirv::ModuleOp originalModule, StringRef oldSymbol, StringRef newSymbol)&gt;</td></tr>
<tr class="memdesc:acac1b5d87a905e6e58d061fca3c4b9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The listener function to receive symbol renaming events.  <a href="namespacemlir_1_1spirv.html#acac1b5d87a905e6e58d061fca3c4b9c2">More...</a><br /></td></tr>
<tr class="separator:acac1b5d87a905e6e58d061fca3c4b9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738af61310165c2eb21778ca20406b6a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a738af61310165c2eb21778ca20406b6a">GetTargetEnvFn</a> = std::function&lt; <a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">spirv::TargetEnvAttr</a>(spirv::ModuleOp)&gt;</td></tr>
<tr class="memdesc:a738af61310165c2eb21778ca20406b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an operation pass that unifies access of multiple aliased resources into access of one single resource.  <a href="namespacemlir_1_1spirv.html#a738af61310165c2eb21778ca20406b6a">More...</a><br /></td></tr>
<tr class="separator:a738af61310165c2eb21778ca20406b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd480fdd0d8fb515c1419293ce3c0e4c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#acd480fdd0d8fb515c1419293ce3c0e4c">BlockMergeInfoMap</a> = <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; <a class="el" href="classmlir_1_1Block.html">Block</a> *, <a class="el" href="structmlir_1_1spirv_1_1BlockMergeInfo.html">BlockMergeInfo</a> &gt;</td></tr>
<tr class="memdesc:acd480fdd0d8fb515c1419293ce3c0e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map from a selection/loop's header block to its merge (and continue) target.  <a href="namespacemlir_1_1spirv.html#acd480fdd0d8fb515c1419293ce3c0e4c">More...</a><br /></td></tr>
<tr class="separator:acd480fdd0d8fb515c1419293ce3c0e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6c12269dafa2f03a9dfb3d1b8b8e62c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; spirv::StorageClass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a6c12269dafa2f03a9dfb3d1b8b8e62c7">mapMemorySpaceToVulkanStorageClass</a> (unsigned)</td></tr>
<tr class="memdesc:a6c12269dafa2f03a9dfb3d1b8b8e62c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps MemRef memory spaces to storage classes for Vulkan-flavored SPIR-V using the default rule.  <a href="namespacemlir_1_1spirv.html#a6c12269dafa2f03a9dfb3d1b8b8e62c7">More...</a><br /></td></tr>
<tr class="separator:a6c12269dafa2f03a9dfb3d1b8b8e62c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a90cd07b1ac0fca0c4100768b74b7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a40a90cd07b1ac0fca0c4100768b74b7e">mapVulkanStorageClassToMemorySpace</a> (spirv::StorageClass)</td></tr>
<tr class="memdesc:a40a90cd07b1ac0fca0c4100768b74b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps storage classes for Vulkan-flavored SPIR-V to MemRef memory spaces using the default rule.  <a href="namespacemlir_1_1spirv.html#a40a90cd07b1ac0fca0c4100768b74b7e">More...</a><br /></td></tr>
<tr class="separator:a40a90cd07b1ac0fca0c4100768b74b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac0b925a72437614eefd91e7f89540f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; spirv::StorageClass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#abac0b925a72437614eefd91e7f89540f">mapMemorySpaceToOpenCLStorageClass</a> (unsigned)</td></tr>
<tr class="memdesc:abac0b925a72437614eefd91e7f89540f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps MemRef memory spaces to storage classes for OpenCL-flavored SPIR-V using the default rule.  <a href="namespacemlir_1_1spirv.html#abac0b925a72437614eefd91e7f89540f">More...</a><br /></td></tr>
<tr class="separator:abac0b925a72437614eefd91e7f89540f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79bf721594b63e9d31bed5988e2fff0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ae79bf721594b63e9d31bed5988e2fff0">mapOpenCLStorageClassToMemorySpace</a> (spirv::StorageClass)</td></tr>
<tr class="memdesc:ae79bf721594b63e9d31bed5988e2fff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps storage classes for OpenCL-flavored SPIR-V to MemRef memory spaces using the default rule.  <a href="namespacemlir_1_1spirv.html#ae79bf721594b63e9d31bed5988e2fff0">More...</a><br /></td></tr>
<tr class="separator:ae79bf721594b63e9d31bed5988e2fff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20da364acf11b2fc680395daeeca97fc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a20da364acf11b2fc680395daeeca97fc">getMemorySpaceToStorageClassTarget</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;)</td></tr>
<tr class="memdesc:a20da364acf11b2fc680395daeeca97fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the target that populates legality of ops with MemRef types.  <a href="namespacemlir_1_1spirv.html#a20da364acf11b2fc680395daeeca97fc">More...</a><br /></td></tr>
<tr class="separator:a20da364acf11b2fc680395daeeca97fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0c9c44e47162a7027a178f81a20270"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a5a0c9c44e47162a7027a178f81a20270">populateMemorySpaceToStorageClassPatterns</a> (<a class="el" href="classmlir_1_1spirv_1_1MemorySpaceToStorageClassConverter.html">MemorySpaceToStorageClassConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a5a0c9c44e47162a7027a178f81a20270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for converting numeric MemRef memory spaces into SPIR-V symbolic ones.  <a href="namespacemlir_1_1spirv.html#a5a0c9c44e47162a7027a178f81a20270">More...</a><br /></td></tr>
<tr class="separator:a5a0c9c44e47162a7027a178f81a20270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebec54b6a40e0cb8f2c7d3640663be4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; Extension &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a2ebec54b6a40e0cb8f2c7d3640663be4">getImpliedExtensions</a> (Version version)</td></tr>
<tr class="memdesc:a2ebec54b6a40e0cb8f2c7d3640663be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the implied extensions for the given version.  <a href="namespacemlir_1_1spirv.html#a2ebec54b6a40e0cb8f2c7d3640663be4">More...</a><br /></td></tr>
<tr class="separator:a2ebec54b6a40e0cb8f2c7d3640663be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6686e4cb7cffae099e00c124e04d5420"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; Capability &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a6686e4cb7cffae099e00c124e04d5420">getDirectImpliedCapabilities</a> (Capability cap)</td></tr>
<tr class="memdesc:a6686e4cb7cffae099e00c124e04d5420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the directly implied capabilities for the given capability.  <a href="namespacemlir_1_1spirv.html#a6686e4cb7cffae099e00c124e04d5420">More...</a><br /></td></tr>
<tr class="separator:a6686e4cb7cffae099e00c124e04d5420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d09788a1496828ace197176ce75e3d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; Capability, 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a1d09788a1496828ace197176ce75e3d9">getRecursiveImpliedCapabilities</a> (Capability cap)</td></tr>
<tr class="memdesc:a1d09788a1496828ace197176ce75e3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the recursively implied capabilities for the given capability.  <a href="namespacemlir_1_1spirv.html#a1d09788a1496828ace197176ce75e3d9">More...</a><br /></td></tr>
<tr class="separator:a1d09788a1496828ace197176ce75e3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765253a5d5815369244e7a4918fa1b89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a765253a5d5815369244e7a4918fa1b89">populateSPIRVGLCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;results)</td></tr>
<tr class="memdesc:a765253a5d5815369244e7a4918fa1b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns to run canoncalization that involves GL ops.  <a href="namespacemlir_1_1spirv.html#a765253a5d5815369244e7a4918fa1b89">More...</a><br /></td></tr>
<tr class="separator:a765253a5d5815369244e7a4918fa1b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c084c603df48bd16083158d58760c9"><td class="memItemLeft" align="right" valign="top">llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a46c084c603df48bd16083158d58760c9">hash_value</a> (const <a class="el" href="structmlir_1_1spirv_1_1StructType_1_1MemberDecorationInfo.html">StructType::MemberDecorationInfo</a> &amp;memberDecorationInfo)</td></tr>
<tr class="separator:a46c084c603df48bd16083158d58760c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084723c4d96882caa7edd6bfc3dfe1d0"><td class="memItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a084723c4d96882caa7edd6bfc3dfe1d0">getInterfaceVarABIAttrName</a> ()</td></tr>
<tr class="memdesc:a084723c4d96882caa7edd6bfc3dfe1d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the attribute name for specifying argument ABI information.  <a href="namespacemlir_1_1spirv.html#a084723c4d96882caa7edd6bfc3dfe1d0">More...</a><br /></td></tr>
<tr class="separator:a084723c4d96882caa7edd6bfc3dfe1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60cb9b4c0712f47e2e1a0e74103826a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1spirv_1_1InterfaceVarABIAttr.html">InterfaceVarABIAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ae60cb9b4c0712f47e2e1a0e74103826a">getInterfaceVarABIAttr</a> (unsigned descriptorSet, unsigned binding, <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; StorageClass &gt; storageClass, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ae60cb9b4c0712f47e2e1a0e74103826a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="classmlir_1_1spirv_1_1InterfaceVarABIAttr.html" title="An attribute that specifies the information regarding the interface variable: descriptor set,...">InterfaceVarABIAttr</a> given its fields.  <a href="namespacemlir_1_1spirv.html#ae60cb9b4c0712f47e2e1a0e74103826a">More...</a><br /></td></tr>
<tr class="separator:ae60cb9b4c0712f47e2e1a0e74103826a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f116e5f53987bfcf7bfb81faba201e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a1f116e5f53987bfcf7bfb81faba201e3">needsInterfaceVarABIAttrs</a> (<a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">TargetEnvAttr</a> targetAttr)</td></tr>
<tr class="memdesc:a1f116e5f53987bfcf7bfb81faba201e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given SPIR-V target (described by <a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html" title="An attribute that specifies the target version, allowed extensions and capabilities,...">TargetEnvAttr</a>) needs ABI attributes for interface variables (spirv.interface_var_abi).  <a href="namespacemlir_1_1spirv.html#a1f116e5f53987bfcf7bfb81faba201e3">More...</a><br /></td></tr>
<tr class="separator:a1f116e5f53987bfcf7bfb81faba201e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecdb10932f9d700379ed74c9df04e530"><td class="memItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#aecdb10932f9d700379ed74c9df04e530">getEntryPointABIAttrName</a> ()</td></tr>
<tr class="memdesc:aecdb10932f9d700379ed74c9df04e530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the attribute name for specifying entry point information.  <a href="namespacemlir_1_1spirv.html#aecdb10932f9d700379ed74c9df04e530">More...</a><br /></td></tr>
<tr class="separator:aecdb10932f9d700379ed74c9df04e530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab474762031def1b0f3380d6d58a7e326"><td class="memItemLeft" align="right" valign="top">EntryPointABIAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ab474762031def1b0f3380d6d58a7e326">getEntryPointABIAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int32_t &gt; localSize, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ab474762031def1b0f3380d6d58a7e326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the EntryPointABIAttr given its fields.  <a href="namespacemlir_1_1spirv.html#ab474762031def1b0f3380d6d58a7e326">More...</a><br /></td></tr>
<tr class="separator:ab474762031def1b0f3380d6d58a7e326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a2cd4522a0c39add4adcd2db5fe8fc"><td class="memItemLeft" align="right" valign="top">EntryPointABIAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a56a2cd4522a0c39add4adcd2db5fe8fc">lookupEntryPointABI</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a56a2cd4522a0c39add4adcd2db5fe8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the entry point ABI on the nearest function-like op containing the given <code>op</code>.  <a href="namespacemlir_1_1spirv.html#a56a2cd4522a0c39add4adcd2db5fe8fc">More...</a><br /></td></tr>
<tr class="separator:a56a2cd4522a0c39add4adcd2db5fe8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe035dc50594dd3b9d3c270a1f1959fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#afe035dc50594dd3b9d3c270a1f1959fa">lookupLocalWorkGroupSize</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:afe035dc50594dd3b9d3c270a1f1959fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the local workgroup size from entry point ABI on the nearest function-like op containing the given <code>op</code>.  <a href="namespacemlir_1_1spirv.html#afe035dc50594dd3b9d3c270a1f1959fa">More...</a><br /></td></tr>
<tr class="separator:afe035dc50594dd3b9d3c270a1f1959fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f2ff3fa9b623a0a6fa86ac75af3f4d"><td class="memItemLeft" align="right" valign="top">ResourceLimitsAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ae1f2ff3fa9b623a0a6fa86ac75af3f4d">getDefaultResourceLimits</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ae1f2ff3fa9b623a0a6fa86ac75af3f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a default resource limits attribute that uses numbers from "Table 46. Required Limits" of the Vulkan spec.  <a href="namespacemlir_1_1spirv.html#ae1f2ff3fa9b623a0a6fa86ac75af3f4d">More...</a><br /></td></tr>
<tr class="separator:ae1f2ff3fa9b623a0a6fa86ac75af3f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7980ee0979f2d8550c4c1b941523f0c5"><td class="memItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a7980ee0979f2d8550c4c1b941523f0c5">getTargetEnvAttrName</a> ()</td></tr>
<tr class="memdesc:a7980ee0979f2d8550c4c1b941523f0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the attribute name for specifying SPIR-V target environment.  <a href="namespacemlir_1_1spirv.html#a7980ee0979f2d8550c4c1b941523f0c5">More...</a><br /></td></tr>
<tr class="separator:a7980ee0979f2d8550c4c1b941523f0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb49fbe2ae3a33a6f06fcc29a3698ac2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">TargetEnvAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#aeb49fbe2ae3a33a6f06fcc29a3698ac2">getDefaultTargetEnv</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:aeb49fbe2ae3a33a6f06fcc29a3698ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the default target environment: SPIR-V 1.0 with Shader capability and no extra extensions.  <a href="namespacemlir_1_1spirv.html#aeb49fbe2ae3a33a6f06fcc29a3698ac2">More...</a><br /></td></tr>
<tr class="separator:aeb49fbe2ae3a33a6f06fcc29a3698ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b51f6bb34187b8de569585d635a9eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">TargetEnvAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a78b51f6bb34187b8de569585d635a9eb">lookupTargetEnv</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a78b51f6bb34187b8de569585d635a9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the target environment recursively from enclosing symbol table ops containing the given <code>op</code>.  <a href="namespacemlir_1_1spirv.html#a78b51f6bb34187b8de569585d635a9eb">More...</a><br /></td></tr>
<tr class="separator:a78b51f6bb34187b8de569585d635a9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae1ed3e62618274db5bad38955db408"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">TargetEnvAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a2ae1ed3e62618274db5bad38955db408">lookupTargetEnvOrDefault</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a2ae1ed3e62618274db5bad38955db408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the target environment recursively from enclosing symbol table ops containing the given <code>op</code> or returns the default target environment as returned by <a class="el" href="namespacemlir_1_1spirv.html#aeb49fbe2ae3a33a6f06fcc29a3698ac2" title="Returns the default target environment: SPIR-V 1.0 with Shader capability and no extra extensions.">getDefaultTargetEnv()</a> if not provided.  <a href="namespacemlir_1_1spirv.html#a2ae1ed3e62618274db5bad38955db408">More...</a><br /></td></tr>
<tr class="separator:a2ae1ed3e62618274db5bad38955db408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17523f6494ead17ffb9559789d9629a"><td class="memItemLeft" align="right" valign="top">AddressingModel&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ac17523f6494ead17ffb9559789d9629a">getAddressingModel</a> (<a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">TargetEnvAttr</a> targetAttr)</td></tr>
<tr class="memdesc:ac17523f6494ead17ffb9559789d9629a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns addressing model selected based on target environment.  <a href="namespacemlir_1_1spirv.html#ac17523f6494ead17ffb9559789d9629a">More...</a><br /></td></tr>
<tr class="separator:ac17523f6494ead17ffb9559789d9629a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcd79b9cf8b161f54bf1ed72ee71887"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; ExecutionModel &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#abdcd79b9cf8b161f54bf1ed72ee71887">getExecutionModel</a> (<a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">TargetEnvAttr</a> targetAttr)</td></tr>
<tr class="memdesc:abdcd79b9cf8b161f54bf1ed72ee71887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns execution model selected based on target environment.  <a href="namespacemlir_1_1spirv.html#abdcd79b9cf8b161f54bf1ed72ee71887">More...</a><br /></td></tr>
<tr class="separator:abdcd79b9cf8b161f54bf1ed72ee71887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbfa30f0b7272297c6a305c0971a5fc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; MemoryModel &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#acbfa30f0b7272297c6a305c0971a5fc9">getMemoryModel</a> (<a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">TargetEnvAttr</a> targetAttr)</td></tr>
<tr class="memdesc:acbfa30f0b7272297c6a305c0971a5fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns memory model selected based on target environment.  <a href="namespacemlir_1_1spirv.html#acbfa30f0b7272297c6a305c0971a5fc9">More...</a><br /></td></tr>
<tr class="separator:acbfa30f0b7272297c6a305c0971a5fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b261512c278d63826166487f8ef08f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; spirv::ModuleOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ac6b261512c278d63826166487f8ef08f">combine</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; spirv::ModuleOp &gt; inputModules, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;combinedModuleBuilder, <a class="el" href="namespacemlir_1_1spirv.html#acac1b5d87a905e6e58d061fca3c4b9c2">SymbolRenameListener</a> symRenameListener)</td></tr>
<tr class="memdesc:ac6b261512c278d63826166487f8ef08f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines a list of SPIR-V <code>inputModules</code> into one.  <a href="namespacemlir_1_1spirv.html#ac6b261512c278d63826166487f8ef08f">More...</a><br /></td></tr>
<tr class="separator:ac6b261512c278d63826166487f8ef08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2817d8ec269930bee509d0d66b4d9587"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a2817d8ec269930bee509d0d66b4d9587">createCanonicalizeGLPass</a> ()</td></tr>
<tr class="memdesc:a2817d8ec269930bee509d0d66b4d9587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to run canoncalization patterns that involve GL ops.  <a href="namespacemlir_1_1spirv.html#a2817d8ec269930bee509d0d66b4d9587">More...</a><br /></td></tr>
<tr class="separator:a2817d8ec269930bee509d0d66b4d9587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083394e57445e80d5aca6ff21a6a4526"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; mlir::ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a083394e57445e80d5aca6ff21a6a4526">createDecorateSPIRVCompositeTypeLayoutPass</a> ()</td></tr>
<tr class="memdesc:a083394e57445e80d5aca6ff21a6a4526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a module pass that converts composite types used by objects in the StorageBuffer, PhysicalStorageBuffer, Uniform, and PushConstant storage classes with layout information.  <a href="namespacemlir_1_1spirv.html#a083394e57445e80d5aca6ff21a6a4526">More...</a><br /></td></tr>
<tr class="separator:a083394e57445e80d5aca6ff21a6a4526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957ab8408a40a7f2f24448163548eac4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; spirv::ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a957ab8408a40a7f2f24448163548eac4">createUpdateVersionCapabilityExtensionPass</a> ()</td></tr>
<tr class="memdesc:a957ab8408a40a7f2f24448163548eac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an operation pass that deduces and attaches the minimal version/ capabilities/extensions requirements for spirv.module ops.  <a href="namespacemlir_1_1spirv.html#a957ab8408a40a7f2f24448163548eac4">More...</a><br /></td></tr>
<tr class="separator:a957ab8408a40a7f2f24448163548eac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1af636fd23732e468b4c9231f56a81b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; spirv::ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#af1af636fd23732e468b4c9231f56a81b">createLowerABIAttributesPass</a> ()</td></tr>
<tr class="memdesc:af1af636fd23732e468b4c9231f56a81b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an operation pass that lowers the ABI attributes specified during SPIR-V Lowering.  <a href="namespacemlir_1_1spirv.html#af1af636fd23732e468b4c9231f56a81b">More...</a><br /></td></tr>
<tr class="separator:af1af636fd23732e468b4c9231f56a81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5966ae95de2750b92caf66230fd09ef2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; spirv::ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a5966ae95de2750b92caf66230fd09ef2">createRewriteInsertsPass</a> ()</td></tr>
<tr class="memdesc:a5966ae95de2750b92caf66230fd09ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an operation pass that rewrites sequential chains of spirv.CompositeInsert into spirv.CompositeConstruct.  <a href="namespacemlir_1_1spirv.html#a5966ae95de2750b92caf66230fd09ef2">More...</a><br /></td></tr>
<tr class="separator:a5966ae95de2750b92caf66230fd09ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532fea1d10bcd9e6077280b75e851845"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; spirv::ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a532fea1d10bcd9e6077280b75e851845">createUnifyAliasedResourcePass</a> (<a class="el" href="namespacemlir_1_1spirv.html#a738af61310165c2eb21778ca20406b6a">GetTargetEnvFn</a> getTargetEnv=nullptr)</td></tr>
<tr class="separator:a532fea1d10bcd9e6077280b75e851845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4743247a58ac64de2a9551dec5ef2a5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a4743247a58ac64de2a9551dec5ef2a5c">getBuiltinVariableValue</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, BuiltIn builtin, <a class="el" href="classmlir_1_1Type.html">Type</a> integerType, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="memdesc:a4743247a58ac64de2a9551dec5ef2a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value for the given <code>builtin</code> variable.  <a href="namespacemlir_1_1spirv.html#a4743247a58ac64de2a9551dec5ef2a5c">More...</a><br /></td></tr>
<tr class="separator:a4743247a58ac64de2a9551dec5ef2a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ced2ee0b51782190a208ff6d7266782"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a6ced2ee0b51782190a208ff6d7266782">getPushConstantValue</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, unsigned elementCount, unsigned offset, <a class="el" href="classmlir_1_1Type.html">Type</a> integerType, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="memdesc:a6ced2ee0b51782190a208ff6d7266782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value at the given <code>offset</code> of the push constant storage with a total of <code>elementCount</code> <code>integerType</code> integers.  <a href="namespacemlir_1_1spirv.html#a6ced2ee0b51782190a208ff6d7266782">More...</a><br /></td></tr>
<tr class="separator:a6ced2ee0b51782190a208ff6d7266782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e2e0e2f96602ed55862a37bee299b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ab4e2e0e2f96602ed55862a37bee299b2">linearizeIndex</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> indices, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; strides, int64_t offset, <a class="el" href="classmlir_1_1Type.html">Type</a> integerType, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="memdesc:ab4e2e0e2f96602ed55862a37bee299b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates IR to perform index linearization with the given <code>indices</code> and their corresponding <code>strides</code>, adding an initial <code>offset</code>.  <a href="namespacemlir_1_1spirv.html#ab4e2e0e2f96602ed55862a37bee299b2">More...</a><br /></td></tr>
<tr class="separator:ab4e2e0e2f96602ed55862a37bee299b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983ecae632ca9270368e5dda2fcaf928"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a983ecae632ca9270368e5dda2fcaf928">getElementPtr</a> (<a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, MemRefType baseType, <a class="el" href="classmlir_1_1Value.html">Value</a> basePtr, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> indices, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="memdesc:a983ecae632ca9270368e5dda2fcaf928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the index computation to get to the element at <code>indices</code> of the memory pointed to by <code>basePtr</code>, using the layout map of <code>baseType</code>.  <a href="namespacemlir_1_1spirv.html#a983ecae632ca9270368e5dda2fcaf928">More...</a><br /></td></tr>
<tr class="separator:a983ecae632ca9270368e5dda2fcaf928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5cda7847e8c423a6432d6a9fd5de30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a9e5cda7847e8c423a6432d6a9fd5de30">getOpenCLElementPtr</a> (<a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, MemRefType baseType, <a class="el" href="classmlir_1_1Value.html">Value</a> basePtr, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> indices, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="separator:a9e5cda7847e8c423a6432d6a9fd5de30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea108d3d4dffc88f5fd236bc360af868"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#aea108d3d4dffc88f5fd236bc360af868">getVulkanElementPtr</a> (<a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, MemRefType baseType, <a class="el" href="classmlir_1_1Value.html">Value</a> basePtr, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> indices, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="separator:aea108d3d4dffc88f5fd236bc360af868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72085a04647899413b02980e24fd0008"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; spirv::ModuleOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a72085a04647899413b02980e24fd0008">deserialize</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt; binary, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a72085a04647899413b02980e24fd0008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes the given SPIR-V <code>binary</code> module and creates a MLIR ModuleOp in the given <code>context</code>.  <a href="namespacemlir_1_1spirv.html#a72085a04647899413b02980e24fd0008">More...</a><br /></td></tr>
<tr class="separator:a72085a04647899413b02980e24fd0008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764762951e6d168cda2fc62d3a4639ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a764762951e6d168cda2fc62d3a4639ee">serialize</a> (ModuleOp module, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; uint32_t &gt; &amp;binary, const <a class="el" href="structmlir_1_1spirv_1_1SerializationOptions.html">SerializationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>={})</td></tr>
<tr class="memdesc:a764762951e6d168cda2fc62d3a4639ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the given SPIR-V <code>module</code> and writes to <code>binary</code>.  <a href="namespacemlir_1_1spirv.html#a764762951e6d168cda2fc62d3a4639ee">More...</a><br /></td></tr>
<tr class="separator:a764762951e6d168cda2fc62d3a4639ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9286568f54e529177c6f19e1a05ead66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a9286568f54e529177c6f19e1a05ead66">appendModuleHeader</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; uint32_t &gt; &amp;header, spirv::Version version, uint32_t idBound)</td></tr>
<tr class="memdesc:a9286568f54e529177c6f19e1a05ead66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a SPRI-V module header to <code>header</code> with the given <code>version</code> and <code>idBound</code>.  <a href="namespacemlir_1_1spirv.html#a9286568f54e529177c6f19e1a05ead66">More...</a><br /></td></tr>
<tr class="separator:a9286568f54e529177c6f19e1a05ead66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6583bd4786f75b42698de079fe0bc892"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a6583bd4786f75b42698de079fe0bc892">getPrefixedOpcode</a> (uint32_t wordCount, spirv::Opcode opcode)</td></tr>
<tr class="memdesc:a6583bd4786f75b42698de079fe0bc892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the word-count-prefixed opcode for an SPIR-V instruction.  <a href="namespacemlir_1_1spirv.html#a6583bd4786f75b42698de079fe0bc892">More...</a><br /></td></tr>
<tr class="separator:a6583bd4786f75b42698de079fe0bc892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff3c223d2106f6d92a5772a9d0736c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a0ff3c223d2106f6d92a5772a9d0736c1">encodeStringLiteralInto</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; uint32_t &gt; &amp;binary, StringRef literal)</td></tr>
<tr class="memdesc:a0ff3c223d2106f6d92a5772a9d0736c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes an SPIR-V <code>literal</code> string into the given <code>binary</code> vector.  <a href="namespacemlir_1_1spirv.html#a0ff3c223d2106f6d92a5772a9d0736c1">More...</a><br /></td></tr>
<tr class="separator:a0ff3c223d2106f6d92a5772a9d0736c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ae92c06481ab5590c94261e73b6166"><td class="memItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ab3ae92c06481ab5590c94261e73b6166">decodeStringLiteral</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt; words, unsigned &amp;wordIndex)</td></tr>
<tr class="memdesc:ab3ae92c06481ab5590c94261e73b6166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a string literal in <code>words</code> starting at <code>wordIndex</code>.  <a href="namespacemlir_1_1spirv.html#ab3ae92c06481ab5590c94261e73b6166">More...</a><br /></td></tr>
<tr class="separator:ab3ae92c06481ab5590c94261e73b6166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3f67306af2bae665876607f6cda007"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a3a3f67306af2bae665876607f6cda007"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a3a3f67306af2bae665876607f6cda007">Deserializer::processOp&lt; spirv::EntryPointOp &gt;</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt; words)</td></tr>
<tr class="separator:a3a3f67306af2bae665876607f6cda007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6e7f02b46ed0e63707dab1e129bb82"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:acf6e7f02b46ed0e63707dab1e129bb82"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#acf6e7f02b46ed0e63707dab1e129bb82">Deserializer::processOp&lt; spirv::ExecutionModeOp &gt;</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt; words)</td></tr>
<tr class="separator:acf6e7f02b46ed0e63707dab1e129bb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009f0aa8f9f8655433f830b39d6c4ab6"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a009f0aa8f9f8655433f830b39d6c4ab6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a009f0aa8f9f8655433f830b39d6c4ab6">Deserializer::processOp&lt; spirv::FunctionCallOp &gt;</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt; operands)</td></tr>
<tr class="separator:a009f0aa8f9f8655433f830b39d6c4ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65663608696ea8ed3e771aa721401699"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a65663608696ea8ed3e771aa721401699"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a65663608696ea8ed3e771aa721401699">Deserializer::processOp&lt; spirv::CopyMemoryOp &gt;</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt; words)</td></tr>
<tr class="separator:a65663608696ea8ed3e771aa721401699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1028b0abc35997e95aefa6b3d26adf79"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a1028b0abc35997e95aefa6b3d26adf79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a1028b0abc35997e95aefa6b3d26adf79">Deserializer::processOp&lt; spirv::GenericCastToPtrExplicitOp &gt;</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt; words)</td></tr>
<tr class="separator:a1028b0abc35997e95aefa6b3d26adf79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9360bb2d9fb5d7a6d16eaa1a17132f97"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a9360bb2d9fb5d7a6d16eaa1a17132f97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a9360bb2d9fb5d7a6d16eaa1a17132f97">Serializer::processOp&lt; spirv::EntryPointOp &gt;</a> (spirv::EntryPointOp op)</td></tr>
<tr class="separator:a9360bb2d9fb5d7a6d16eaa1a17132f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27df4c1b5396a8998d58603a044e5d0"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ad27df4c1b5396a8998d58603a044e5d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ad27df4c1b5396a8998d58603a044e5d0">Serializer::processOp&lt; spirv::ExecutionModeOp &gt;</a> (spirv::ExecutionModeOp op)</td></tr>
<tr class="separator:ad27df4c1b5396a8998d58603a044e5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8166d677987aab5a71255741c5b5a63b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a8166d677987aab5a71255741c5b5a63b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a8166d677987aab5a71255741c5b5a63b">Serializer::processOp&lt; spirv::FunctionCallOp &gt;</a> (spirv::FunctionCallOp op)</td></tr>
<tr class="separator:a8166d677987aab5a71255741c5b5a63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02999329ba2aaf9d90c2154489e6ace"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ae02999329ba2aaf9d90c2154489e6ace"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ae02999329ba2aaf9d90c2154489e6ace">Serializer::processOp&lt; spirv::CopyMemoryOp &gt;</a> (spirv::CopyMemoryOp op)</td></tr>
<tr class="separator:ae02999329ba2aaf9d90c2154489e6ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30d7e3a8c376ff9d21825446fd0e6a2"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ae30d7e3a8c376ff9d21825446fd0e6a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ae30d7e3a8c376ff9d21825446fd0e6a2">Serializer::processOp&lt; spirv::GenericCastToPtrExplicitOp &gt;</a> (spirv::GenericCastToPtrExplicitOp op)</td></tr>
<tr class="separator:ae30d7e3a8c376ff9d21825446fd0e6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833133e74c83ef32f078b57244466d0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a833133e74c83ef32f078b57244466d0c">encodeInstructionInto</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; uint32_t &gt; &amp;binary, spirv::Opcode op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt; operands)</td></tr>
<tr class="memdesc:a833133e74c83ef32f078b57244466d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes an SPIR-V instruction with the given <code>opcode</code> and <code>operands</code> into the given <code>binary</code> vector.  <a href="namespacemlir_1_1spirv.html#a833133e74c83ef32f078b57244466d0c">More...</a><br /></td></tr>
<tr class="separator:a833133e74c83ef32f078b57244466d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0066624e2704755cca3404ab368dbcc3"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a0066624e2704755cca3404ab368dbcc3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a0066624e2704755cca3404ab368dbcc3">Serializer::processTypeDecoration&lt; spirv::ArrayType &gt;</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1spirv_1_1ArrayType.html">spirv::ArrayType</a> type, uint32_t resultID)</td></tr>
<tr class="separator:a0066624e2704755cca3404ab368dbcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97cd75646073d697112f7f8cc79c503"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ab97cd75646073d697112f7f8cc79c503"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ab97cd75646073d697112f7f8cc79c503">Serializer::processTypeDecoration&lt; spirv::RuntimeArrayType &gt;</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1spirv_1_1RuntimeArrayType.html">spirv::RuntimeArrayType</a> type, uint32_t resultID)</td></tr>
<tr class="separator:ab97cd75646073d697112f7f8cc79c503"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad26be4ada4901dc6598761977638338c"><td class="memItemLeft" align="right" valign="top">constexpr unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#ad26be4ada4901dc6598761977638338c">kHeaderWordCount</a> = 5</td></tr>
<tr class="memdesc:ad26be4ada4901dc6598761977638338c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPIR-V binary header word count.  <a href="namespacemlir_1_1spirv.html#ad26be4ada4901dc6598761977638338c">More...</a><br /></td></tr>
<tr class="separator:ad26be4ada4901dc6598761977638338c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5385336e089899ca7fcc7af2dbedf4e6"><td class="memItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a5385336e089899ca7fcc7af2dbedf4e6">kMagicNumber</a> = 0x07230203</td></tr>
<tr class="memdesc:a5385336e089899ca7fcc7af2dbedf4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPIR-V magic number.  <a href="namespacemlir_1_1spirv.html#a5385336e089899ca7fcc7af2dbedf4e6">More...</a><br /></td></tr>
<tr class="separator:a5385336e089899ca7fcc7af2dbedf4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2478bd60cd2037a1d56b6ce17bd32bb4"><td class="memItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html#a2478bd60cd2037a1d56b6ce17bd32bb4">kGeneratorNumber</a> = 22</td></tr>
<tr class="memdesc:a2478bd60cd2037a1d56b6ce17bd32bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The serializer tool ID registered to the Khronos Group.  <a href="namespacemlir_1_1spirv.html#a2478bd60cd2037a1d56b6ce17bd32bb4">More...</a><br /></td></tr>
<tr class="separator:a2478bd60cd2037a1d56b6ce17bd32bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="acd480fdd0d8fb515c1419293ce3c0e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd480fdd0d8fb515c1419293ce3c0e4c">&#9670;&nbsp;</a></span>BlockMergeInfoMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1spirv.html#acd480fdd0d8fb515c1419293ce3c0e4c">mlir::spirv::BlockMergeInfoMap</a> = typedef <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt;<a class="el" href="classmlir_1_1Block.html">Block</a> *, <a class="el" href="structmlir_1_1spirv_1_1BlockMergeInfo.html">BlockMergeInfo</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map from a selection/loop's header block to its merge (and continue) target. </p>

<p class="definition">Definition at line <a class="el" href="Deserializer_8h_source.html#l00059">59</a> of file <a class="el" href="Deserializer_8h_source.html">Deserializer.h</a>.</p>

</div>
</div>
<a id="a738af61310165c2eb21778ca20406b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a738af61310165c2eb21778ca20406b6a">&#9670;&nbsp;</a></span>GetTargetEnvFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1spirv.html#a738af61310165c2eb21778ca20406b6a">mlir::spirv::GetTargetEnvFn</a> = typedef std::function&lt;<a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">spirv::TargetEnvAttr</a>(spirv::ModuleOp)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an operation pass that unifies access of multiple aliased resources into access of one single resource. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SPIRV_2Transforms_2Passes_8h_source.html#l00073">73</a> of file <a class="el" href="Dialect_2SPIRV_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a8c7c1526971652a9456ea3fadb73c0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7c1526971652a9456ea3fadb73c0af">&#9670;&nbsp;</a></span>MemorySpaceToStorageClassMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1spirv.html#a8c7c1526971652a9456ea3fadb73c0af">mlir::spirv::MemorySpaceToStorageClassMap</a> = typedef std::function&lt;<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;spirv::StorageClass&gt;(unsigned)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mapping from numeric MemRef memory spaces into SPIR-V symbolic ones. </p>

<p class="definition">Definition at line <a class="el" href="MemRefToSPIRV_8h_source.html#l00025">25</a> of file <a class="el" href="MemRefToSPIRV_8h_source.html">MemRefToSPIRV.h</a>.</p>

</div>
</div>
<a id="acac1b5d87a905e6e58d061fca3c4b9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac1b5d87a905e6e58d061fca3c4b9c2">&#9670;&nbsp;</a></span>SymbolRenameListener</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1spirv.html#acac1b5d87a905e6e58d061fca3c4b9c2">mlir::spirv::SymbolRenameListener</a> = typedef <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt;void( spirv::ModuleOp originalModule, StringRef oldSymbol, StringRef newSymbol)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The listener function to receive symbol renaming events. </p>
<p><code>originalModule</code> is the input spirv::ModuleOp that contains the renamed symbol. <code>oldSymbol</code> and <code>newSymbol</code> are the original and renamed symbol. Note that it's the responsibility of the caller to properly retain the storage underlying the passed StringRefs if the listener callback outlives this function call. </p>

<p class="definition">Definition at line <a class="el" href="ModuleCombiner_8h_source.html#l00032">32</a> of file <a class="el" href="ModuleCombiner_8h_source.html">ModuleCombiner.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9286568f54e529177c6f19e1a05ead66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9286568f54e529177c6f19e1a05ead66">&#9670;&nbsp;</a></span>appendModuleHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::spirv::appendModuleHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spirv::Version&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends a SPRI-V module header to <code>header</code> with the given <code>version</code> and <code>idBound</code>. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVBinaryUtils_8cpp_source.html#l00018">18</a> of file <a class="el" href="SPIRVBinaryUtils_8cpp_source.html">SPIRVBinaryUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVBinaryUtils_8h_source.html#l00031">kGeneratorNumber</a>, <a class="el" href="SPIRVBinaryUtils_8h_source.html#l00028">kMagicNumber</a>, and <a class="el" href="SPIRVBinaryUtils_8cpp.html#a689f1d4c6493b449baf3c637ceaed760">MIN_VERSION_CASE</a>.</p>

<p class="reference">Referenced by <a class="el" href="Serializer_8cpp_source.html#l00112">mlir::spirv::Serializer::collect()</a>.</p>

</div>
</div>
<a id="ac6b261512c278d63826166487f8ef08f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b261512c278d63826166487f8ef08f">&#9670;&nbsp;</a></span>combine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; spirv::ModuleOp &gt; mlir::spirv::combine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; spirv::ModuleOp &gt;&#160;</td>
          <td class="paramname"><em>inputModules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>combinedModuleBuilder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1spirv.html#acac1b5d87a905e6e58d061fca3c4b9c2">SymbolRenameListener</a>&#160;</td>
          <td class="paramname"><em>symRenameListener</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines a list of SPIR-V <code>inputModules</code> into one. </p>
<p>Returns the combined module on success; returns a null module otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputModules</td><td>the list of modules to combine. They won't be modified. </td></tr>
    <tr><td class="paramname">combinedMdouleBuilder</td><td>an <a class="el" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations.">OpBuilder</a> for building the combined module. </td></tr>
    <tr><td class="paramname">symbRenameListener</td><td>a listener that gets called everytime a symbol in one of the input modules is renamed.</td></tr>
  </table>
  </dd>
</dl>
<p>To combine multiple SPIR-V modules, we move all the module-level ops from all the input modules into one big combined module. To that end, the combination process proceeds in 2 phases:</p>
<ol type="1">
<li>resolve conflicts between pairs of ops from different modules,</li>
<li>deduplicate equivalent ops/sub-ops in the merged module.</li>
</ol>
<p>For the conflict resolution phase, the following rules are employed to resolve such conflicts:</p>
<ul>
<li>If 2 spirv.func's have the same symbol name, then rename one of the functions.</li>
<li>If an spirv.func and another op have the same symbol name, then rename the other symbol.</li>
<li>If none of the 2 conflicting ops are spirv.func, then rename either.</li>
</ul>
<p>For deduplication, the following 3 cases are taken into consideration:</p>
<ul>
<li>If 2 spirv.GlobalVariable's have either the same descriptor set + binding or the same build_in attribute value, then replace one of them using the other.</li>
<li>If 2 spirv.SpecConstant's have the same spec_id attribute value, then replace one of them using the other.</li>
<li>Deduplicating functions are not supported right now.</li>
</ul>
<p>In all cases, the references to the updated symbol (whether renamed or deduplicated) are also updated to reflect the change. </p>

<p class="definition">Definition at line <a class="el" href="ModuleCombiner_8cpp_source.html#l00090">90</a> of file <a class="el" href="ModuleCombiner_8cpp_source.html">ModuleCombiner.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleCombiner_8cpp_source.html#l00076">computeHash()</a>, <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="Builders_8cpp_source.html#l00386">mlir::OpBuilder::insert()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00894">mlir::SymbolTable::replaceAllSymbolUses()</a>, <a class="el" href="Builders_8h_source.html#l00383">mlir::OpBuilder::setInsertionPointToStart()</a>, and <a class="el" href="ModuleCombiner_8cpp_source.html#l00051">updateSymbolAndAllUses()</a>.</p>

</div>
</div>
<a id="a2817d8ec269930bee509d0d66b4d9587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2817d8ec269930bee509d0d66b4d9587">&#9670;&nbsp;</a></span>createCanonicalizeGLPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;&gt; &gt; mlir::spirv::createCanonicalizeGLPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to run canoncalization patterns that involve GL ops. </p>
<p>These patterns cannot be run in default canonicalization because GL ops aren't always available. So they should be involed specifically when needed. </p>

<p class="definition">Definition at line <a class="el" href="CanonicalizeGLPass_8cpp_source.html#l00039">39</a> of file <a class="el" href="CanonicalizeGLPass_8cpp_source.html">CanonicalizeGLPass.cpp</a>.</p>

</div>
</div>
<a id="a083394e57445e80d5aca6ff21a6a4526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a083394e57445e80d5aca6ff21a6a4526">&#9670;&nbsp;</a></span>createDecorateSPIRVCompositeTypeLayoutPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::spirv::createDecorateSPIRVCompositeTypeLayoutPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a module pass that converts composite types used by objects in the StorageBuffer, PhysicalStorageBuffer, Uniform, and PushConstant storage classes with layout information. </p>
<p>Right now this pass only supports Vulkan layout rules. </p>

<p class="definition">Definition at line <a class="el" href="DecorateCompositeTypeLayoutPass_8cpp_source.html#l00151">151</a> of file <a class="el" href="DecorateCompositeTypeLayoutPass_8cpp_source.html">DecorateCompositeTypeLayoutPass.cpp</a>.</p>

</div>
</div>
<a id="af1af636fd23732e468b4c9231f56a81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1af636fd23732e468b4c9231f56a81b">&#9670;&nbsp;</a></span>createLowerABIAttributesPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; spirv::ModuleOp &gt; &gt; mlir::spirv::createLowerABIAttributesPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an operation pass that lowers the ABI attributes specified during SPIR-V Lowering. </p>
<p>Specifically,</p><ol type="1">
<li>Creates the global variables for arguments of entry point function using the specification in the <code>spirv.interface_var_abi</code> attribute for each argument.</li>
<li>Inserts the EntryPointOp and the ExecutionModeOp for entry point functions using the specification in the <code>spirv.entry_point_abi</code> attribute. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00300">300</a> of file <a class="el" href="LowerABIAttributesPass_8cpp_source.html">LowerABIAttributesPass.cpp</a>.</p>

</div>
</div>
<a id="a5966ae95de2750b92caf66230fd09ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5966ae95de2750b92caf66230fd09ef2">&#9670;&nbsp;</a></span>createRewriteInsertsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; spirv::ModuleOp &gt; &gt; mlir::spirv::createRewriteInsertsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an operation pass that rewrites sequential chains of spirv.CompositeInsert into spirv.CompositeConstruct. </p>

<p class="definition">Definition at line <a class="el" href="RewriteInsertsPass_8cpp_source.html#l00122">122</a> of file <a class="el" href="RewriteInsertsPass_8cpp_source.html">RewriteInsertsPass.cpp</a>.</p>

</div>
</div>
<a id="a532fea1d10bcd9e6077280b75e851845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a532fea1d10bcd9e6077280b75e851845">&#9670;&nbsp;</a></span>createUnifyAliasedResourcePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; spirv::ModuleOp &gt; &gt; mlir::spirv::createUnifyAliasedResourcePass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1spirv.html#a738af61310165c2eb21778ca20406b6a">spirv::GetTargetEnvFn</a>&#160;</td>
          <td class="paramname"><em>getTargetEnv</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00589">589</a> of file <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html">UnifyAliasedResourcePass.cpp</a>.</p>

</div>
</div>
<a id="a957ab8408a40a7f2f24448163548eac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a957ab8408a40a7f2f24448163548eac4">&#9670;&nbsp;</a></span>createUpdateVersionCapabilityExtensionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; spirv::ModuleOp &gt; &gt; mlir::spirv::createUpdateVersionCapabilityExtensionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an operation pass that deduces and attaches the minimal version/ capabilities/extensions requirements for spirv.module ops. </p>
<p>For each spirv.module op, this pass requires a <code>spirv.target_env</code> attribute on it or an enclosing module-like op to drive the deduction. The reason is that an op can be enabled by multiple extensions/capabilities. So we need to know which one to pick. <code>spirv.target_env</code> gives the hard limit as for what the target environment can support; this pass deduces what are actually needed for a specific spirv.module op. </p>

<p class="definition">Definition at line <a class="el" href="UpdateVCEPass_8cpp_source.html#l00189">189</a> of file <a class="el" href="UpdateVCEPass_8cpp_source.html">UpdateVCEPass.cpp</a>.</p>

</div>
</div>
<a id="ab3ae92c06481ab5590c94261e73b6166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ae92c06481ab5590c94261e73b6166">&#9670;&nbsp;</a></span>decodeStringLiteral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StringRef mlir::spirv::decodeStringLiteral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>wordIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decodes a string literal in <code>words</code> starting at <code>wordIndex</code>. </p>
<p>Update the latter to point to the position in words after the string literal. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVBinaryUtils_8h_source.html#l00047">47</a> of file <a class="el" href="SPIRVBinaryUtils_8h_source.html">SPIRVBinaryUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="DeserializeOps_8cpp_source.html#l00332">Deserializer::processOp&lt; spirv::EntryPointOp &gt;()</a>.</p>

</div>
</div>
<a id="a72085a04647899413b02980e24fd0008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72085a04647899413b02980e24fd0008">&#9670;&nbsp;</a></span>deserialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; spirv::ModuleOp &gt; mlir::spirv::deserialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>binary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserializes the given SPIR-V <code>binary</code> module and creates a MLIR ModuleOp in the given <code>context</code>. </p>
<p>Returns the ModuleOp on success; otherwise, reports errors to the error handler registered with <code>context</code> and returns a null module. </p>

<p class="definition">Definition at line <a class="el" href="Deserialization_8cpp_source.html#l00015">15</a> of file <a class="el" href="Deserialization_8cpp_source.html">Deserialization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Deserializer_8cpp_source.html#l00101">mlir::spirv::Deserializer::collect()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00062">mlir::spirv::Deserializer::deserialize()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00040">deserializeModule()</a>, and <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00102">roundTripModule()</a>.</p>

</div>
</div>
<a id="a65663608696ea8ed3e771aa721401699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65663608696ea8ed3e771aa721401699">&#9670;&nbsp;</a></span>Deserializer::processOp&lt; spirv::CopyMemoryOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::spirv::Deserializer::processOp&lt; spirv::CopyMemoryOp &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>words</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DeserializeOps_8cpp_source.html#l00455">455</a> of file <a class="el" href="DeserializeOps_8cpp_source.html">DeserializeOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00327">mlir::emitError()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="a3a3f67306af2bae665876607f6cda007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a3f67306af2bae665876607f6cda007">&#9670;&nbsp;</a></span>Deserializer::processOp&lt; spirv::EntryPointOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::spirv::Deserializer::processOp&lt; spirv::EntryPointOp &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>words</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DeserializeOps_8cpp_source.html#l00331">331</a> of file <a class="el" href="DeserializeOps_8cpp_source.html">DeserializeOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVBinaryUtils_8h_source.html#l00047">decodeStringLiteral()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00327">mlir::emitError()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="acf6e7f02b46ed0e63707dab1e129bb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6e7f02b46ed0e63707dab1e129bb82">&#9670;&nbsp;</a></span>Deserializer::processOp&lt; spirv::ExecutionModeOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::spirv::Deserializer::processOp&lt; spirv::ExecutionModeOp &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>words</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DeserializeOps_8cpp_source.html#l00380">380</a> of file <a class="el" href="DeserializeOps_8cpp_source.html">DeserializeOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00327">mlir::emitError()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="a009f0aa8f9f8655433f830b39d6c4ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a009f0aa8f9f8655433f830b39d6c4ab6">&#9670;&nbsp;</a></span>Deserializer::processOp&lt; spirv::FunctionCallOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::spirv::Deserializer::processOp&lt; spirv::FunctionCallOp &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>operands</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DeserializeOps_8cpp_source.html#l00413">413</a> of file <a class="el" href="DeserializeOps_8cpp_source.html">DeserializeOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00327">mlir::emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00160">value</a>.</p>

</div>
</div>
<a id="a1028b0abc35997e95aefa6b3d26adf79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1028b0abc35997e95aefa6b3d26adf79">&#9670;&nbsp;</a></span>Deserializer::processOp&lt; spirv::GenericCastToPtrExplicitOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::spirv::Deserializer::processOp&lt; spirv::GenericCastToPtrExplicitOp &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>words</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DeserializeOps_8cpp_source.html#l00527">527</a> of file <a class="el" href="DeserializeOps_8cpp_source.html">DeserializeOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00049">mlir::Operation::create()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00327">mlir::emitError()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00324">mlir::Operation::getResult()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="a833133e74c83ef32f078b57244466d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833133e74c83ef32f078b57244466d0c">&#9670;&nbsp;</a></span>encodeInstructionInto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::spirv::encodeInstructionInto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>binary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spirv::Opcode&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes an SPIR-V instruction with the given <code>opcode</code> and <code>operands</code> into the given <code>binary</code> vector. </p>

<p class="definition">Definition at line <a class="el" href="Serializer_8cpp_source.html#l00077">77</a> of file <a class="el" href="Serializer_8cpp_source.html">Serializer.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVBinaryUtils_8cpp_source.html#l00061">getPrefixedOpcode()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SerializeOps_8cpp_source.html#l00629">Serializer::processOp&lt; spirv::CopyMemoryOp &gt;()</a>, <a class="el" href="SerializeOps_8cpp_source.html#l00538">Serializer::processOp&lt; spirv::EntryPointOp &gt;()</a>, <a class="el" href="SerializeOps_8cpp_source.html#l00573">Serializer::processOp&lt; spirv::ExecutionModeOp &gt;()</a>, <a class="el" href="SerializeOps_8cpp_source.html#l00602">Serializer::processOp&lt; spirv::FunctionCallOp &gt;()</a>, and <a class="el" href="SerializeOps_8cpp_source.html#l00673">Serializer::processOp&lt; spirv::GenericCastToPtrExplicitOp &gt;()</a>.</p>

</div>
</div>
<a id="a0ff3c223d2106f6d92a5772a9d0736c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff3c223d2106f6d92a5772a9d0736c1">&#9670;&nbsp;</a></span>encodeStringLiteralInto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::spirv::encodeStringLiteralInto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>binary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>literal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes an SPIR-V <code>literal</code> string into the given <code>binary</code> vector. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVBinaryUtils_8cpp_source.html#l00066">66</a> of file <a class="el" href="SPIRVBinaryUtils_8cpp_source.html">SPIRVBinaryUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SerializeOps_8cpp_source.html#l00538">Serializer::processOp&lt; spirv::EntryPointOp &gt;()</a>.</p>

</div>
</div>
<a id="ac17523f6494ead17ffb9559789d9629a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17523f6494ead17ffb9559789d9629a">&#9670;&nbsp;</a></span>getAddressingModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spirv::AddressingModel mlir::spirv::getAddressingModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">spirv::TargetEnvAttr</a>&#160;</td>
          <td class="paramname"><em>targetAttr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns addressing model selected based on target environment. </p>

<p class="definition">Definition at line <a class="el" href="TargetAndABI_8cpp_source.html#l00203">203</a> of file <a class="el" href="TargetAndABI_8cpp_source.html">TargetAndABI.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVAttributes_8cpp_source.html#l00313">mlir::spirv::TargetEnvAttr::getCapabilities()</a>.</p>

</div>
</div>
<a id="a4743247a58ac64de2a9551dec5ef2a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4743247a58ac64de2a9551dec5ef2a5c">&#9670;&nbsp;</a></span>getBuiltinVariableValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::spirv::getBuiltinVariableValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BuiltIn&#160;</td>
          <td class="paramname"><em>builtin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>integerType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value for the given <code>builtin</code> variable. </p>
<p>This function gets or inserts the global variable associated for the builtin within the nearest symbol table enclosing <code>op</code>. Returns null <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> on error. </p>

<p class="reference">Referenced by <a class="el" href="LinalgToSPIRV_8cpp_source.html#l00028">getLocalInvocationDimSize()</a>.</p>

</div>
</div>
<a id="ae1f2ff3fa9b623a0a6fa86ac75af3f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f2ff3fa9b623a0a6fa86ac75af3f4d">&#9670;&nbsp;</a></span>getDefaultResourceLimits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spirv::ResourceLimitsAttr mlir::spirv::getDefaultResourceLimits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a default resource limits attribute that uses numbers from "Table 46. Required Limits" of the Vulkan spec. </p>

<p class="definition">Definition at line <a class="el" href="TargetAndABI_8cpp_source.html#l00154">154</a> of file <a class="el" href="TargetAndABI_8cpp_source.html">TargetAndABI.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00257">mlir::Builder::getI32ArrayAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetAndABI_8cpp_source.html#l00169">getDefaultTargetEnv()</a>.</p>

</div>
</div>
<a id="aeb49fbe2ae3a33a6f06fcc29a3698ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb49fbe2ae3a33a6f06fcc29a3698ac2">&#9670;&nbsp;</a></span>getDefaultTargetEnv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">spirv::TargetEnvAttr</a> mlir::spirv::getDefaultTargetEnv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the default target environment: SPIR-V 1.0 with Shader capability and no extra extensions. </p>

<p class="definition">Definition at line <a class="el" href="TargetAndABI_8cpp_source.html#l00169">169</a> of file <a class="el" href="TargetAndABI_8cpp_source.html">TargetAndABI.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVAttributes_8cpp_source.html#l00285">mlir::spirv::TargetEnvAttr::get()</a>, <a class="el" href="classmlir_1_1spirv_1_1VerCapExtAttr.html#a7d13aefc75fe19ec31af3a2abb800f2b">mlir::spirv::VerCapExtAttr::get()</a>, <a class="el" href="TargetAndABI_8cpp_source.html#l00154">getDefaultResourceLimits()</a>, and <a class="el" href="SPIRVAttributes_8h_source.html#l00136">mlir::spirv::TargetEnvAttr::kUnknownDeviceID</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetAndABI_8cpp_source.html#l00195">lookupTargetEnvOrDefault()</a>.</p>

</div>
</div>
<a id="a6686e4cb7cffae099e00c124e04d5420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6686e4cb7cffae099e00c124e04d5420">&#9670;&nbsp;</a></span>getDirectImpliedCapabilities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;Capability&gt; mlir::spirv::getDirectImpliedCapabilities </td>
          <td>(</td>
          <td class="paramtype">Capability&#160;</td>
          <td class="paramname"><em>cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the directly implied capabilities for the given capability. </p>
<p>These capabilities are implicitly declared by the given capability. </p>

</div>
</div>
<a id="a983ecae632ca9270368e5dda2fcaf928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983ecae632ca9270368e5dda2fcaf928">&#9670;&nbsp;</a></span>getElementPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::spirv::getElementPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>baseType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>basePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the index computation to get to the element at <code>indices</code> of the memory pointed to by <code>basePtr</code>, using the layout map of <code>baseType</code>. </p>
<p>Returns null if index computation cannot be performed. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVConversion_8cpp_source.html#l00809">809</a> of file <a class="el" href="SPIRVConversion_8cpp_source.html">SPIRVConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVConversion_8cpp_source.html#l00126">mlir::SPIRVTypeConverter::allows()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00774">getOpenCLElementPtr()</a>, and <a class="el" href="SPIRVConversion_8cpp_source.html#l00743">getVulkanElementPtr()</a>.</p>

</div>
</div>
<a id="ab474762031def1b0f3380d6d58a7e326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab474762031def1b0f3380d6d58a7e326">&#9670;&nbsp;</a></span>getEntryPointABIAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spirv::EntryPointABIAttr mlir::spirv::getEntryPointABIAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int32_t &gt;&#160;</td>
          <td class="paramname"><em>localSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the EntryPointABIAttr given its fields. </p>

<p class="definition">Definition at line <a class="el" href="TargetAndABI_8cpp_source.html#l00122">122</a> of file <a class="el" href="TargetAndABI_8cpp_source.html">TargetAndABI.cpp</a>.</p>

</div>
</div>
<a id="aecdb10932f9d700379ed74c9df04e530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecdb10932f9d700379ed74c9df04e530">&#9670;&nbsp;</a></span>getEntryPointABIAttrName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef mlir::spirv::getEntryPointABIAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the attribute name for specifying entry point information. </p>

<p class="definition">Definition at line <a class="el" href="TargetAndABI_8cpp_source.html#l00119">119</a> of file <a class="el" href="TargetAndABI_8cpp_source.html">TargetAndABI.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetAndABI_8cpp_source.html#l00133">lookupEntryPointABI()</a>, <a class="el" href="GPUToSPIRV_8cpp_source.html#l00195">lowerAsEntryFunction()</a>, and <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00114">lowerEntryPointABIAttr()</a>.</p>

</div>
</div>
<a id="abdcd79b9cf8b161f54bf1ed72ee71887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdcd79b9cf8b161f54bf1ed72ee71887">&#9670;&nbsp;</a></span>getExecutionModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; spirv::ExecutionModel &gt; mlir::spirv::getExecutionModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">spirv::TargetEnvAttr</a>&#160;</td>
          <td class="paramname"><em>targetAttr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns execution model selected based on target environment. </p>
<p>Returns failure if it cannot be selected. </p>

<p class="definition">Definition at line <a class="el" href="TargetAndABI_8cpp_source.html#l00220">220</a> of file <a class="el" href="TargetAndABI_8cpp_source.html">TargetAndABI.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, and <a class="el" href="SPIRVAttributes_8cpp_source.html#l00313">mlir::spirv::TargetEnvAttr::getCapabilities()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00114">lowerEntryPointABIAttr()</a>.</p>

</div>
</div>
<a id="a2ebec54b6a40e0cb8f2c7d3640663be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebec54b6a40e0cb8f2c7d3640663be4">&#9670;&nbsp;</a></span>getImpliedExtensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;Extension&gt; mlir::spirv::getImpliedExtensions </td>
          <td>(</td>
          <td class="paramtype">Version&#160;</td>
          <td class="paramname"><em>version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the implied extensions for the given version. </p>
<p>These extensions are incorporated into the current version so they are implicitly declared when targeting the given version. </p>

<p class="reference">Referenced by <a class="el" href="TargetAndABI_8cpp_source.html#l00022">mlir::spirv::TargetEnv::TargetEnv()</a>.</p>

</div>
</div>
<a id="ae60cb9b4c0712f47e2e1a0e74103826a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae60cb9b4c0712f47e2e1a0e74103826a">&#9670;&nbsp;</a></span>getInterfaceVarABIAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1spirv_1_1InterfaceVarABIAttr.html">InterfaceVarABIAttr</a> mlir::spirv::getInterfaceVarABIAttr </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>descriptorSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>binding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; StorageClass &gt;&#160;</td>
          <td class="paramname"><em>storageClass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the <a class="el" href="classmlir_1_1spirv_1_1InterfaceVarABIAttr.html" title="An attribute that specifies the information regarding the interface variable: descriptor set,...">InterfaceVarABIAttr</a> given its fields. </p>

<p class="reference">Referenced by <a class="el" href="GPUToSPIRV_8cpp_source.html#l00256">getDefaultABIAttrs()</a>.</p>

</div>
</div>
<a id="a084723c4d96882caa7edd6bfc3dfe1d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084723c4d96882caa7edd6bfc3dfe1d0">&#9670;&nbsp;</a></span>getInterfaceVarABIAttrName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef mlir::spirv::getInterfaceVarABIAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the attribute name for specifying argument ABI information. </p>

<p class="definition">Definition at line <a class="el" href="TargetAndABI_8cpp_source.html#l00097">97</a> of file <a class="el" href="TargetAndABI_8cpp_source.html">TargetAndABI.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="GPUToSPIRV_8cpp_source.html#l00256">getDefaultABIAttrs()</a>, <a class="el" href="GPUToSPIRV_8cpp_source.html#l00195">lowerAsEntryFunction()</a>, and <a class="el" href="SPIRVDialect_8cpp_source.html#l00959">verifyRegionAttribute()</a>.</p>

</div>
</div>
<a id="acbfa30f0b7272297c6a305c0971a5fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbfa30f0b7272297c6a305c0971a5fc9">&#9670;&nbsp;</a></span>getMemoryModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; spirv::MemoryModel &gt; mlir::spirv::getMemoryModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">spirv::TargetEnvAttr</a>&#160;</td>
          <td class="paramname"><em>targetAttr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns memory model selected based on target environment. </p>
<p>Returns failure if it cannot be selected. </p>

<p class="definition">Definition at line <a class="el" href="TargetAndABI_8cpp_source.html#l00231">231</a> of file <a class="el" href="TargetAndABI_8cpp_source.html">TargetAndABI.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00313">mlir::spirv::TargetEnvAttr::getCapabilities()</a>, and <a class="el" href="Runtimes_8h_source.html#l00018">mlir::gpu::amd::OpenCL</a>.</p>

</div>
</div>
<a id="a20da364acf11b2fc680395daeeca97fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20da364acf11b2fc680395daeeca97fc">&#9670;&nbsp;</a></span>getMemorySpaceToStorageClassTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &gt; mlir::spirv::getMemorySpaceToStorageClassTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the target that populates legality of ops with MemRef types. </p>

<p class="definition">Definition at line <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00224">224</a> of file <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html">MapMemRefStorageClassPass.cpp</a>.</p>

<p class="reference">References <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00208">isLegalOp()</a>.</p>

</div>
</div>
<a id="a9e5cda7847e8c423a6432d6a9fd5de30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e5cda7847e8c423a6432d6a9fd5de30">&#9670;&nbsp;</a></span>getOpenCLElementPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::spirv::getOpenCLElementPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>baseType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>basePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVConversion_8cpp_source.html#l00774">774</a> of file <a class="el" href="SPIRVConversion_8cpp_source.html">SPIRVConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00280">mlir::Type::cast()</a>, <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00118">mlir::SPIRVTypeConverter::getIndexType()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00778">mlir::getStridesAndOffset()</a>, <a class="el" href="Value_8h_source.html#l00114">mlir::Value::getType()</a>, <a class="el" href="DecomposeLinalgOps_8cpp_source.html#l00131">getZero()</a>, <a class="el" href="IR_2Types_8h_source.html#l00260">mlir::Type::isa()</a>, and <a class="el" href="SPIRVConversion_8cpp_source.html#l00719">linearizeIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVConversion_8cpp_source.html#l00809">getElementPtr()</a>.</p>

</div>
</div>
<a id="a6583bd4786f75b42698de079fe0bc892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6583bd4786f75b42698de079fe0bc892">&#9670;&nbsp;</a></span>getPrefixedOpcode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mlir::spirv::getPrefixedOpcode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wordCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spirv::Opcode&#160;</td>
          <td class="paramname"><em>opcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the word-count-prefixed opcode for an SPIR-V instruction. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVBinaryUtils_8cpp_source.html#l00061">61</a> of file <a class="el" href="SPIRVBinaryUtils_8cpp_source.html">SPIRVBinaryUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Serializer_8cpp_source.html#l00077">encodeInstructionInto()</a>.</p>

</div>
</div>
<a id="a6ced2ee0b51782190a208ff6d7266782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ced2ee0b51782190a208ff6d7266782">&#9670;&nbsp;</a></span>getPushConstantValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::spirv::getPushConstantValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>elementCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>integerType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the value at the given <code>offset</code> of the push constant storage with a total of <code>elementCount</code> <code>integerType</code> integers. </p>
<p>A global variable will be created in the nearest symbol table enclosing <code>op</code> for the push constant storage if not existing. Load ops will be created via the given <code>builder</code> to load values from the push constant. Returns null <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> on error. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVConversion_8cpp_source.html#l00693">693</a> of file <a class="el" href="SPIRVConversion_8cpp_source.html">SPIRVConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00225">mlir::Operation::emitError()</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="Builders_8cpp_source.html#l00190">mlir::Builder::getI32IntegerAttr()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00154">mlir::Operation::getLoc()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00266">mlir::SymbolTable::getNearestSymbolTable()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00680">getOrInsertPushConstantVariable()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00165">mlir::Operation::getParentOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00486">mlir::Operation::getRegion()</a>, and <a class="el" href="DecomposeLinalgOps_8cpp_source.html#l00131">getZero()</a>.</p>

</div>
</div>
<a id="a1d09788a1496828ace197176ce75e3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d09788a1496828ace197176ce75e3d9">&#9670;&nbsp;</a></span>getRecursiveImpliedCapabilities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;Capability, 0&gt; mlir::spirv::getRecursiveImpliedCapabilities </td>
          <td>(</td>
          <td class="paramtype">Capability&#160;</td>
          <td class="paramname"><em>cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the recursively implied capabilities for the given capability. </p>
<p>These capabilities are implicitly declared by the given capability. Compared to the above function, this function collects implied capabilities recursively: if an implicitly declared capability implicitly declares a third one, the third one will also be returned. </p>

<p class="reference">Referenced by <a class="el" href="TargetAndABI_8cpp_source.html#l00022">mlir::spirv::TargetEnv::TargetEnv()</a>.</p>

</div>
</div>
<a id="a7980ee0979f2d8550c4c1b941523f0c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7980ee0979f2d8550c4c1b941523f0c5">&#9670;&nbsp;</a></span>getTargetEnvAttrName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef mlir::spirv::getTargetEnvAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the attribute name for specifying SPIR-V target environment. </p>

<p class="definition">Definition at line <a class="el" href="TargetAndABI_8cpp_source.html#l00167">167</a> of file <a class="el" href="TargetAndABI_8cpp_source.html">TargetAndABI.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetAndABI_8cpp_source.html#l00179">lookupTargetEnv()</a>.</p>

</div>
</div>
<a id="aea108d3d4dffc88f5fd236bc360af868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea108d3d4dffc88f5fd236bc360af868">&#9670;&nbsp;</a></span>getVulkanElementPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::spirv::getVulkanElementPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>baseType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>basePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVConversion_8cpp_source.html#l00743">743</a> of file <a class="el" href="SPIRVConversion_8cpp_source.html">SPIRVConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00118">mlir::SPIRVTypeConverter::getIndexType()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00778">mlir::getStridesAndOffset()</a>, <a class="el" href="DecomposeLinalgOps_8cpp_source.html#l00131">getZero()</a>, and <a class="el" href="SPIRVConversion_8cpp_source.html#l00719">linearizeIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVConversion_8cpp_source.html#l00809">getElementPtr()</a>.</p>

</div>
</div>
<a id="a46c084c603df48bd16083158d58760c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c084c603df48bd16083158d58760c9">&#9670;&nbsp;</a></span>hash_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::hash_code mlir::spirv::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1spirv_1_1StructType_1_1MemberDecorationInfo.html">StructType::MemberDecorationInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>memberDecorationInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRVTypes_8cpp_source.html#l01143">1143</a> of file <a class="el" href="SPIRVTypes_8cpp_source.html">SPIRVTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVTypes_8h_source.html#l00292">mlir::spirv::StructType::MemberDecorationInfo::decoration</a>, and <a class="el" href="SPIRVTypes_8h_source.html#l00290">mlir::spirv::StructType::MemberDecorationInfo::memberIndex</a>.</p>

</div>
</div>
<a id="ab4e2e0e2f96602ed55862a37bee299b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e2e0e2f96602ed55862a37bee299b2">&#9670;&nbsp;</a></span>linearizeIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::spirv::linearizeIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>integerType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates IR to perform index linearization with the given <code>indices</code> and their corresponding <code>strides</code>, adding an initial <code>offset</code>. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVConversion_8cpp_source.html#l00719">719</a> of file <a class="el" href="SPIRVConversion_8cpp_source.html">SPIRVConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, and <a class="el" href="Matchers_8h_source.html#l00230">mlir::detail::enumerate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVConversion_8cpp_source.html#l00774">getOpenCLElementPtr()</a>, and <a class="el" href="SPIRVConversion_8cpp_source.html#l00743">getVulkanElementPtr()</a>.</p>

</div>
</div>
<a id="a56a2cd4522a0c39add4adcd2db5fe8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56a2cd4522a0c39add4adcd2db5fe8fc">&#9670;&nbsp;</a></span>lookupEntryPointABI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spirv::EntryPointABIAttr mlir::spirv::lookupEntryPointABI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries the entry point ABI on the nearest function-like op containing the given <code>op</code>. </p>
<p>Returns null attribute if not found. </p>

<p class="definition">Definition at line <a class="el" href="TargetAndABI_8cpp_source.html#l00133">133</a> of file <a class="el" href="TargetAndABI_8cpp_source.html">TargetAndABI.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00375">mlir::Operation::getAttrOfType()</a>, <a class="el" href="TargetAndABI_8cpp_source.html#l00119">getEntryPointABIAttrName()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00165">mlir::Operation::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetAndABI_8cpp_source.html#l00146">lookupLocalWorkGroupSize()</a>.</p>

</div>
</div>
<a id="afe035dc50594dd3b9d3c270a1f1959fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe035dc50594dd3b9d3c270a1f1959fa">&#9670;&nbsp;</a></span>lookupLocalWorkGroupSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a> mlir::spirv::lookupLocalWorkGroupSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries the local workgroup size from entry point ABI on the nearest function-like op containing the given <code>op</code>. </p>
<p>Returns null attribute if not found. </p>

<p class="definition">Definition at line <a class="el" href="TargetAndABI_8cpp_source.html#l00146">146</a> of file <a class="el" href="TargetAndABI_8cpp_source.html">TargetAndABI.cpp</a>.</p>

<p class="reference">References <a class="el" href="TargetAndABI_8cpp_source.html#l00133">lookupEntryPointABI()</a>.</p>

</div>
</div>
<a id="a78b51f6bb34187b8de569585d635a9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b51f6bb34187b8de569585d635a9eb">&#9670;&nbsp;</a></span>lookupTargetEnv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">spirv::TargetEnvAttr</a> mlir::spirv::lookupTargetEnv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries the target environment recursively from enclosing symbol table ops containing the given <code>op</code>. </p>

<p class="definition">Definition at line <a class="el" href="TargetAndABI_8cpp_source.html#l00179">179</a> of file <a class="el" href="TargetAndABI_8cpp_source.html">TargetAndABI.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00375">mlir::Operation::getAttrOfType()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00266">mlir::SymbolTable::getNearestSymbolTable()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00165">mlir::Operation::getParentOp()</a>, and <a class="el" href="TargetAndABI_8cpp_source.html#l00167">getTargetEnvAttrName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetAndABI_8cpp_source.html#l00195">lookupTargetEnvOrDefault()</a>, and <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00114">lowerEntryPointABIAttr()</a>.</p>

</div>
</div>
<a id="a2ae1ed3e62618274db5bad38955db408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae1ed3e62618274db5bad38955db408">&#9670;&nbsp;</a></span>lookupTargetEnvOrDefault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">spirv::TargetEnvAttr</a> mlir::spirv::lookupTargetEnvOrDefault </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries the target environment recursively from enclosing symbol table ops containing the given <code>op</code> or returns the default target environment as returned by <a class="el" href="namespacemlir_1_1spirv.html#aeb49fbe2ae3a33a6f06fcc29a3698ac2" title="Returns the default target environment: SPIR-V 1.0 with Shader capability and no extra extensions.">getDefaultTargetEnv()</a> if not provided. </p>

<p class="definition">Definition at line <a class="el" href="TargetAndABI_8cpp_source.html#l00195">195</a> of file <a class="el" href="TargetAndABI_8cpp_source.html">TargetAndABI.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00147">mlir::Operation::getContext()</a>, <a class="el" href="TargetAndABI_8cpp_source.html#l00169">getDefaultTargetEnv()</a>, and <a class="el" href="TargetAndABI_8cpp_source.html#l00179">lookupTargetEnv()</a>.</p>

<p class="reference">Referenced by <a class="el" href="GPUToSPIRV_8cpp_source.html#l00256">getDefaultABIAttrs()</a>.</p>

</div>
</div>
<a id="abac0b925a72437614eefd91e7f89540f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac0b925a72437614eefd91e7f89540f">&#9670;&nbsp;</a></span>mapMemorySpaceToOpenCLStorageClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; spirv::StorageClass &gt; mlir::spirv::mapMemorySpaceToOpenCLStorageClass </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>memorySpace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps MemRef memory spaces to storage classes for OpenCL-flavored SPIR-V using the default rule. </p>
<p>Returns None if the memory space is unknown. </p>

<p class="definition">Definition at line <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00102">102</a> of file <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html">MapMemRefStorageClassPass.cpp</a>.</p>

<p class="reference">References <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00092">OPENCL_STORAGE_SPACE_MAP_LIST</a>, and <a class="el" href="MapMemRefStorageClassPass_8cpp.html#a3d01385e94043fb63719e7abba469fd6">STORAGE_SPACE_MAP_FN</a>.</p>

</div>
</div>
<a id="a6c12269dafa2f03a9dfb3d1b8b8e62c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c12269dafa2f03a9dfb3d1b8b8e62c7">&#9670;&nbsp;</a></span>mapMemorySpaceToVulkanStorageClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; spirv::StorageClass &gt; mlir::spirv::mapMemorySpaceToVulkanStorageClass </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>memorySpace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps MemRef memory spaces to storage classes for Vulkan-flavored SPIR-V using the default rule. </p>
<p>Returns None if the memory space is unknown. </p>

<p class="definition">Definition at line <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00059">59</a> of file <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html">MapMemRefStorageClassPass.cpp</a>.</p>

<p class="reference">References <a class="el" href="MapMemRefStorageClassPass_8cpp.html#a3d01385e94043fb63719e7abba469fd6">STORAGE_SPACE_MAP_FN</a>, and <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00046">VULKAN_STORAGE_SPACE_MAP_LIST</a>.</p>

</div>
</div>
<a id="ae79bf721594b63e9d31bed5988e2fff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79bf721594b63e9d31bed5988e2fff0">&#9670;&nbsp;</a></span>mapOpenCLStorageClassToMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; unsigned &gt; mlir::spirv::mapOpenCLStorageClassToMemorySpace </td>
          <td>(</td>
          <td class="paramtype">spirv::StorageClass&#160;</td>
          <td class="paramname"><em>storageClass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps storage classes for OpenCL-flavored SPIR-V to MemRef memory spaces using the default rule. </p>
<p>Returns None if the storage class is unsupported. </p>

<p class="definition">Definition at line <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00118">118</a> of file <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html">MapMemRefStorageClassPass.cpp</a>.</p>

<p class="reference">References <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00092">OPENCL_STORAGE_SPACE_MAP_LIST</a>, and <a class="el" href="MapMemRefStorageClassPass_8cpp.html#a3d01385e94043fb63719e7abba469fd6">STORAGE_SPACE_MAP_FN</a>.</p>

</div>
</div>
<a id="a40a90cd07b1ac0fca0c4100768b74b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a90cd07b1ac0fca0c4100768b74b7e">&#9670;&nbsp;</a></span>mapVulkanStorageClassToMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; unsigned &gt; mlir::spirv::mapVulkanStorageClassToMemorySpace </td>
          <td>(</td>
          <td class="paramtype">spirv::StorageClass&#160;</td>
          <td class="paramname"><em>storageClass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps storage classes for Vulkan-flavored SPIR-V to MemRef memory spaces using the default rule. </p>
<p>Returns None if the storage class is unsupported. </p>

<p class="definition">Definition at line <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00075">75</a> of file <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html">MapMemRefStorageClassPass.cpp</a>.</p>

<p class="reference">References <a class="el" href="MapMemRefStorageClassPass_8cpp.html#a3d01385e94043fb63719e7abba469fd6">STORAGE_SPACE_MAP_FN</a>, and <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00046">VULKAN_STORAGE_SPACE_MAP_LIST</a>.</p>

</div>
</div>
<a id="a1f116e5f53987bfcf7bfb81faba201e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f116e5f53987bfcf7bfb81faba201e3">&#9670;&nbsp;</a></span>needsInterfaceVarABIAttrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::spirv::needsInterfaceVarABIAttrs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html">spirv::TargetEnvAttr</a>&#160;</td>
          <td class="paramname"><em>targetAttr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the given SPIR-V target (described by <a class="el" href="classmlir_1_1spirv_1_1TargetEnvAttr.html" title="An attribute that specifies the target version, allowed extensions and capabilities,...">TargetEnvAttr</a>) needs ABI attributes for interface variables (spirv.interface_var_abi). </p>

<p class="definition">Definition at line <a class="el" href="TargetAndABI_8cpp_source.html#l00109">109</a> of file <a class="el" href="TargetAndABI_8cpp_source.html">TargetAndABI.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVAttributes_8cpp_source.html#l00313">mlir::spirv::TargetEnvAttr::getCapabilities()</a>.</p>

<p class="reference">Referenced by <a class="el" href="GPUToSPIRV_8cpp_source.html#l00256">getDefaultABIAttrs()</a>.</p>

</div>
</div>
<a id="a5a0c9c44e47162a7027a178f81a20270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a0c9c44e47162a7027a178f81a20270">&#9670;&nbsp;</a></span>populateMemorySpaceToStorageClassPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::spirv::populateMemorySpaceToStorageClassPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1spirv_1_1MemorySpaceToStorageClassConverter.html">spirv::MemorySpaceToStorageClassConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for converting numeric MemRef memory spaces into SPIR-V symbolic ones. </p>

<p class="definition">Definition at line <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00281">281</a> of file <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html">MapMemRefStorageClassPass.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01587">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01563">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a765253a5d5815369244e7a4918fa1b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a765253a5d5815369244e7a4918fa1b89">&#9670;&nbsp;</a></span>populateSPIRVGLCanonicalizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::spirv::populateSPIRVGLCanonicalizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>results</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates patterns to run canoncalization that involves GL ops. </p>
<p>These patterns cannot be run in default canonicalization because GL ops aren't always available. So they should be involed specifically when needed. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVGLCanonicalization_8cpp_source.html#l00025">25</a> of file <a class="el" href="SPIRVGLCanonicalization_8cpp_source.html">SPIRVGLCanonicalization.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01587">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01563">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a764762951e6d168cda2fc62d3a4639ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764762951e6d168cda2fc62d3a4639ee">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::spirv::serialize </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>binary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1spirv_1_1SerializationOptions.html">SerializationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes the given SPIR-V <code>module</code> and writes to <code>binary</code>. </p>
<p>On failure, reports errors to the error handler registered with the MLIR context for <code>module</code>. </p>

<p class="reference">Referenced by <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00102">roundTripModule()</a>, and <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00073">serializeModule()</a>.</p>

</div>
</div>
<a id="ae02999329ba2aaf9d90c2154489e6ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae02999329ba2aaf9d90c2154489e6ace">&#9670;&nbsp;</a></span>Serializer::processOp&lt; spirv::CopyMemoryOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::spirv::Serializer::processOp&lt; spirv::CopyMemoryOp &gt; </td>
          <td>(</td>
          <td class="paramtype">spirv::CopyMemoryOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializeOps_8cpp_source.html#l00628">628</a> of file <a class="el" href="SerializeOps_8cpp_source.html">SerializeOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Serializer_8cpp_source.html#l00077">encodeInstructionInto()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="a9360bb2d9fb5d7a6d16eaa1a17132f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9360bb2d9fb5d7a6d16eaa1a17132f97">&#9670;&nbsp;</a></span>Serializer::processOp&lt; spirv::EntryPointOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::spirv::Serializer::processOp&lt; spirv::EntryPointOp &gt; </td>
          <td>(</td>
          <td class="paramtype">spirv::EntryPointOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializeOps_8cpp_source.html#l00537">537</a> of file <a class="el" href="SerializeOps_8cpp_source.html">SerializeOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Serializer_8cpp_source.html#l00077">encodeInstructionInto()</a>, <a class="el" href="SPIRVBinaryUtils_8cpp_source.html#l00066">encodeStringLiteralInto()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00885">mlir::FlatSymbolRefAttr::getValue()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="ad27df4c1b5396a8998d58603a044e5d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27df4c1b5396a8998d58603a044e5d0">&#9670;&nbsp;</a></span>Serializer::processOp&lt; spirv::ExecutionModeOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::spirv::Serializer::processOp&lt; spirv::ExecutionModeOp &gt; </td>
          <td>(</td>
          <td class="paramtype">spirv::ExecutionModeOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializeOps_8cpp_source.html#l00572">572</a> of file <a class="el" href="SerializeOps_8cpp_source.html">SerializeOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Serializer_8cpp_source.html#l00077">encodeInstructionInto()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="a8166d677987aab5a71255741c5b5a63b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8166d677987aab5a71255741c5b5a63b">&#9670;&nbsp;</a></span>Serializer::processOp&lt; spirv::FunctionCallOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::spirv::Serializer::processOp&lt; spirv::FunctionCallOp &gt; </td>
          <td>(</td>
          <td class="paramtype">spirv::FunctionCallOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializeOps_8cpp_source.html#l00601">601</a> of file <a class="el" href="SerializeOps_8cpp_source.html">SerializeOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Serializer_8cpp_source.html#l00077">encodeInstructionInto()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="IR_2Types_8h_source.html#l00260">mlir::Type::isa()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00160">value</a>.</p>

</div>
</div>
<a id="ae30d7e3a8c376ff9d21825446fd0e6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30d7e3a8c376ff9d21825446fd0e6a2">&#9670;&nbsp;</a></span>Serializer::processOp&lt; spirv::GenericCastToPtrExplicitOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::spirv::Serializer::processOp&lt; spirv::GenericCastToPtrExplicitOp &gt; </td>
          <td>(</td>
          <td class="paramtype">spirv::GenericCastToPtrExplicitOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializeOps_8cpp_source.html#l00673">673</a> of file <a class="el" href="SerializeOps_8cpp_source.html">SerializeOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00280">mlir::Type::cast()</a>, <a class="el" href="Serializer_8cpp_source.html#l00077">encodeInstructionInto()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="a0066624e2704755cca3404ab368dbcc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0066624e2704755cca3404ab368dbcc3">&#9670;&nbsp;</a></span>Serializer::processTypeDecoration&lt; spirv::ArrayType &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::spirv::Serializer::processTypeDecoration&lt; <a class="el" href="classmlir_1_1spirv_1_1ArrayType.html">spirv::ArrayType</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1spirv_1_1ArrayType.html">spirv::ArrayType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>resultID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Serializer_8cpp_source.html#l00269">269</a> of file <a class="el" href="Serializer_8cpp_source.html">Serializer.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVTypes_8cpp_source.html#l00066">mlir::spirv::ArrayType::getArrayStride()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="ab97cd75646073d697112f7f8cc79c503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97cd75646073d697112f7f8cc79c503">&#9670;&nbsp;</a></span>Serializer::processTypeDecoration&lt; spirv::RuntimeArrayType &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::spirv::Serializer::processTypeDecoration&lt; <a class="el" href="classmlir_1_1spirv_1_1RuntimeArrayType.html">spirv::RuntimeArrayType</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1spirv_1_1RuntimeArrayType.html">spirv::RuntimeArrayType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>resultID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Serializer_8cpp_source.html#l00279">279</a> of file <a class="el" href="Serializer_8cpp_source.html">Serializer.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVTypes_8cpp_source.html#l00543">mlir::spirv::RuntimeArrayType::getArrayStride()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a2478bd60cd2037a1d56b6ce17bd32bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2478bd60cd2037a1d56b6ce17bd32bb4">&#9670;&nbsp;</a></span>kGeneratorNumber</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t mlir::spirv::kGeneratorNumber = 22</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The serializer tool ID registered to the Khronos Group. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVBinaryUtils_8h_source.html#l00031">31</a> of file <a class="el" href="SPIRVBinaryUtils_8h_source.html">SPIRVBinaryUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVBinaryUtils_8cpp_source.html#l00018">appendModuleHeader()</a>.</p>

</div>
</div>
<a id="ad26be4ada4901dc6598761977638338c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26be4ada4901dc6598761977638338c">&#9670;&nbsp;</a></span>kHeaderWordCount</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned mlir::spirv::kHeaderWordCount = 5</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SPIR-V binary header word count. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVBinaryUtils_8h_source.html#l00025">25</a> of file <a class="el" href="SPIRVBinaryUtils_8h_source.html">SPIRVBinaryUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Serializer_8cpp_source.html#l00112">mlir::spirv::Serializer::collect()</a>.</p>

</div>
</div>
<a id="a5385336e089899ca7fcc7af2dbedf4e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5385336e089899ca7fcc7af2dbedf4e6">&#9670;&nbsp;</a></span>kMagicNumber</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t mlir::spirv::kMagicNumber = 0x07230203</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SPIR-V magic number. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVBinaryUtils_8h_source.html#l00028">28</a> of file <a class="el" href="SPIRVBinaryUtils_8h_source.html">SPIRVBinaryUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVBinaryUtils_8cpp_source.html#l00018">appendModuleHeader()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 17 2022 20:37:52 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
