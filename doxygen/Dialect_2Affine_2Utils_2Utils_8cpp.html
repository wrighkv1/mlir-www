<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/Affine/Utils/Utils.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">16.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a class="el" href="dir_30022079959872f4a1874dfcab7bb1fc.html">Affine</a></li><li class="navelem"><a class="el" href="dir_36ccfdf0d236a67fd57e73c4a5bad479.html">Utils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Utils.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="Dialect_2Affine_2Utils_8h_source.html">mlir/Dialect/Affine/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">mlir/Dialect/Affine/Analysis/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineValueMap_8h_source.html">mlir/Dialect/Affine/IR/AffineValueMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LoopUtils_8h_source.html">mlir/Dialect/Affine/LoopUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Arith_2Utils_2Utils_8h_source.html">mlir/Dialect/Arith/Utils/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="FuncOps_8h_source.html">mlir/Dialect/Func/IR/FuncOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="MemRef_8h_source.html">mlir/Dialect/MemRef/IR/MemRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineExprVisitor_8h_source.html">mlir/IR/AffineExprVisitor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="BlockAndValueMapping_8h_source.html">mlir/IR/BlockAndValueMapping.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dominance_8h_source.html">mlir/IR/Dominance.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2IntegerSet_8h_source.html">mlir/IR/IntegerSet.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="GreedyPatternRewriteDriver_8h_source.html">mlir/Transforms/GreedyPatternRewriteDriver.h</a>&quot;</code><br />
</div><div class="textblock"><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Include dependency graph for Utils.cpp:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="Dialect_2Affine_2Utils_2Utils_8cpp__incl.png" border="0" usemap="#alib_2Dialect_2Affine_2Utils_2Utils_8cpp" alt=""/></div>
<map name="alib_2Dialect_2Affine_2Utils_2Utils_8cpp" id="alib_2Dialect_2Affine_2Utils_2Utils_8cpp">
<area shape="rect" title=" " alt="" coords="3504,5,3634,47"/>
<area shape="rect" href="Dialect_2Affine_2Utils_8h.html" title=" " alt="" coords="2979,95,3119,136"/>
<area shape="rect" href="Dialect_2Affine_2Analysis_2Utils_8h.html" title=" " alt="" coords="3314,363,3454,404"/>
<area shape="rect" href="AffineOps_8h.html" title=" " alt="" coords="2856,184,2996,225"/>
<area shape="rect" href="AffineValueMap_8h.html" title=" " alt="" coords="3081,363,3238,404"/>
<area shape="rect" href="LoopUtils_8h.html" title=" " alt="" coords="3695,363,3835,404"/>
<area shape="rect" href="Dialect_2Arith_2Utils_2Utils_8h.html" title=" " alt="" coords="804,184,937,225"/>
<area shape="rect" href="FuncOps_8h.html" title=" " alt="" coords="518,273,668,315"/>
<area shape="rect" href="MemRef_8h.html" title=" " alt="" coords="1764,184,1921,225"/>
<area shape="rect" href="AffineExprVisitor_8h.html" title=" " alt="" coords="3657,102,3846,129"/>
<area shape="rect" href="BlockAndValueMapping_8h.html" title=" " alt="" coords="3725,191,3960,218"/>
<area shape="rect" href="Dominance_8h.html" title=" " alt="" coords="3921,102,4076,129"/>
<area shape="rect" href="mlir_2IR_2IntegerSet_8h.html" title=" " alt="" coords="4100,102,4248,129"/>
<area shape="rect" href="GreedyPatternRewriteDriver_8h.html" title=" " alt="" coords="4273,95,4494,136"/>
<area shape="rect" href="AffineAnalysis_8h.html" title=" " alt="" coords="2642,184,2832,225"/>
<area shape="rect" href="Arith_8h.html" title=" " alt="" coords="2092,273,2225,315"/>
<area shape="rect" href="Value_8h.html" title=" " alt="" coords="2768,541,2885,568"/>
<area shape="rect" title=" " alt="" coords="2630,459,2804,486"/>
<area shape="rect" href="IR_2Dialect_8h.html" title=" " alt="" coords="2048,370,2175,397"/>
<area shape="rect" href="OpImplementation_8h.html" title=" " alt="" coords="1354,370,1557,397"/>
<area shape="rect" href="CastInterfaces_8h.html" title=" " alt="" coords="2200,370,2426,397"/>
<area shape="rect" href="InferTypeOpInterface_8h.html" title=" " alt="" coords="1842,363,2024,404"/>
<area shape="rect" href="SideEffectInterfaces_8h.html" title=" " alt="" coords="1581,363,1768,404"/>
<area shape="rect" href="OperationSupport_8h.html" title=" " alt="" coords="2880,459,3074,486"/>
<area shape="rect" href="Location_8h.html" title=" " alt="" coords="2909,541,3045,568"/>
<area shape="rect" title=" " alt="" coords="3069,541,3146,568"/>
<area shape="rect" href="mlir_2Support_2LLVM_8h.html" title=" " alt="" coords="3108,616,3260,643"/>
<area shape="rect" href="mlir_2IR_2BuiltinTypes_8h.html" title=" " alt="" coords="1237,459,1397,486"/>
<area shape="rect" href="Builders_8h.html" title=" " alt="" coords="1016,459,1151,486"/>
<area shape="rect" href="AffineStructures_8h.html" title=" " alt="" coords="3422,452,3623,493"/>
<area shape="rect" href="mlir_2IR_2AffineMap_8h.html" title=" " alt="" coords="3098,459,3245,486"/>
<area shape="rect" href="Block_8h.html" title=" " alt="" coords="3648,459,3765,486"/>
<area shape="rect" href="LogicalResult_8h.html" title=" " alt="" coords="3421,541,3626,568"/>
<area shape="rect" href="AffineMemoryOpInterfaces_8h.html" title=" " alt="" coords="2826,363,3056,404"/>
<area shape="rect" href="ControlFlowInterfaces_8h.html" title=" " alt="" coords="2451,363,2650,404"/>
<area shape="rect" href="LoopLikeInterface_8h.html" title=" " alt="" coords="2926,273,3105,315"/>
<area shape="rect" title=" " alt="" coords="3129,273,3316,315"/>
<area shape="rect" title=" " alt="" coords="3340,273,3481,315"/>
<area shape="rect" href="Matchers_8h.html" title=" " alt="" coords="692,281,833,307"/>
<area shape="rect" href="PatternMatch_8h.html" title=" " alt="" coords="1112,370,1279,397"/>
<area shape="rect" href="FunctionInterfaces_8h.html" title=" " alt="" coords="683,370,884,397"/>
<area shape="rect" href="SymbolTable_8h.html" title=" " alt="" coords="203,459,367,486"/>
<area shape="rect" href="CallInterfaces_8h.html" title=" " alt="" coords="26,370,248,397"/>
<area shape="rect" title=" " alt="" coords="322,363,472,404"/>
<area shape="rect" title=" " alt="" coords="496,363,658,404"/>
<area shape="rect" href="ReshapeOpsUtils_8h.html" title=" " alt="" coords="1868,273,2017,315"/>
<area shape="rect" href="CopyOpInterface_8h.html" title=" " alt="" coords="908,281,1150,307"/>
<area shape="rect" href="ShapedOpInterfaces_8h.html" title=" " alt="" coords="1174,273,1361,315"/>
<area shape="rect" href="ViewLikeInterface_8h.html" title=" " alt="" coords="1385,273,1564,315"/>
<area shape="rect" title=" " alt="" coords="1639,273,1843,315"/>
</map>
</div>
</div>
<p><a href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;affine-utils&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8361db875ebdd069691084e31cb1f90a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a8361db875ebdd069691084e31cb1f90a">TileExprPattern</a> { <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a8361db875ebdd069691084e31cb1f90aa0a2909cee5222be1729a359f34c482f6">TileFloorDiv</a>
, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a8361db875ebdd069691084e31cb1f90aafab640cbd0e0ef2d840e36d087e561ec">TileMod</a>
, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a8361db875ebdd069691084e31cb1f90aabb4b0501a7b81d89719cae036aa1937e">TileNone</a>
 }</td></tr>
<tr class="memdesc:a8361db875ebdd069691084e31cb1f90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to set patterns of affine expr in tiled-layout map.  <a href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a8361db875ebdd069691084e31cb1f90a">More...</a><br /></td></tr>
<tr class="separator:a8361db875ebdd069691084e31cb1f90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a91ed5c48cf2d60834e274223a2fe3391"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a91ed5c48cf2d60834e274223a2fe3391">promoteIfBlock</a> (AffineIfOp ifOp, bool elseBlock)</td></tr>
<tr class="memdesc:a91ed5c48cf2d60834e274223a2fe3391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes the <code>then</code> or the <code>else</code> block of <code>ifOp</code> (depending on whether <code>elseBlock</code> is false or true) into <code>ifOp</code>'s containing block, and discards the rest of the op.  <a href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a91ed5c48cf2d60834e274223a2fe3391">More...</a><br /></td></tr>
<tr class="separator:a91ed5c48cf2d60834e274223a2fe3391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c58877969ba751da8da214b1866e2e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#ac0c58877969ba751da8da214b1866e2e">getOutermostInvariantForOp</a> (AffineIfOp ifOp)</td></tr>
<tr class="memdesc:ac0c58877969ba751da8da214b1866e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the outermost affine.for/parallel op that the <code>ifOp</code> is invariant on.  <a href="Dialect_2Affine_2Utils_2Utils_8cpp.html#ac0c58877969ba751da8da214b1866e2e">More...</a><br /></td></tr>
<tr class="separator:ac0c58877969ba751da8da214b1866e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3327936fe7d848e7ec99d8efaebf3794"><td class="memItemLeft" align="right" valign="top">static AffineIfOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a3327936fe7d848e7ec99d8efaebf3794">hoistAffineIfOp</a> (AffineIfOp ifOp, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *hoistOverOp)</td></tr>
<tr class="memdesc:a3327936fe7d848e7ec99d8efaebf3794"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper for the mechanics of <a class="el" href="namespacemlir.html#a57bafa91f432ad40bb6246fbcbd555fe" title="Hoists out affine.if/else to as high as possible, i.e., past all invariant affine....">mlir::hoistAffineIfOp</a>.  <a href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a3327936fe7d848e7ec99d8efaebf3794">More...</a><br /></td></tr>
<tr class="separator:a3327936fe7d848e7ec99d8efaebf3794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b5e959a281013c569a8ca6720021e3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a68b5e959a281013c569a8ca6720021e3">forwardStoreToLoad</a> (AffineReadOpInterface loadOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;loadOpsToErase, <a class="el" href="classllvm_1_1SmallPtrSetImpl.html">SmallPtrSetImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;memrefsToErase, <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;domInfo)</td></tr>
<tr class="memdesc:a68b5e959a281013c569a8ca6720021e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to eliminate loadOp by replacing it with a value stored into memory which the load is guaranteed to retrieve.  <a href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a68b5e959a281013c569a8ca6720021e3">More...</a><br /></td></tr>
<tr class="separator:a68b5e959a281013c569a8ca6720021e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea670d31490e9e32ff58e3ef96e5a60"><td class="memItemLeft" align="right" valign="top">template bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a8ea670d31490e9e32ff58e3ef96e5a60">mlir::hasNoInterveningEffect&lt; mlir::MemoryEffects::Read, mlir::AffineReadOpInterface &gt;</a> (<a class="el" href="classmlir_1_1Operation.html">mlir::Operation</a> *, mlir::AffineReadOpInterface)</td></tr>
<tr class="separator:a8ea670d31490e9e32ff58e3ef96e5a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ea120a9473888db3f617dac2404687"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a73ea120a9473888db3f617dac2404687">findUnusedStore</a> (AffineWriteOpInterface writeA, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;opsToErase, <a class="el" href="classmlir_1_1PostDominanceInfo.html">PostDominanceInfo</a> &amp;postDominanceInfo)</td></tr>
<tr class="separator:a73ea120a9473888db3f617dac2404687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c958409217e6311092b570801a9842"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a35c958409217e6311092b570801a9842">loadCSE</a> (AffineReadOpInterface loadA, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;loadOpsToErase, <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;domInfo)</td></tr>
<tr class="separator:a35c958409217e6311092b570801a9842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533cf0842c1c6bce487e9c42d7593543"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a533cf0842c1c6bce487e9c42d7593543">getTileSizePos</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; std::tuple&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, unsigned, unsigned &gt;&gt; &amp;tileSizePos)</td></tr>
<tr class="memdesc:a533cf0842c1c6bce487e9c42d7593543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>map</code> is a tiled layout.  <a href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a533cf0842c1c6bce487e9c42d7593543">More...</a><br /></td></tr>
<tr class="separator:a533cf0842c1c6bce487e9c42d7593543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb08d5234d99d6f4af63a5d0466028d8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#adb08d5234d99d6f4af63a5d0466028d8">isNormalizedMemRefDynamicDim</a> (unsigned dim, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> layoutMap, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; unsigned &gt; &amp;inMemrefTypeDynDims, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:adb08d5234d99d6f4af63a5d0466028d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>dim</code> dimension of memrefType with <code>layoutMap</code> becomes dynamic after normalization.  <a href="Dialect_2Affine_2Utils_2Utils_8cpp.html#adb08d5234d99d6f4af63a5d0466028d8">More...</a><br /></td></tr>
<tr class="separator:adb08d5234d99d6f4af63a5d0466028d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d1fa11b6b2534b14e10e5214f5a108"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#ab1d1fa11b6b2534b14e10e5214f5a108">createDimSizeExprForTiledLayout</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> oldMapOutput, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a8361db875ebdd069691084e31cb1f90a">TileExprPattern</a> pat)</td></tr>
<tr class="memdesc:ab1d1fa11b6b2534b14e10e5214f5a108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create affine expr to calculate dimension size for a tiled-layout map.  <a href="Dialect_2Affine_2Utils_2Utils_8cpp.html#ab1d1fa11b6b2534b14e10e5214f5a108">More...</a><br /></td></tr>
<tr class="separator:ab1d1fa11b6b2534b14e10e5214f5a108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01de90caeccd203207a3806b7dae0ba3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a01de90caeccd203207a3806b7dae0ba3">createNewDynamicSizes</a> (MemRefType oldMemRefType, MemRefType newMemRefType, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, memref::AllocOp *allocOp, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> b, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;newDynamicSizes)</td></tr>
<tr class="memdesc:a01de90caeccd203207a3806b7dae0ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new maps to calculate each dimension size of <code>newMemRefType</code>, and create <code>newDynamicSizes</code> from them by using AffineApplyOp.  <a href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a01de90caeccd203207a3806b7dae0ba3">More...</a><br /></td></tr>
<tr class="separator:a01de90caeccd203207a3806b7dae0ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5496b69e9e151385e3cc306aa3b8a6eb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a5496b69e9e151385e3cc306aa3b8a6eb">getIndexProduct</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; set)</td></tr>
<tr class="memdesc:a5496b69e9e151385e3cc306aa3b8a6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create IR that computes the product of all elements in the set.  <a href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a5496b69e9e151385e3cc306aa3b8a6eb">More...</a><br /></td></tr>
<tr class="separator:a5496b69e9e151385e3cc306aa3b8a6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&nbsp;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;affine-utils&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00029">29</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a8361db875ebdd069691084e31cb1f90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8361db875ebdd069691084e31cb1f90a">&#9670;&nbsp;</a></span>TileExprPattern</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a8361db875ebdd069691084e31cb1f90a">TileExprPattern</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum to set patterns of affine expr in tiled-layout map. </p>
<p>TileFloorDiv: &lt;dim expr&gt; div &lt;tile size&gt; TileMod: &lt;dim expr&gt; mod &lt;tile size&gt; TileNone: None of the above Example: #tiled_2d_128x256 = affine_map&lt;(d0, d1) -&gt; (d0 div 128, d1 div 256, d0 mod 128, d1 mod 256)&gt; "d0 div 128" and "d1 div 256" ==&gt; TileFloorDiv "d0 mod 128" and "d1 mod 256" ==&gt; TileMod </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8361db875ebdd069691084e31cb1f90aa0a2909cee5222be1729a359f34c482f6"></a>TileFloorDiv&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8361db875ebdd069691084e31cb1f90aafab640cbd0e0ef2d840e36d087e561ec"></a>TileMod&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8361db875ebdd069691084e31cb1f90aabb4b0501a7b81d89719cae036aa1937e"></a>TileNone&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01455">1455</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab1d1fa11b6b2534b14e10e5214f5a108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d1fa11b6b2534b14e10e5214f5a108">&#9670;&nbsp;</a></span>createDimSizeExprForTiledLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> createDimSizeExprForTiledLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>oldMapOutput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a8361db875ebdd069691084e31cb1f90a">TileExprPattern</a>&#160;</td>
          <td class="paramname"><em>pat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create affine expr to calculate dimension size for a tiled-layout map. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01582">1582</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00291">mlir::AffineExpr::cast()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00046">mlir::getAffineBinaryOpExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00303">mlir::AffineBinaryOpExpr::getLHS()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00306">mlir::AffineBinaryOpExpr::getRHS()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01455">TileFloorDiv</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01455">TileMod</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01637">createNewDynamicSizes()</a>.</p>

</div>
</div>
<a id="a01de90caeccd203207a3806b7dae0ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01de90caeccd203207a3806b7dae0ba3">&#9670;&nbsp;</a></span>createNewDynamicSizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void createNewDynamicSizes </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>oldMemRefType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>newMemRefType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::AllocOp *&#160;</td>
          <td class="paramname"><em>allocOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newDynamicSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new maps to calculate each dimension size of <code>newMemRefType</code>, and create <code>newDynamicSizes</code> from them by using AffineApplyOp. </p>
<p>Steps for normalizing dynamic memrefs for a tiled layout map Example: #map0 = affine_map&lt;(d0, d1) -&gt; (d0, d1 floordiv 32, d1 mod 32)&gt; %0 = dim arg0, c1 :memref&lt;4x?xf32&gt; %1 = alloc(%0) : memref&lt;4x?xf32, #map0&gt;</p>
<p>(Before this function)</p><ol type="1">
<li>Check if <code>map</code>(#map0) is a tiled layout using <code><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a533cf0842c1c6bce487e9c42d7593543" title="Check if map is a tiled layout.">getTileSizePos()</a></code>. Only single layout map is supported.</li>
<li>Create normalized memrefType using <code><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#adb08d5234d99d6f4af63a5d0466028d8" title="Check if dim dimension of memrefType with layoutMap becomes dynamic after normalization.">isNormalizedMemRefDynamicDim()</a></code>. It is memref&lt;4x?x?xf32&gt; in the above example.</li>
</ol>
<p>(In this function)</p><ol type="1">
<li>Create new maps to calculate each dimension of the normalized memrefType using <code><a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#ab1d1fa11b6b2534b14e10e5214f5a108" title="Create affine expr to calculate dimension size for a tiled-layout map.">createDimSizeExprForTiledLayout()</a></code>. In the tiled layout, the dimension size can be calculated by replacing "floordiv &lt;tile size&gt;" with "ceildiv &lt;tile size&gt;" and "mod &lt;tile size&gt;" with "&lt;tile size&gt;".</li>
</ol>
<ul>
<li>New map in the above example #map0 = affine_map&lt;(d0, d1) -&gt; (d0)&gt; #map1 = affine_map&lt;(d0, d1) -&gt; (d1 ceildiv 32)&gt; #map2 = affine_map&lt;(d0, d1) -&gt; (32)&gt;</li>
</ul>
<ol type="1">
<li>Create AffineApplyOp to apply the new maps. The output of AffineApplyOp is used in dynamicSizes of new AllocOp. %0 = dim arg0, c1 : memref&lt;4x?xf32&gt; c4 = arith.constant 4 : index %1 = affine.apply #map1(c4, %0) %2 = affine.apply #map2(c4, %0) </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01637">1637</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01582">createDimSizeExprForTiledLayout()</a>, <a class="el" href="Builders_8cpp_source.html#l00056">mlir::Builder::getIndexType()</a>, <a class="el" href="Builders_8cpp_source.html#l00212">mlir::Builder::getIntegerAttr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00315">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00310">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00319">mlir::AffineMap::getResults()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01463">getTileSizePos()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01455">TileFloorDiv</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01455">TileMod</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01455">TileNone</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01687">mlir::normalizeMemRef()</a>.</p>

</div>
</div>
<a id="a73ea120a9473888db3f617dac2404687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ea120a9473888db3f617dac2404687">&#9670;&nbsp;</a></span>findUnusedStore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void findUnusedStore </td>
          <td>(</td>
          <td class="paramtype">AffineWriteOpInterface&#160;</td>
          <td class="paramname"><em>writeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>opsToErase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PostDominanceInfo.html">PostDominanceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>postDominanceInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00906">906</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00650">mlir::Operation::getUsers()</a>, and <a class="el" href="Dominance_8h_source.html#l00184">mlir::PostDominanceInfo::postDominates()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01031">mlir::affineScalarReplace()</a>.</p>

</div>
</div>
<a id="a68b5e959a281013c569a8ca6720021e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b5e959a281013c569a8ca6720021e3">&#9670;&nbsp;</a></span>forwardStoreToLoad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> forwardStoreToLoad </td>
          <td>(</td>
          <td class="paramtype">AffineReadOpInterface&#160;</td>
          <td class="paramname"><em>loadOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>loadOpsToErase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallPtrSetImpl.html">SmallPtrSetImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>memrefsToErase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>domInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to eliminate loadOp by replacing it with a value stored into memory which the load is guaranteed to retrieve. </p>
<p>This check involves three components: 1) The store and load must be on the same location 2) The store must dominate (and therefore must always occur prior to) the load 3) No other operations will overwrite the memory loaded between the given load and store. If such a value exists, the replaced <code>loadOp</code> will be added to <code>loadOpsToErase</code> and its memref will be added to <code>memrefsToErase</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00838">838</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dominance_8h_source.html#l00137">mlir::DominanceInfo::dominates()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Value_8h_source.html#l00114">mlir::Value::getType()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01031">mlir::affineScalarReplace()</a>.</p>

</div>
</div>
<a id="a5496b69e9e151385e3cc306aa3b8a6eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5496b69e9e151385e3cc306aa3b8a6eb">&#9670;&nbsp;</a></span>getIndexProduct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt; getIndexProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create IR that computes the product of all elements in the set. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01838">1838</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00316">mlir::detail::bindSymbols()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Builders_8h_source.html#l00054">mlir::Builder::getContext()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01005">mlir::makeComposedFoldedAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01850">mlir::delinearizeIndex()</a>.</p>

</div>
</div>
<a id="ac0c58877969ba751da8da214b1866e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c58877969ba751da8da214b1866e2e">&#9670;&nbsp;</a></span>getOutermostInvariantForOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Operation.html">Operation</a>* getOutermostInvariantForOp </td>
          <td>(</td>
          <td class="paramtype">AffineIfOp&#160;</td>
          <td class="paramname"><em>ifOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the outermost affine.for/parallel op that the <code>ifOp</code> is invariant on. </p>
<p>The <code>ifOp</code> could be hoisted and placed right before such an operation. This method assumes that the ifOp has been canonicalized (to be correct and effective). </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00260">260</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00295">mlir::Operation::getOperands()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00408">mlir::hoistAffineIfOp()</a>.</p>

</div>
</div>
<a id="a533cf0842c1c6bce487e9c42d7593543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533cf0842c1c6bce487e9c42d7593543">&#9670;&nbsp;</a></span>getTileSizePos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> getTileSizePos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; std::tuple&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, unsigned, unsigned &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tileSizePos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <code>map</code> is a tiled layout. </p>
<p>In the tiled layout, specific k dimensions being floordiv'ed by respective tile sizes appeare in a mod with the same tile sizes, and no other expression involves those k dimensions. This function stores a vector of tuples (<code>tileSizePos</code>) including AffineExpr for tile size, positions of corresponding <code>floordiv</code> and <code>mod</code>. If it is not a tiled layout, an empty vector is returned. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01463">1463</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00291">mlir::AffineExpr::cast()</a>, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133abaa422535e7ce48b442cc07089e64e7a">mlir::FloorDiv</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00303">mlir::AffineBinaryOpExpr::getLHS()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00319">mlir::AffineMap::getResults()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00306">mlir::AffineBinaryOpExpr::getRHS()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00270">mlir::AffineExpr::isa()</a>, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a7aeb0277500c86e4aa6bd23f9a737942">mlir::Mod</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01637">createNewDynamicSizes()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01687">mlir::normalizeMemRef()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01745">mlir::normalizeMemRefType()</a>.</p>

</div>
</div>
<a id="a3327936fe7d848e7ec99d8efaebf3794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3327936fe7d848e7ec99d8efaebf3794">&#9670;&nbsp;</a></span>hoistAffineIfOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static AffineIfOp hoistAffineIfOp </td>
          <td>(</td>
          <td class="paramtype">AffineIfOp&#160;</td>
          <td class="paramname"><em>ifOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>hoistOverOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper for the mechanics of <a class="el" href="namespacemlir.html#a57bafa91f432ad40bb6246fbcbd555fe" title="Hoists out affine.if/else to as high as possible, i.e., past all invariant affine....">mlir::hoistAffineIfOp</a>. </p>
<p>Hoists <code>ifOp</code> just over <code>hoistOverOp</code>. Returns the new hoisted op if any hoisting happened, otherwise the same <code>ifOp</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00286">286</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00051">mlir::WalkResult::advance()</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00070">mlir::BlockAndValueMapping::clear()</a>, <a class="el" href="Builders_8cpp_source.html#l00510">mlir::OpBuilder::clone()</a>, <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00144">mlir::Operation::getBlock()</a>, <a class="el" href="Builders_8cpp_source.html#l00101">mlir::Builder::getBoolAttr()</a>, <a class="el" href="Block_8h_source.html#l00126">mlir::Block::getOperations()</a>, <a class="el" href="Builders_8cpp_source.html#l00243">mlir::Builder::getStringAttr()</a>, <a class="el" href="Visitors_8h_source.html#l00050">mlir::WalkResult::interrupt()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00244">promoteIfBlock()</a>, and <a class="el" href="Builders_8h_source.html#l00364">mlir::OpBuilder::setInsertionPointAfter()</a>.</p>

</div>
</div>
<a id="adb08d5234d99d6f4af63a5d0466028d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb08d5234d99d6f4af63a5d0466028d8">&#9670;&nbsp;</a></span>isNormalizedMemRefDynamicDim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isNormalizedMemRefDynamicDim </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>layoutMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>inMemrefTypeDynDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <code>dim</code> dimension of memrefType with <code>layoutMap</code> becomes dynamic after normalization. </p>
<p>Dimensions that include dynamic dimensions in the map output will become dynamic dimensions. Return true if <code>dim</code> is dynamic dimension.</p>
<p>Example: #map0 = affine_map&lt;(d0, d1) -&gt; (d0, d1 floordiv 32, d1 mod 32)&gt;</p>
<p>If d1 is dynamic dimension, 2nd and 3rd dimension of map output are dynamic. memref&lt;4x?xf32, #map0&gt; ==&gt; memref&lt;4x?x?xf32&gt; </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01562">1562</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00319">mlir::AffineMap::getResults()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00270">mlir::AffineExpr::isa()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00029">mlir::AffineExpr::walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01745">mlir::normalizeMemRefType()</a>.</p>

</div>
</div>
<a id="a35c958409217e6311092b570801a9842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c958409217e6311092b570801a9842">&#9670;&nbsp;</a></span>loadCSE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void loadCSE </td>
          <td>(</td>
          <td class="paramtype">AffineReadOpInterface&#160;</td>
          <td class="paramname"><em>loadA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>loadOpsToErase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>domInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00951">951</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dominance_8h_source.html#l00137">mlir::DominanceInfo::dominates()</a>, and <a class="el" href="Value_8h_source.html#l00158">mlir::Value::replaceAllUsesWith()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01031">mlir::affineScalarReplace()</a>.</p>

</div>
</div>
<a id="a8ea670d31490e9e32ff58e3ef96e5a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea670d31490e9e32ff58e3ef96e5a60">&#9670;&nbsp;</a></span>mlir::hasNoInterveningEffect&lt; mlir::MemoryEffects::Read, mlir::AffineReadOpInterface &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template bool <a class="el" href="namespacemlir.html#af91b446fee7cd36a479244747c5d6b18">mlir::hasNoInterveningEffect</a>&lt; <a class="el" href="structmlir_1_1MemoryEffects_1_1Read.html">mlir::MemoryEffects::Read</a>, mlir::AffineReadOpInterface &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">mlir::Operation</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::AffineReadOpInterface&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91ed5c48cf2d60834e274223a2fe3391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ed5c48cf2d60834e274223a2fe3391">&#9670;&nbsp;</a></span>promoteIfBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void promoteIfBlock </td>
          <td>(</td>
          <td class="paramtype">AffineIfOp&#160;</td>
          <td class="paramname"><em>ifOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>elseBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Promotes the <code>then</code> or the <code>else</code> block of <code>ifOp</code> (depending on whether <code>elseBlock</code> is false or true) into <code>ifOp</code>'s containing block, and discards the rest of the op. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00244">244</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00132">mlir::Block::begin()</a>, <a class="el" href="Block_8h_source.html#l00133">mlir::Block::end()</a>, and <a class="el" href="Block_8h_source.html#l00126">mlir::Block::getOperations()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00286">hoistAffineIfOp()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 17 2022 20:37:45 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
