<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::tensor Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">16.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1tensor.html">tensor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::tensor Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html">ExtractSliceFromCollapseHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class assists with generating IR required to materialize an arbitrary-sized slice from the result of a CollapseShapeOp.  <a href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9d4142525a7f3e353e50a35cd66c945d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a9d4142525a7f3e353e50a35cd66c945d">ControlConstantExtractSliceFusionFn</a> = std::function&lt; bool(ExtractSliceOp)&gt;</td></tr>
<tr class="memdesc:a9d4142525a7f3e353e50a35cd66c945d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to control the folding of constant and extract slice.  <a href="namespacemlir_1_1tensor.html#a9d4142525a7f3e353e50a35cd66c945d">More...</a><br /></td></tr>
<tr class="separator:a9d4142525a7f3e353e50a35cd66c945d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac1b0cdf08bf148506f761f70f24059f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#ac1b0cdf08bf148506f761f70f24059f0">preservesStaticInformation</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> source, <a class="el" href="classmlir_1_1Type.html">Type</a> target)</td></tr>
<tr class="memdesc:ac1b0cdf08bf148506f761f70f24059f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>target</code> is a ranked tensor type that preserves static information available in the <code>source</code> ranked tensor type.  <a href="namespacemlir_1_1tensor.html#ac1b0cdf08bf148506f761f70f24059f0">More...</a><br /></td></tr>
<tr class="separator:ac1b0cdf08bf148506f761f70f24059f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30deb019e8a71c65e127e245b9cf63fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a30deb019e8a71c65e127e245b9cf63fb">canFoldIntoConsumerOp</a> (CastOp castOp)</td></tr>
<tr class="memdesc:a30deb019e8a71c65e127e245b9cf63fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether tensor::CastOp casts to a more dynamic version of the source tensor.  <a href="namespacemlir_1_1tensor.html#a30deb019e8a71c65e127e245b9cf63fb">More...</a><br /></td></tr>
<tr class="separator:a30deb019e8a71c65e127e245b9cf63fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbbd2b47f452ac54390390eb2099edd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a1bbbd2b47f452ac54390390eb2099edd">canFoldIntoProducerOp</a> (CastOp castOp)</td></tr>
<tr class="memdesc:a1bbbd2b47f452ac54390390eb2099edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the tensor::CastOp casts to a more static version of the source tensor.  <a href="namespacemlir_1_1tensor.html#a1bbbd2b47f452ac54390390eb2099edd">More...</a><br /></td></tr>
<tr class="separator:a1bbbd2b47f452ac54390390eb2099edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e4cc4be054eec0b07a42e2f63f05f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a00e4cc4be054eec0b07a42e2f63f05f2">foldTensorCast</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a00e4cc4be054eec0b07a42e2f63f05f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs folding of any operand of <code>op</code> if it comes from a tensor::CastOp that can be folded.  <a href="namespacemlir_1_1tensor.html#a00e4cc4be054eec0b07a42e2f63f05f2">More...</a><br /></td></tr>
<tr class="separator:a00e4cc4be054eec0b07a42e2f63f05f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d0935f6c223e44294137605bb39d60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#ad1d0935f6c223e44294137605bb39d60">getMixedSizes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="memdesc:ad1d0935f6c223e44294137605bb39d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimensions of the given tensor value.  <a href="namespacemlir_1_1tensor.html#ad1d0935f6c223e44294137605bb39d60">More...</a><br /></td></tr>
<tr class="separator:ad1d0935f6c223e44294137605bb39d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfe3bede328e5dc72de55dfca72fe1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a6cfe3bede328e5dc72de55dfca72fe1d">createCanonicalRankReducingExtractSliceOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> tensor, RankedTensorType targetType)</td></tr>
<tr class="memdesc:a6cfe3bede328e5dc72de55dfca72fe1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rank-reducing ExtractSliceOp @[0 .  <a href="namespacemlir_1_1tensor.html#a6cfe3bede328e5dc72de55dfca72fe1d">More...</a><br /></td></tr>
<tr class="separator:a6cfe3bede328e5dc72de55dfca72fe1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0730cfcf9d984a57414d62c2b18b2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a6b0730cfcf9d984a57414d62c2b18b2f">createCanonicalRankReducingInsertSliceOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> tensor, <a class="el" href="classmlir_1_1Value.html">Value</a> dest)</td></tr>
<tr class="memdesc:a6b0730cfcf9d984a57414d62c2b18b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rank-reducing InsertSliceOp @[0 .  <a href="namespacemlir_1_1tensor.html#a6b0730cfcf9d984a57414d62c2b18b2f">More...</a><br /></td></tr>
<tr class="separator:a6b0730cfcf9d984a57414d62c2b18b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e502153b3c46a11dad42045c36bc31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a90e502153b3c46a11dad42045c36bc31">getOrCreateDestination</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpResult.html">OpResult</a> opResult)</td></tr>
<tr class="memdesc:a90e502153b3c46a11dad42045c36bc31"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a helper function for DestinationStyleOpInterface.  <a href="namespacemlir_1_1tensor.html#a90e502153b3c46a11dad42045c36bc31">More...</a><br /></td></tr>
<tr class="separator:a90e502153b3c46a11dad42045c36bc31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28262a44a78b9ce6b2e43195dd2a085"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#ad28262a44a78b9ce6b2e43195dd2a085">getOrCreateDestinations</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:ad28262a44a78b9ce6b2e43195dd2a085"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a helper function for DestinationStyleOpInterface.  <a href="namespacemlir_1_1tensor.html#ad28262a44a78b9ce6b2e43195dd2a085">More...</a><br /></td></tr>
<tr class="separator:ad28262a44a78b9ce6b2e43195dd2a085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edfdd5a23215fd0d8d587be6ebae28a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a0edfdd5a23215fd0d8d587be6ebae28a">populateFoldConstantExtractSlicePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="namespacemlir_1_1tensor.html#a9d4142525a7f3e353e50a35cd66c945d">ControlConstantExtractSliceFusionFn</a> &amp;controlFn=[](ExtractSliceOp op) { return false;})</td></tr>
<tr class="memdesc:a0edfdd5a23215fd0d8d587be6ebae28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold the extract slice op with its constant operand.  <a href="namespacemlir_1_1tensor.html#a0edfdd5a23215fd0d8d587be6ebae28a">More...</a><br /></td></tr>
<tr class="separator:a0edfdd5a23215fd0d8d587be6ebae28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537a26573013e086958f9f7a18fa65d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a537a26573013e086958f9f7a18fa65d5">registerInferTypeOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">mlir::DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a537a26573013e086958f9f7a18fa65d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers external models for Infer <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> interfaces for tensor ops.  <a href="namespacemlir_1_1tensor.html#a537a26573013e086958f9f7a18fa65d5">More...</a><br /></td></tr>
<tr class="separator:a537a26573013e086958f9f7a18fa65d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a54e3a80e7a3bee2ffe4245b76beae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#aa9a54e3a80e7a3bee2ffe4245b76beae">bubbleUpPadSlice</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, tensor::PadOp padOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; offsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizes, bool generateZeroSliceGuard=true)</td></tr>
<tr class="memdesc:aa9a54e3a80e7a3bee2ffe4245b76beae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bubbles up a slice of this pad by taking the slice first and then performing the padding.  <a href="namespacemlir_1_1tensor.html#aa9a54e3a80e7a3bee2ffe4245b76beae">More...</a><br /></td></tr>
<tr class="separator:aa9a54e3a80e7a3bee2ffe4245b76beae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a4bebf333acf49aa338a6f810152f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a84a4bebf333acf49aa338a6f810152f5">registerTilingInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">mlir::DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a84a4bebf333acf49aa338a6f810152f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers external models for Tiling interface for tensor ops.  <a href="namespacemlir_1_1tensor.html#a84a4bebf333acf49aa338a6f810152f5">More...</a><br /></td></tr>
<tr class="separator:a84a4bebf333acf49aa338a6f810152f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09a0f22283c4ef45935f058b6f629cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#aa09a0f22283c4ef45935f058b6f629cb">registerBufferizableOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:aa09a0f22283c4ef45935f058b6f629cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3303ddaae66c9995b0938917ae210d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#aac3303ddaae66c9995b0938917ae210d">populateSplitPaddingPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> baseBenefit=1)</td></tr>
<tr class="memdesc:aac3303ddaae66c9995b0938917ae210d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>patterns</code> with patterns to wrap a tensor.pad op with an scf.if op to separate the cases where we don't need padding (all pad sizes are actually zeros) and where we indeed need padding.  <a href="namespacemlir_1_1tensor.html#aac3303ddaae66c9995b0938917ae210d">More...</a><br /></td></tr>
<tr class="separator:aac3303ddaae66c9995b0938917ae210d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ef1b6b64e9e6fdcdb845aec25a1e41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#aa6ef1b6b64e9e6fdcdb845aec25a1e41">replaceExtractSliceWithTiledProducer</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, tensor::ExtractSliceOp sliceOp, <a class="el" href="classmlir_1_1OpResult.html">OpResult</a> producerOp)</td></tr>
<tr class="memdesc:aa6ef1b6b64e9e6fdcdb845aec25a1e41"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to swap an <code>tensor.extract_slice</code> with its producer when the producer implements the <code>TilingInterface</code>.  <a href="namespacemlir_1_1tensor.html#aa6ef1b6b64e9e6fdcdb845aec25a1e41">More...</a><br /></td></tr>
<tr class="separator:aa6ef1b6b64e9e6fdcdb845aec25a1e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354a5a1166be4a8db79d65866e88182e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a354a5a1166be4a8db79d65866e88182e">populateMergeConsecutiveInsertExtractSlicePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a354a5a1166be4a8db79d65866e88182e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects patterns to merge consecutive tensor.insert_slice/extract_slice into one.  <a href="namespacemlir_1_1tensor.html#a354a5a1166be4a8db79d65866e88182e">More...</a><br /></td></tr>
<tr class="separator:a354a5a1166be4a8db79d65866e88182e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5549d629eff95d24dfb8efeb0f15e29e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a5549d629eff95d24dfb8efeb0f15e29e">simplifyCollapseShapeWithRankReducingExtractSlice</a> (tensor::CollapseShapeOp op, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter)</td></tr>
<tr class="memdesc:a5549d629eff95d24dfb8efeb0f15e29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to simplify a <code>tensor.collapse_shape</code> operation by inserting a single rank-reducing <code>tensor.extract_slice</code> operation.  <a href="namespacemlir_1_1tensor.html#a5549d629eff95d24dfb8efeb0f15e29e">More...</a><br /></td></tr>
<tr class="separator:a5549d629eff95d24dfb8efeb0f15e29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad868b8da7a736ec0ce3e89a2de41711c"><td class="memItemLeft" align="right" valign="top">PadOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#ad868b8da7a736ec0ce3e89a2de41711c">createPadHighOp</a> (RankedTensorType type, <a class="el" href="classmlir_1_1Value.html">Value</a> source, <a class="el" href="classmlir_1_1Value.html">Value</a> pad, bool nofold, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="separator:ad868b8da7a736ec0ce3e89a2de41711c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450fa57046cd901b794bacb1d5bfcbcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a450fa57046cd901b794bacb1d5bfcbcb">createDynamicDimValues</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> rankedTensor)</td></tr>
<tr class="separator:a450fa57046cd901b794bacb1d5bfcbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af653ec1883b204db69c003fbd5b08c6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#af653ec1883b204db69c003fbd5b08c6a">createDimValues</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> rankedTensor)</td></tr>
<tr class="separator:af653ec1883b204db69c003fbd5b08c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a9d4142525a7f3e353e50a35cd66c945d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4142525a7f3e353e50a35cd66c945d">&#9670;&nbsp;</a></span>ControlConstantExtractSliceFusionFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1tensor.html#a9d4142525a7f3e353e50a35cd66c945d">mlir::tensor::ControlConstantExtractSliceFusionFn</a> = typedef std::function&lt;bool(ExtractSliceOp)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to control the folding of constant and extract slice. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Tensor_2IR_2Tensor_8h_source.html#l00146">146</a> of file <a class="el" href="mlir_2Dialect_2Tensor_2IR_2Tensor_8h_source.html">Tensor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa9a54e3a80e7a3bee2ffe4245b76beae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9a54e3a80e7a3bee2ffe4245b76beae">&#9670;&nbsp;</a></span>bubbleUpPadSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * mlir::tensor::bubbleUpPadSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::PadOp&#160;</td>
          <td class="paramname"><em>padOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>generateZeroSliceGuard</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bubbles up a slice of this pad by taking the slice first and then performing the padding. </p>
<p><code>offsets</code> and <code>strides</code> specifies each dimension's start offset and size for the slice. The slice has unit strides along all dimensions.</p>
<p>Specifically, this function converts: </p><div class="fragment"><div class="line">%0 = tensor.pad %source low[...] high[...] { linalg.yield %cst }</div>
<div class="line">%1 = &lt;extract-slice&gt; %0 offsets=[...], sizes[...]</div>
</div><!-- fragment --><p> into </p><div class="fragment"><div class="line">%0 = tensor.extract_slice %source ...</div>
<div class="line">%0 = tensor.pad %0 low[...] high[...] { linalg.yield %cst }</div>
</div><!-- fragment --><p>If <code>generateZeroSliceGuard</code> is true, the generated IR will contain logic to guard against the case that we might take a zero-sized slice from the original source. For such cases, we <code>tensor.generate</code> to generate the full tensor. </p>

<p class="definition">Definition at line <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00073">73</a> of file <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html">TensorTilingInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00336">mlir::bindDims()</a>, <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8h_source.html#l00472">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00052">mlir::dispatchIndexOpFoldResults()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01043">mlir::AffineMap::get()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00070">mlir::getAsOpFoldResult()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00096">mlir::getConstantIntValue()</a>, <a class="el" href="Builders_8h_source.html#l00054">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00109">mlir::Builder::getIndexAttr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00256">mlir::AffineMap::getMultiDimIdentityMap()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00053">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00201">max()</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l00194">min()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Transforms_8cpp_source.html#l00450">mlir::linalg::ExtractSliceOfPadTensorSwapPattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a30deb019e8a71c65e127e245b9cf63fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30deb019e8a71c65e127e245b9cf63fb">&#9670;&nbsp;</a></span>canFoldIntoConsumerOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::tensor::canFoldIntoConsumerOp </td>
          <td>(</td>
          <td class="paramtype">CastOp&#160;</td>
          <td class="paramname"><em>castOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether tensor::CastOp casts to a more dynamic version of the source tensor. </p>
<p>This is useful to fold a tensor.cast into a consuming op and implement canonicalization patterns for ops in different dialects that may consume the results of tensor.cast operations. Such foldable tensor.cast operations are typically inserted as <code>extract_slice</code> ops and are canonicalized, to preserve the type compatibility of their uses.</p>
<p>Returns true when all conditions are met:</p><ol type="1">
<li>source and result are ranked tensors with same element type and rank.</li>
<li>the tensor type has more static information than the result</li>
</ol>
<p>Example: </p><div class="fragment"><div class="line">%1 = tensor.cast %0 : tensor&lt;8x16xf32&gt; to tensor&lt;?x?xf32&gt;</div>
<div class="line">%2 = consumer %1 ... : tensor&lt;?x?xf32&gt; ...</div>
</div><!-- fragment --><p>folds into:</p>
<div class="fragment"><div class="line">%2 = consumer %0 ... : tensor&lt;8x16xf32&gt; ...</div>
</div><!-- fragment --><p>This is useful to fold a tensor.cast into a consuming op and implement canonicalization patterns for ops in different dialects that may consume the results of tensor.cast operations. Such foldable tensor.cast operations are typically inserted as <code>slice</code> ops and are canonicalized, to preserve the type compatibility of their uses.</p>
<p>Returns true when all conditions are met:</p><ol type="1">
<li>source and result are ranked tensors with same element type and rank.</li>
<li>the tensor type has more static information than the result</li>
</ol>
<p>Example: </p><div class="fragment"><div class="line">%1 = tensor.cast %0 : tensor&lt;8x16xf32&gt; to tensor&lt;?x?xf32&gt;</div>
<div class="line">%2 = consumer %1 ... : tensor&lt;?x?xf32&gt; ...</div>
</div><!-- fragment --><p>folds into:</p>
<div class="fragment"><div class="line">%2 = consumer %0 ... : tensor&lt;8x16xf32&gt; ...</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00169">169</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="TensorOps_8cpp_source.html#l00121">preservesStaticInformation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l00208">foldTensorCast()</a>, and <a class="el" href="MemRefOps_8cpp_source.html#l02416">CollapseShapeOpMemRefCastFolder::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a1bbbd2b47f452ac54390390eb2099edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bbbd2b47f452ac54390390eb2099edd">&#9670;&nbsp;</a></span>canFoldIntoProducerOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::tensor::canFoldIntoProducerOp </td>
          <td>(</td>
          <td class="paramtype">CastOp&#160;</td>
          <td class="paramname"><em>castOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the tensor::CastOp casts to a more static version of the source tensor. </p>
<p>This is useful to fold into a producing op and implement canonicaliation patterns with the <code>tensor.cast</code> op as the root, but producer being from different dialects. Returns true when all conditions are met:</p><ol type="1">
<li>source and result and ranked tensors with same element type and rank.</li>
<li>the result type has more static information than the source.</li>
</ol>
<p>Example: </p><div class="fragment"><div class="line">%1 = producer ... : tensor&lt;?x?xf32&gt;</div>
<div class="line">%2 = tensor.cast %1 : tensor&lt;?x?xf32&gt; to tensor&lt;8x16xf32&gt;</div>
</div><!-- fragment --><p>can be canonicalized to :</p>
<div class="fragment"><div class="line">%2 = producer ... : tensor&lt;8x16xf32&gt;</div>
</div><!-- fragment --><p> Not all ops might be canonicalizable this way, but for those that can be, this method provides a check that it is worth doing the canonicalization. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00199">199</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="TensorOps_8cpp_source.html#l00121">preservesStaticInformation()</a>.</p>

</div>
</div>
<a id="a6cfe3bede328e5dc72de55dfca72fe1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cfe3bede328e5dc72de55dfca72fe1d">&#9670;&nbsp;</a></span>createCanonicalRankReducingExtractSliceOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::tensor::createCanonicalRankReducingExtractSliceOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RankedTensorType&#160;</td>
          <td class="paramname"><em>targetType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a rank-reducing ExtractSliceOp @[0 . </p>
<p>. 0] with strides [1 .. 1] and appropriate sizes (i.e. <code>tensor.getSizes()</code>) to reduce the rank of <code>tensor</code> to that of <code>targetType</code>. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l01988">1988</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00280">mlir::Type::cast()</a>, <a class="el" href="Builders_8h_source.html#l00472">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Builders_8cpp_source.html#l00109">mlir::Builder::getIndexAttr()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00043">getMixedSizes()</a>, and <a class="el" href="Value_8h_source.html#l00114">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Transforms_8cpp_source.html#l00486">mlir::linalg::DownscaleSizeOneWindowed2DConvolution&lt; Conv2DOp, Conv1DOp &gt;::returningMatchAndRewrite()</a>, and <a class="el" href="Transforms_8cpp_source.html#l00579">mlir::linalg::DownscaleDepthwiseConv2DNhwcHwcOp::returningMatchAndRewrite()</a>.</p>

</div>
</div>
<a id="a6b0730cfcf9d984a57414d62c2b18b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0730cfcf9d984a57414d62c2b18b2f">&#9670;&nbsp;</a></span>createCanonicalRankReducingInsertSliceOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::tensor::createCanonicalRankReducingInsertSliceOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a rank-reducing InsertSliceOp @[0 . </p>
<p>. 0] with strides [1 .. 1] and appropriate sizes (i.e. <code>dest.getSizes()</code>). The result is a new tensor with rank increased to that of <code>dest</code>, obtained by inserting <code>tensor</code> into <code>dest</code> at the canonical [0 .. 0] position. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l02344">2344</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00280">mlir::Type::cast()</a>, <a class="el" href="Builders_8h_source.html#l00472">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Builders_8cpp_source.html#l00109">mlir::Builder::getIndexAttr()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00043">getMixedSizes()</a>, and <a class="el" href="Value_8h_source.html#l00114">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Transforms_8cpp_source.html#l00486">mlir::linalg::DownscaleSizeOneWindowed2DConvolution&lt; Conv2DOp, Conv1DOp &gt;::returningMatchAndRewrite()</a>, and <a class="el" href="Transforms_8cpp_source.html#l00579">mlir::linalg::DownscaleDepthwiseConv2DNhwcHwcOp::returningMatchAndRewrite()</a>.</p>

</div>
</div>
<a id="af653ec1883b204db69c003fbd5b08c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af653ec1883b204db69c003fbd5b08c6a">&#9670;&nbsp;</a></span>createDimValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::tensor::createDimValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>rankedTensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00055">55</a> of file <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00280">mlir::Type::cast()</a>, <a class="el" href="Builders_8h_source.html#l00472">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Matchers_8h_source.html#l00230">mlir::detail::enumerate()</a>, <a class="el" href="Builders_8cpp_source.html#l00109">mlir::Builder::getIndexAttr()</a>, and <a class="el" href="Value_8h_source.html#l00114">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="a450fa57046cd901b794bacb1d5bfcbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a450fa57046cd901b794bacb1d5bfcbcb">&#9670;&nbsp;</a></span>createDynamicDimValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::tensor::createDynamicDimValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>rankedTensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00041">41</a> of file <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00280">mlir::Type::cast()</a>, <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="Matchers_8h_source.html#l00230">mlir::detail::enumerate()</a>, and <a class="el" href="Value_8h_source.html#l00114">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SplitReduction_8cpp_source.html#l00246">mlir::linalg::splitReductionByScaling()</a>.</p>

</div>
</div>
<a id="ad868b8da7a736ec0ce3e89a2de41711c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad868b8da7a736ec0ce3e89a2de41711c">&#9670;&nbsp;</a></span>createPadHighOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PadOp mlir::tensor::createPadHighOp </td>
          <td>(</td>
          <td class="paramtype">RankedTensorType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>pad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nofold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00021">21</a> of file <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00336">mlir::bindDims()</a>, <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8h_source.html#l00472">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Matchers_8h_source.html#l00230">mlir::detail::enumerate()</a>, <a class="el" href="Builders_8h_source.html#l00054">mlir::Builder::getContext()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00957">mlir::makeComposedAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00346">mlir::linalg::makeComposedPadHighOp()</a>.</p>

</div>
</div>
<a id="a00e4cc4be054eec0b07a42e2f63f05f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e4cc4be054eec0b07a42e2f63f05f2">&#9670;&nbsp;</a></span>foldTensorCast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::tensor::foldTensorCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs folding of any operand of <code>op</code> if it comes from a tensor::CastOp that can be folded. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00208">208</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="TensorOps_8cpp_source.html#l00169">canFoldIntoConsumerOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00300">mlir::Operation::getOpOperands()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="ad1d0935f6c223e44294137605bb39d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d0935f6c223e44294137605bb39d60">&#9670;&nbsp;</a></span>getMixedSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::tensor::getMixedSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the dimensions of the given tensor value. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00043">43</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8cpp_source.html#l00109">mlir::Builder::getIndexAttr()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00160">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l01988">createCanonicalRankReducingExtractSliceOp()</a>, and <a class="el" href="TensorOps_8cpp_source.html#l02344">createCanonicalRankReducingInsertSliceOp()</a>.</p>

</div>
</div>
<a id="a90e502153b3c46a11dad42045c36bc31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e502153b3c46a11dad42045c36bc31">&#9670;&nbsp;</a></span>getOrCreateDestination()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::tensor::getOrCreateDestination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a>&#160;</td>
          <td class="paramname"><em>opResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a helper function for DestinationStyleOpInterface. </p>
<p>If there is a destination operand for the given <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a>, return that operand. Otherwise, return an empty tensor (<code>tensor.empty</code>) with the shape of the <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a>. Dynamic dimensions are queried via ReifyRankedShapedTypeOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00058">58</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2Types_8h_source.html#l00270">mlir::Type::dyn_cast()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00070">mlir::getAsOpFoldResult()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Builders_8cpp_source.html#l00109">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Value_8h_source.html#l00454">mlir::OpResult::getResultNumber()</a>, <a class="el" href="Value_8h_source.html#l00114">mlir::Value::getType()</a>, and <a class="el" href="Builders_8h_source.html#l00350">mlir::OpBuilder::setInsertionPoint()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l00097">getOrCreateDestinations()</a>.</p>

</div>
</div>
<a id="ad28262a44a78b9ce6b2e43195dd2a085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28262a44a78b9ce6b2e43195dd2a085">&#9670;&nbsp;</a></span>getOrCreateDestinations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::tensor::getOrCreateDestinations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a helper function for DestinationStyleOpInterface. </p>
<p>Get or create destinations for every tensor <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> of the given op. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00097">97</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00058">getOrCreateDestination()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00332">mlir::Operation::getResults()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Split_8cpp_source.html#l00067">mlir::linalg::splitOp()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00327">tileAndFuseFirstExtractUseThroughContainingOpBlockArgument()</a>, <a class="el" href="Tiling_8cpp_source.html#l00748">tilePadOp()</a>, <a class="el" href="Tiling_8cpp_source.html#l00414">mlir::linalg::tileReductionUsingForeachThread()</a>, <a class="el" href="Tiling_8cpp_source.html#l00296">tileToForeachThreadOpImpl()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00278">mlir::scf::tileUsingSCFForOp()</a>.</p>

</div>
</div>
<a id="a0edfdd5a23215fd0d8d587be6ebae28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0edfdd5a23215fd0d8d587be6ebae28a">&#9670;&nbsp;</a></span>populateFoldConstantExtractSlicePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::populateFoldConstantExtractSlicePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1tensor.html#a9d4142525a7f3e353e50a35cd66c945d">ControlConstantExtractSliceFusionFn</a> &amp;&#160;</td>
          <td class="paramname"><em>controlFn</em> = <code>[](ExtractSliceOp&#160;op)&#160;{&#160;&#160;&#160;return&#160;false;&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to fold the extract slice op with its constant operand. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l01900">1900</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01587">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01563">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a354a5a1166be4a8db79d65866e88182e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354a5a1166be4a8db79d65866e88182e">&#9670;&nbsp;</a></span>populateMergeConsecutiveInsertExtractSlicePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::populateMergeConsecutiveInsertExtractSlicePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects patterns to merge consecutive tensor.insert_slice/extract_slice into one. </p>
<p>These patterns are in in this separate entry point because the bufferization is sensitive over IR structure, particularly those tensor.extract_slice and tensor.insert_slice ops for creating the slices. </p>

<p class="definition">Definition at line <a class="el" href="MergeConsecutiveInsertExtractSlicePatterns_8cpp_source.html#l00078">78</a> of file <a class="el" href="MergeConsecutiveInsertExtractSlicePatterns_8cpp_source.html">MergeConsecutiveInsertExtractSlicePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01587">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01563">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="aac3303ddaae66c9995b0938917ae210d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac3303ddaae66c9995b0938917ae210d">&#9670;&nbsp;</a></span>populateSplitPaddingPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::populateSplitPaddingPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>baseBenefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <code>patterns</code> with patterns to wrap a tensor.pad op with an scf.if op to separate the cases where we don't need padding (all pad sizes are actually zeros) and where we indeed need padding. </p>

<p class="definition">Definition at line <a class="el" href="SplitPaddingPatterns_8cpp_source.html#l00092">92</a> of file <a class="el" href="SplitPaddingPatterns_8cpp_source.html">SplitPaddingPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01587">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01563">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ac1b0cdf08bf148506f761f70f24059f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b0cdf08bf148506f761f70f24059f0">&#9670;&nbsp;</a></span>preservesStaticInformation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::tensor::preservesStaticInformation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <code>target</code> is a ranked tensor type that preserves static information available in the <code>source</code> ranked tensor type. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00121">121</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00270">mlir::Type::dyn_cast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l00169">canFoldIntoConsumerOp()</a>, and <a class="el" href="TensorOps_8cpp_source.html#l00199">canFoldIntoProducerOp()</a>.</p>

</div>
</div>
<a id="aa09a0f22283c4ef45935f058b6f629cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09a0f22283c4ef45935f058b6f629cb">&#9670;&nbsp;</a></span>registerBufferizableOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::registerBufferizableOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tensor_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l01037">1037</a> of file <a class="el" href="Tensor_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html">BufferizableOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00179">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="MLIRContext_8h_source.html#l00103">mlir::MLIRContext::loadDialect()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllDialects_8h_source.html#l00075">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a537a26573013e086958f9f7a18fa65d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537a26573013e086958f9f7a18fa65d5">&#9670;&nbsp;</a></span>registerInferTypeOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::registerInferTypeOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">mlir::DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers external models for Infer <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> interfaces for tensor ops. </p>
<p>Currently, it registers:</p>
<ul>
<li>ReifyRankedShapedTypeOpInterface for <code>tensor.collapse_shape</code>.</li>
<li>ReifyRankedShapedTypeOpInterface for <code>tensor.expand_shape</code>.</li>
</ul>
<p>Unfortunately, a "normal" internal registration is not possible at the moment, because of the dependency of the interface implementation for these ops on <code>affine.apply</code> and Affine dialect already depends on TensorOps. In order to break the cyclic dependency (TensorOps-&gt;AffineOps-&gt;TensorOps) the implementation is moved to a separate library. </p>

<p class="definition">Definition at line <a class="el" href="TensorInferTypeOpInterfaceImpl_8cpp_source.html#l00196">196</a> of file <a class="el" href="TensorInferTypeOpInterfaceImpl_8cpp_source.html">TensorInferTypeOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00179">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllDialects_8h_source.html#l00075">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a84a4bebf333acf49aa338a6f810152f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a4bebf333acf49aa338a6f810152f5">&#9670;&nbsp;</a></span>registerTilingInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::registerTilingInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">mlir::DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers external models for Tiling interface for tensor ops. </p>
<p>Currently, it registers:</p>
<ul>
<li>TilingInterface for <code>tensor.pad</code>.</li>
</ul>
<p>Unfortunately, a "normal" internal registration is not possible at the moment, because of the dependency of the interface implementation for these ops on <code>affine.apply</code> and Affine dialect already depends on TensorOps. In order to break the cyclic dependency (TensorOps-&gt;AffineOps-&gt;TensorOps) the implementation is moved to a separate library. </p>

<p class="definition">Definition at line <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00281">281</a> of file <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html">TensorTilingInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00179">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllDialects_8h_source.html#l00075">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="aa6ef1b6b64e9e6fdcdb845aec25a1e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6ef1b6b64e9e6fdcdb845aec25a1e41">&#9670;&nbsp;</a></span>replaceExtractSliceWithTiledProducer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::tensor::replaceExtractSliceWithTiledProducer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::ExtractSliceOp&#160;</td>
          <td class="paramname"><em>sliceOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a>&#160;</td>
          <td class="paramname"><em>producerOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to swap an <code>tensor.extract_slice</code> with its producer when the producer implements the <code>TilingInterface</code>. </p>
<p>The pattern itself does not provide a mechanism to control where the application happens. With use of transform dialect that control is done within the transform dialect. Other use cases can inherit from this pattern and add necessary controls. </p>

<p class="definition">Definition at line <a class="el" href="SwapExtractSliceWithProducerPatterns_8cpp_source.html#l00023">23</a> of file <a class="el" href="SwapExtractSliceWithProducerPatterns_8cpp_source.html">SwapExtractSliceWithProducerPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Value_8h_source.html#l00451">mlir::OpResult::getOwner()</a>, and <a class="el" href="Value_8h_source.html#l00454">mlir::OpResult::getResultNumber()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00535">mlir::scf::tileConsumerAndFuseProducerGreedilyUsingSCFForOp()</a>.</p>

</div>
</div>
<a id="a5549d629eff95d24dfb8efeb0f15e29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5549d629eff95d24dfb8efeb0f15e29e">&#9670;&nbsp;</a></span>simplifyCollapseShapeWithRankReducingExtractSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::tensor::simplifyCollapseShapeWithRankReducingExtractSlice </td>
          <td>(</td>
          <td class="paramtype">tensor::CollapseShapeOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to simplify a <code>tensor.collapse_shape</code> operation by inserting a single rank-reducing <code>tensor.extract_slice</code> operation. </p>
<p>The <code>extract_slice</code> op will either take the place of the source, allowing for a new, simpler <code>collapse_shape</code> op to replace <code>op</code>, or the <code>collapse_shape</code> op will be completely replaced by the <code>extract_slice</code> result. Either way, <code>op</code> is replaced and new new op is returned.</p>
<h3><a class="anchor" id="autotoc_md20"></a>
Example:</h3>
<div class="fragment"><div class="line">%result = tensor.collapse_shape %0 [[0, 1], [2, 3]]</div>
<div class="line">   : tensor&lt;?x1x30x10xf32&gt; to tensor&lt;?x300xf32&gt;</div>
</div><!-- fragment --><p> can be transformed to</p>
<div class="fragment"><div class="line">%tmp = tensor.extract_slice %0 [0, 0, 0, 0]</div>
<div class="line">                        [0, %dim1, 30, 30]</div>
<div class="line">                        [1, 1, 1 1]</div>
<div class="line">  : tensor&lt;?x1x30x10xf32&gt; to tensor&lt;?x30x10xf32&gt;</div>
<div class="line">%result = tensor.collapse_shape %tmp [[0], [1, 2]]</div>
<div class="line">  : tensor&lt;?x30x10xf32&gt; to tensor&lt;?x300xf32&gt;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md21"></a>
Example:</h3>
<div class="fragment"><div class="line">%result = tensor.collapse_shape %1 [[0, 1], [2]]</div>
<div class="line">   : tensor&lt;?x1x30xf32&gt; to tensor&lt;?x30xf32&gt;</div>
</div><!-- fragment --><p> can be transformed to </p><div class="fragment"><div class="line">%result = tensor.extract_slice %1 [0, 0, 0]</div>
<div class="line">                                  [%dim2, 1, 30]</div>
<div class="line">                                  [1, 1, 1]</div>
<div class="line">   : tensor&lt;?x1x30xf32&gt; to tensor&lt;?x30xf32&gt;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md22"></a>
Unsupported cases:</h3>
<p>This transform doesn't yet support reducing the rank of the reassociation indices, which would require inserting a <code>tensor.expand_shape</code> op similar to the following example: </p><div class="fragment"><div class="line">%result = tensor.collapse_shape %0 [[0, 1], [2, 3]]</div>
<div class="line">   : tensor&lt;1x1x30x10xf32&gt; to tensor&lt;1x300xf32&gt;</div>
</div><!-- fragment --><p> can be transformed to </p><div class="fragment"><div class="line">%tmp = tensor.extract_slice %0 [0, 0, 0, 0]</div>
<div class="line">                        [0, 1, 30, 30]</div>
<div class="line">                        [1, 1, 1 1]</div>
<div class="line">  : tensor&lt;1x1x30x10xf32&gt; to tensor&lt;30x10xf32&gt;</div>
<div class="line">%result0 = tensor.collapse_shape %tmp [[0, 1]]</div>
<div class="line">  : tensor&lt;30x10xf32&gt; to tensor&lt;300xf32&gt;</div>
<div class="line">%result1 = tensor.expand_shape %tmp [[0, 1], [2]] :... tensor&lt;1x300xf32&gt;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00185">185</a> of file <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html">ExtractSliceFromReshapeUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Builders_8cpp_source.html#l00109">mlir::Builder::getIndexAttr()</a>, <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00040">getShapeDimSizes()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00261">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00451">mlir::RewriterBase::replaceOpWithNewOp()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 17 2022 20:37:52 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
