<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/Affine/IR/AffineOps.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">16.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a class="el" href="dir_30022079959872f4a1874dfcab7bb1fc.html">Affine</a></li><li class="navelem"><a class="el" href="dir_253b99abdc8fa8576ac945bee537f5fd.html">IR</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">AffineOps.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineValueMap_8h_source.html">mlir/Dialect/Affine/IR/AffineValueMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="MemRef_8h_source.html">mlir/Dialect/MemRef/IR/MemRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineExprVisitor_8h_source.html">mlir/IR/AffineExprVisitor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="BlockAndValueMapping_8h_source.html">mlir/IR/BlockAndValueMapping.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2IntegerSet_8h_source.html">mlir/IR/IntegerSet.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Matchers_8h_source.html">mlir/IR/Matchers.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="OpDefinition_8h_source.html">mlir/IR/OpDefinition.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PatternMatch_8h_source.html">mlir/IR/PatternMatch.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ShapedOpInterfaces_8h_source.html">mlir/Interfaces/ShapedOpInterfaces.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="InliningUtils_8h_source.html">mlir/Transforms/InliningUtils.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/ScopeExit.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallBitVector.h&quot;</code><br />
<code>#include &quot;llvm/ADT/TypeSwitch.h&quot;</code><br />
<code>#include &quot;llvm/Support/Debug.h&quot;</code><br />
<code>#include &lt;numeric&gt;</code><br />
<code>#include &quot;mlir/Dialect/Affine/IR/AffineOpsDialect.cpp.inc&quot;</code><br />
<code>#include &quot;mlir/Dialect/Affine/IR/AffineOps.cpp.inc&quot;</code><br />
</div><div class="textblock"><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Include dependency graph for AffineOps.cpp:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="AffineOps_8cpp__incl.png" border="0" usemap="#alib_2Dialect_2Affine_2IR_2AffineOps_8cpp" alt=""/></div>
<map name="alib_2Dialect_2Affine_2IR_2AffineOps_8cpp" id="alib_2Dialect_2Affine_2IR_2AffineOps_8cpp">
<area shape="rect" title=" " alt="" coords="2801,5,2935,47"/>
<area shape="rect" href="AffineOps_8h.html" title=" " alt="" coords="1075,184,1215,225"/>
<area shape="rect" title=" " alt="" coords="483,459,677,486"/>
<area shape="rect" href="OpDefinition_8h.html" title=" " alt="" coords="1547,541,1709,568"/>
<area shape="rect" href="AffineValueMap_8h.html" title=" " alt="" coords="371,273,528,315"/>
<area shape="rect" href="MemRef_8h.html" title=" " alt="" coords="2200,95,2357,136"/>
<area shape="rect" href="PatternMatch_8h.html" title=" " alt="" coords="2406,281,2573,307"/>
<area shape="rect" href="ShapedOpInterfaces_8h.html" title=" " alt="" coords="2749,184,2936,225"/>
<area shape="rect" href="AffineExprVisitor_8h.html" title=" " alt="" coords="45,370,235,397"/>
<area shape="rect" href="BlockAndValueMapping_8h.html" title=" " alt="" coords="2907,541,3141,568"/>
<area shape="rect" href="mlir_2IR_2IntegerSet_8h.html" title=" " alt="" coords="259,370,407,397"/>
<area shape="rect" href="Matchers_8h.html" title=" " alt="" coords="1272,370,1413,397"/>
<area shape="rect" href="InliningUtils_8h.html" title=" " alt="" coords="2981,95,3157,136"/>
<area shape="rect" title=" " alt="" coords="3181,102,3344,129"/>
<area shape="rect" title=" " alt="" coords="3368,102,3539,129"/>
<area shape="rect" title=" " alt="" coords="3563,102,3725,129"/>
<area shape="rect" title=" " alt="" coords="3749,102,3824,129"/>
<area shape="rect" title=" " alt="" coords="3848,95,4051,136"/>
<area shape="rect" title=" " alt="" coords="4075,95,4231,136"/>
<area shape="rect" href="AffineMemoryOpInterfaces_8h.html" title=" " alt="" coords="1131,273,1362,315"/>
<area shape="rect" href="mlir_2IR_2AffineMap_8h.html" title=" " alt="" coords="483,370,629,397"/>
<area shape="rect" href="Arith_8h.html" title=" " alt="" coords="1525,273,1659,315"/>
<area shape="rect" href="Builders_8h.html" title=" " alt="" coords="1766,459,1901,486"/>
<area shape="rect" href="ControlFlowInterfaces_8h.html" title=" " alt="" coords="2183,273,2382,315"/>
<area shape="rect" href="LoopLikeInterface_8h.html" title=" " alt="" coords="1007,452,1185,493"/>
<area shape="rect" title=" " alt="" coords="704,273,891,315"/>
<area shape="rect" title=" " alt="" coords="915,273,1056,315"/>
<area shape="rect" href="mlir_2IR_2BuiltinTypes_8h.html" title=" " alt="" coords="1431,459,1591,486"/>
<area shape="rect" href="mlir_2IR_2AffineExpr_8h.html" title=" " alt="" coords="83,459,229,486"/>
<area shape="rect" title=" " alt="" coords="253,459,408,486"/>
<area shape="rect" title=" " alt="" coords="213,616,305,643"/>
<area shape="rect" href="IR_2Dialect_8h.html" title=" " alt="" coords="1197,616,1323,643"/>
<area shape="rect" title=" " alt="" coords="1501,840,1683,881"/>
<area shape="rect" href="IR_2Operation_8h.html" title=" " alt="" coords="1394,616,1539,643"/>
<area shape="rect" href="OperationSupport_8h.html" title=" " alt="" coords="1176,691,1371,717"/>
<area shape="rect" href="Value_8h.html" title=" " alt="" coords="1215,765,1332,792"/>
<area shape="rect" href="Block_8h.html" title=" " alt="" coords="1440,691,1557,717"/>
<area shape="rect" href="CastInterfaces_8h.html" title=" " alt="" coords="2123,459,2349,486"/>
<area shape="rect" href="InferTypeOpInterface_8h.html" title=" " alt="" coords="1539,363,1720,404"/>
<area shape="rect" href="SideEffectInterfaces_8h.html" title=" " alt="" coords="2521,452,2708,493"/>
<area shape="rect" href="ReshapeOpsUtils_8h.html" title=" " alt="" coords="2391,184,2540,225"/>
<area shape="rect" href="CallInterfaces_8h.html" title=" " alt="" coords="1290,191,1513,218"/>
<area shape="rect" href="CopyOpInterface_8h.html" title=" " alt="" coords="1948,191,2191,218"/>
<area shape="rect" href="ViewLikeInterface_8h.html" title=" " alt="" coords="1744,363,1923,404"/>
<area shape="rect" title=" " alt="" coords="1537,184,1741,225"/>
<area shape="rect" title=" " alt="" coords="1765,184,1923,225"/>
<area shape="rect" href="BuiltinOps_8h.html" title=" " alt="" coords="2686,370,2834,397"/>
<area shape="rect" title=" " alt="" coords="2200,370,2395,397"/>
<area shape="rect" title=" " alt="" coords="2419,370,2610,397"/>
<area shape="rect" title=" " alt="" coords="2699,273,2885,315"/>
</map>
</div>
</div>
<p><a href="AffineOps_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDeduplicateAffineMinMaxExpressions.html">DeduplicateAffineMinMaxExpressions&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove duplicated expressions in affine min/max ops.  <a href="structDeduplicateAffineMinMaxExpressions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMergeAffineMinMaxOp.html">MergeAffineMinMaxOp&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge an affine min/max op to its consumers if its consumer is also an affine min/max op.  <a href="structMergeAffineMinMaxOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCanonicalizeAffineMinMaxOpExprAndTermOrder.html">CanonicalizeAffineMinMaxOpExprAndTermOrder&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize the affine map result expression order of an affine min/max operation.  <a href="structCanonicalizeAffineMinMaxOpExprAndTermOrder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCanonicalizeSingleResultAffineMinMaxOp.html">CanonicalizeSingleResultAffineMinMaxOp&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;affine-analysis&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4eeb99d83d4a53327f3c7a9574ad6f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#aeb4eeb99d83d4a53327f3c7a9574ad6f">GET_OP_LIST</a></td></tr>
<tr class="separator:aeb4eeb99d83d4a53327f3c7a9574ad6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c883a38e577b8b12282ff70c95a16d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a52c883a38e577b8b12282ff70c95a16d">GET_OP_CLASSES</a></td></tr>
<tr class="separator:a52c883a38e577b8b12282ff70c95a16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afb70e7e08d963e3f8338d11301fc4004"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#afb70e7e08d963e3f8338d11301fc4004">remainsLegalAfterInline</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Region.html">Region</a> *dest, const <a class="el" href="classmlir_1_1BlockAndValueMapping.html">BlockAndValueMapping</a> &amp;mapping, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; legalityCheck)</td></tr>
<tr class="memdesc:afb70e7e08d963e3f8338d11301fc4004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>value</code> known to be a legal affine dimension or symbol in <code>src</code> region remains legal if the operation that uses it is inlined into <code>dest</code> with the given value mapping.  <a href="AffineOps_8cpp.html#afb70e7e08d963e3f8338d11301fc4004">More...</a><br /></td></tr>
<tr class="separator:afb70e7e08d963e3f8338d11301fc4004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5aed3481d2961b1b02ddcf67b7b6993"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#ab5aed3481d2961b1b02ddcf67b7b6993">remainsLegalAfterInline</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Region.html">Region</a> *dest, const <a class="el" href="classmlir_1_1BlockAndValueMapping.html">BlockAndValueMapping</a> &amp;mapping, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; legalityCheck)</td></tr>
<tr class="memdesc:ab5aed3481d2961b1b02ddcf67b7b6993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all values known to be legal affine dimensions or symbols in <code>src</code> remain so if their respective users are inlined into <code>dest</code>.  <a href="AffineOps_8cpp.html#ab5aed3481d2961b1b02ddcf67b7b6993">More...</a><br /></td></tr>
<tr class="separator:ab5aed3481d2961b1b02ddcf67b7b6993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c87dc72c15957a6eb37f2814302209f"><td class="memTemplParams" colspan="2">template&lt;typename OpTy &gt; </td></tr>
<tr class="memitem:a1c87dc72c15957a6eb37f2814302209f"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a1c87dc72c15957a6eb37f2814302209f">remainsLegalAfterInline</a> (OpTy op, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Region.html">Region</a> *dest, const <a class="el" href="classmlir_1_1BlockAndValueMapping.html">BlockAndValueMapping</a> &amp;mapping)</td></tr>
<tr class="memdesc:a1c87dc72c15957a6eb37f2814302209f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an affine read or write operation remains legal after inlining from <code>src</code> to <code>dest</code>.  <a href="AffineOps_8cpp.html#a1c87dc72c15957a6eb37f2814302209f">More...</a><br /></td></tr>
<tr class="separator:a1c87dc72c15957a6eb37f2814302209f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9087c9020dc5397a2edf1feda93d79"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aff9087c9020dc5397a2edf1feda93d79"><td class="memTemplItemLeft" align="right" valign="top">bool LLVM_ATTRIBUTE_UNUSED&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#aff9087c9020dc5397a2edf1feda93d79">remainsLegalAfterInline</a> (AffineApplyOp op, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Region.html">Region</a> *dest, const <a class="el" href="classmlir_1_1BlockAndValueMapping.html">BlockAndValueMapping</a> &amp;mapping)</td></tr>
<tr class="memdesc:aff9087c9020dc5397a2edf1feda93d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an affine apply operation remains legal after inlining from <code>src</code> to <code>dest</code>.  <a href="AffineOps_8cpp.html#aff9087c9020dc5397a2edf1feda93d79">More...</a><br /></td></tr>
<tr class="separator:aff9087c9020dc5397a2edf1feda93d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db62c4fe9a0af0edf33f735e7450913"><td class="memTemplParams" colspan="2">template&lt;typename AnyMemRefDefOp &gt; </td></tr>
<tr class="memitem:a6db62c4fe9a0af0edf33f735e7450913"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a6db62c4fe9a0af0edf33f735e7450913">isMemRefSizeValidSymbol</a> (AnyMemRefDefOp memrefDefOp, unsigned index, <a class="el" href="classmlir_1_1Region.html">Region</a> *region)</td></tr>
<tr class="memdesc:a6db62c4fe9a0af0edf33f735e7450913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the 'index' dimension of the <code>memref</code> defined by <code>memrefDefOp</code> is a statically shaped one or defined using a valid symbol for <code>region</code>.  <a href="AffineOps_8cpp.html#a6db62c4fe9a0af0edf33f735e7450913">More...</a><br /></td></tr>
<tr class="separator:a6db62c4fe9a0af0edf33f735e7450913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7f0f42fc1a8809ab9d7ae95aac496a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#abb7f0f42fc1a8809ab9d7ae95aac496a">isDimOpValidSymbol</a> (ShapedDimOpInterface dimOp, <a class="el" href="classmlir_1_1Region.html">Region</a> *region)</td></tr>
<tr class="memdesc:abb7f0f42fc1a8809ab9d7ae95aac496a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the result of the dim op is a valid symbol for <code>region</code>.  <a href="AffineOps_8cpp.html#abb7f0f42fc1a8809ab9d7ae95aac496a">More...</a><br /></td></tr>
<tr class="separator:abb7f0f42fc1a8809ab9d7ae95aac496a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40425801875310c2151577ce17a33acd"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a40425801875310c2151577ce17a33acd">isValidAffineIndexOperand</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, <a class="el" href="classmlir_1_1Region.html">Region</a> *region)</td></tr>
<tr class="separator:a40425801875310c2151577ce17a33acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909b810a734e0872e03164db8d7fa7f8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a909b810a734e0872e03164db8d7fa7f8">printDimAndSymbolList</a> (<a class="el" href="classmlir_1_1Operation.html#ae9f435d73bdd799ad9f8ace519293a45">Operation::operand_iterator</a> begin, <a class="el" href="classmlir_1_1Operation.html#ae9f435d73bdd799ad9f8ace519293a45">Operation::operand_iterator</a> end, unsigned numDims, <a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;printer)</td></tr>
<tr class="memdesc:a909b810a734e0872e03164db8d7fa7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints dimension and symbol list.  <a href="AffineOps_8cpp.html#a909b810a734e0872e03164db8d7fa7f8">More...</a><br /></td></tr>
<tr class="separator:a909b810a734e0872e03164db8d7fa7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf19ea7311ad162852c482c8523b7120"><td class="memTemplParams" colspan="2">template&lt;typename OpTy &gt; </td></tr>
<tr class="memitem:aaf19ea7311ad162852c482c8523b7120"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#aaf19ea7311ad162852c482c8523b7120">verifyDimAndSymbolIdentifiers</a> (OpTy &amp;op, <a class="el" href="classmlir_1_1Operation.html#a8fc63f3d33e11994ab3330eb6e8990b9">Operation::operand_range</a> operands, unsigned numDims)</td></tr>
<tr class="memdesc:aaf19ea7311ad162852c482c8523b7120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to verify that a set of operands are valid dimension and symbol identifiers.  <a href="AffineOps_8cpp.html#aaf19ea7311ad162852c482c8523b7120">More...</a><br /></td></tr>
<tr class="separator:aaf19ea7311ad162852c482c8523b7120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9113c24d7d445c3728e0d7945c064421"><td class="memItemLeft" align="right" valign="top">static int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a9113c24d7d445c3728e0d7945c064421">getLargestKnownDivisor</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> e, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands)</td></tr>
<tr class="memdesc:a9113c24d7d445c3728e0d7945c064421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest known divisor of <code>e</code>.  <a href="AffineOps_8cpp.html#a9113c24d7d445c3728e0d7945c064421">More...</a><br /></td></tr>
<tr class="separator:a9113c24d7d445c3728e0d7945c064421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764b24362c096adadc31e0db757b0bbc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a764b24362c096adadc31e0db757b0bbc">isNonNegativeBoundedBy</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> e, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands, int64_t k)</td></tr>
<tr class="memdesc:a764b24362c096adadc31e0db757b0bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>e</code> is known to be: 0 &lt;= <code>e</code> &lt; <code>k</code>.  <a href="AffineOps_8cpp.html#a764b24362c096adadc31e0db757b0bbc">More...</a><br /></td></tr>
<tr class="separator:a764b24362c096adadc31e0db757b0bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac607329b2b966b06fe88ec201119aea3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#ac607329b2b966b06fe88ec201119aea3">isQTimesDPlusR</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> e, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands, int64_t &amp;div, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;quotientTimesDiv, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;rem)</td></tr>
<tr class="memdesc:ac607329b2b966b06fe88ec201119aea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if expression <code>e</code> is of the form d*e_1 + e_2 where 0 &lt;= e_2 &lt; d.  <a href="AffineOps_8cpp.html#ac607329b2b966b06fe88ec201119aea3">More...</a><br /></td></tr>
<tr class="separator:ac607329b2b966b06fe88ec201119aea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25dd93649ca1f6b8b66a800b4cb38af"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#ac25dd93649ca1f6b8b66a800b4cb38af">simplifyExprAndOperands</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;expr, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands)</td></tr>
<tr class="memdesc:ac25dd93649ca1f6b8b66a800b4cb38af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify <code>expr</code> while exploiting information from the values in <code>operands</code>.  <a href="AffineOps_8cpp.html#ac25dd93649ca1f6b8b66a800b4cb38af">More...</a><br /></td></tr>
<tr class="separator:ac25dd93649ca1f6b8b66a800b4cb38af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c002a789228f4f6ca08ecf5d775ef3"><td class="memItemLeft" align="right" valign="top">static void LLVM_ATTRIBUTE_UNUSED&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a15c002a789228f4f6ca08ecf5d775ef3">simplifyMapWithOperands</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands)</td></tr>
<tr class="memdesc:a15c002a789228f4f6ca08ecf5d775ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify the map while exploiting information on the values in <code>operands</code>.  <a href="AffineOps_8cpp.html#a15c002a789228f4f6ca08ecf5d775ef3">More...</a><br /></td></tr>
<tr class="separator:a15c002a789228f4f6ca08ecf5d775ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583a996043dd655d70f175b01cfe19cd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a583a996043dd655d70f175b01cfe19cd">replaceDimOrSym</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *map, unsigned dimOrSymbolPosition, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;dims, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;syms)</td></tr>
<tr class="memdesc:a583a996043dd655d70f175b01cfe19cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of AffineExpr at position <code>pos</code> in <code>map</code> by the defining AffineApplyOp expression and operands.  <a href="AffineOps_8cpp.html#a583a996043dd655d70f175b01cfe19cd">More...</a><br /></td></tr>
<tr class="separator:a583a996043dd655d70f175b01cfe19cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac2b143b9e950ff18a9c6e949699a98"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a4ac2b143b9e950ff18a9c6e949699a98">composeAffineMapAndOperands</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *map, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands)</td></tr>
<tr class="memdesc:a4ac2b143b9e950ff18a9c6e949699a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over <code>operands</code> and fold away all those produced by an AffineApplyOp iteratively.  <a href="AffineOps_8cpp.html#a4ac2b143b9e950ff18a9c6e949699a98">More...</a><br /></td></tr>
<tr class="separator:a4ac2b143b9e950ff18a9c6e949699a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f080fa5377f31fd9ba465ad2789ef1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a01f080fa5377f31fd9ba465ad2789ef1">materializeConstants</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; values, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;constants, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;actualValues)</td></tr>
<tr class="memdesc:a01f080fa5377f31fd9ba465ad2789ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of <code>OpFoldResult</code>, build the necessary operations to populate <code>actualValues</code> with values produced by operations.  <a href="AffineOps_8cpp.html#a01f080fa5377f31fd9ba465ad2789ef1">More...</a><br /></td></tr>
<tr class="separator:a01f080fa5377f31fd9ba465ad2789ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858e28031d26c8a1095d59f0b269a9d2"><td class="memTemplParams" colspan="2">template&lt;typename OpTy , typename... Args&gt; </td></tr>
<tr class="memitem:a858e28031d26c8a1095d59f0b269a9d2"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if_t&lt; OpTy::template hasTrait&lt; <a class="el" href="classmlir_1_1OpTrait_1_1OneResult.html">OpTrait::OneResult</a> &gt;), <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a858e28031d26c8a1095d59f0b269a9d2">createOrFold</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands, Args &amp;&amp;...leadingArguments)</td></tr>
<tr class="memdesc:a858e28031d26c8a1095d59f0b269a9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an operation of the type provided as template argument and attempt to fold it immediately.  <a href="AffineOps_8cpp.html#a858e28031d26c8a1095d59f0b269a9d2">More...</a><br /></td></tr>
<tr class="separator:a858e28031d26c8a1095d59f0b269a9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0230f8255abc6b40272f16c3bb8e8e94"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a0230f8255abc6b40272f16c3bb8e8e94">composeMultiResultAffineMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;map, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;operands)</td></tr>
<tr class="memdesc:a0230f8255abc6b40272f16c3bb8e8e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes the given affine map with the given list of operands, pulling in the maps from any affine.apply operations that supply the operands.  <a href="AffineOps_8cpp.html#a0230f8255abc6b40272f16c3bb8e8e94">More...</a><br /></td></tr>
<tr class="separator:a0230f8255abc6b40272f16c3bb8e8e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf870053b51991e5999a553ab45e4819"><td class="memTemplParams" colspan="2">template&lt;typename OpTy &gt; </td></tr>
<tr class="memitem:aaf870053b51991e5999a553ab45e4819"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#aaf870053b51991e5999a553ab45e4819">makeComposedFoldedMinMax</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; operands)</td></tr>
<tr class="separator:aaf870053b51991e5999a553ab45e4819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e66c6a798856c89d951e1955e40b73b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a2e66c6a798856c89d951e1955e40b73b">createFoldedComposedAffineApply</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operandsRef)</td></tr>
<tr class="memdesc:a2e66c6a798856c89d951e1955e40b73b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully compose map with operands and canonicalize the result.  <a href="AffineOps_8cpp.html#a2e66c6a798856c89d951e1955e40b73b">More...</a><br /></td></tr>
<tr class="separator:a2e66c6a798856c89d951e1955e40b73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622cab33387384a309422bb2c690772f"><td class="memTemplParams" colspan="2">template&lt;class MapOrSet &gt; </td></tr>
<tr class="memitem:a622cab33387384a309422bb2c690772f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a622cab33387384a309422bb2c690772f">canonicalizePromotedSymbols</a> (MapOrSet *mapOrSet, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands)</td></tr>
<tr class="separator:a622cab33387384a309422bb2c690772f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a13ffbd2aefb7089f0b7a1e5411b11"><td class="memTemplParams" colspan="2">template&lt;class MapOrSet &gt; </td></tr>
<tr class="memitem:a43a13ffbd2aefb7089f0b7a1e5411b11"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a43a13ffbd2aefb7089f0b7a1e5411b11">canonicalizeMapOrSetAndOperands</a> (MapOrSet *mapOrSet, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands)</td></tr>
<tr class="separator:a43a13ffbd2aefb7089f0b7a1e5411b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de10d06704729af9438e5f4ae91bdec"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a4de10d06704729af9438e5f4ae91bdec">parseBound</a> (bool isLower, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result, <a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;p)</td></tr>
<tr class="memdesc:a4de10d06704729af9438e5f4ae91bdec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a for operation loop bounds.  <a href="AffineOps_8cpp.html#a4de10d06704729af9438e5f4ae91bdec">More...</a><br /></td></tr>
<tr class="separator:a4de10d06704729af9438e5f4ae91bdec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2978fd47e940232657b5ae684d7ccce"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#ae2978fd47e940232657b5ae684d7ccce">printBound</a> (AffineMapAttr boundMap, <a class="el" href="classmlir_1_1Operation.html#a8fc63f3d33e11994ab3330eb6e8990b9">Operation::operand_range</a> boundOperands, const char *prefix, <a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p)</td></tr>
<tr class="separator:ae2978fd47e940232657b5ae684d7ccce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1b5f51edb6d5cd35b45da7063f72a2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a9e1b5f51edb6d5cd35b45da7063f72a2">foldLoopBounds</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a9e1b5f51edb6d5cd35b45da7063f72a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold the constant bounds of a loop.  <a href="AffineOps_8cpp.html#a9e1b5f51edb6d5cd35b45da7063f72a2">More...</a><br /></td></tr>
<tr class="separator:a9e1b5f51edb6d5cd35b45da7063f72a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e08e1a0a3c19566aeaa94fbfc188ddb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a2e08e1a0a3c19566aeaa94fbfc188ddb">canonicalizeLoopBounds</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a2e08e1a0a3c19566aeaa94fbfc188ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize the bounds of the given loop.  <a href="AffineOps_8cpp.html#a2e08e1a0a3c19566aeaa94fbfc188ddb">More...</a><br /></td></tr>
<tr class="separator:a2e08e1a0a3c19566aeaa94fbfc188ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021d91d70aa35c1c72efff729a5d296a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a021d91d70aa35c1c72efff729a5d296a">hasTrivialZeroTripCount</a> (AffineForOp op)</td></tr>
<tr class="memdesc:a021d91d70aa35c1c72efff729a5d296a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the affine.for has zero iterations in trivial cases.  <a href="AffineOps_8cpp.html#a021d91d70aa35c1c72efff729a5d296a">More...</a><br /></td></tr>
<tr class="separator:a021d91d70aa35c1c72efff729a5d296a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db09c19adc76e23ac2943fef4a17051"><td class="memTemplParams" colspan="2">template&lt;typename BoundListTy , typename LoopCreatorTy &gt; </td></tr>
<tr class="memitem:a9db09c19adc76e23ac2943fef4a17051"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a9db09c19adc76e23ac2943fef4a17051">buildAffineLoopNestImpl</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, BoundListTy lbs, BoundListTy ubs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; steps, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilderFn, LoopCreatorTy &amp;&amp;loopCreatorFn)</td></tr>
<tr class="memdesc:a9db09c19adc76e23ac2943fef4a17051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds an affine loop nest, using "loopCreatorFn" to create individual loop operations.  <a href="AffineOps_8cpp.html#a9db09c19adc76e23ac2943fef4a17051">More...</a><br /></td></tr>
<tr class="separator:a9db09c19adc76e23ac2943fef4a17051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000ad2f44506c1fbce68e3f31a6aa2b5"><td class="memItemLeft" align="right" valign="top">static AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a000ad2f44506c1fbce68e3f31a6aa2b5">buildAffineLoopFromConstants</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, int64_t lb, int64_t ub, int64_t step, AffineForOp::BodyBuilderFn bodyBuilderFn)</td></tr>
<tr class="memdesc:a000ad2f44506c1fbce68e3f31a6aa2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an affine loop from the bounds known to be constants.  <a href="AffineOps_8cpp.html#a000ad2f44506c1fbce68e3f31a6aa2b5">More...</a><br /></td></tr>
<tr class="separator:a000ad2f44506c1fbce68e3f31a6aa2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834861d11a6a7baca945d6ffbc3a8ed2"><td class="memItemLeft" align="right" valign="top">static AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a834861d11a6a7baca945d6ffbc3a8ed2">buildAffineLoopFromValues</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> lb, <a class="el" href="classmlir_1_1Value.html">Value</a> ub, int64_t step, AffineForOp::BodyBuilderFn bodyBuilderFn)</td></tr>
<tr class="memdesc:a834861d11a6a7baca945d6ffbc3a8ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an affine loop from the bounds that may or may not be constants.  <a href="AffineOps_8cpp.html#a834861d11a6a7baca945d6ffbc3a8ed2">More...</a><br /></td></tr>
<tr class="separator:a834861d11a6a7baca945d6ffbc3a8ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d11028d3d26c5cccb74bfcc8e9a130"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a56d11028d3d26c5cccb74bfcc8e9a130">composeSetAndOperands</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> &amp;set, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;operands)</td></tr>
<tr class="memdesc:a56d11028d3d26c5cccb74bfcc8e9a130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose any affine.apply ops feeding into <code>operands</code> of the integer set <code>set</code> by composing the maps of such affine.apply ops with the integer set constraints.  <a href="AffineOps_8cpp.html#a56d11028d3d26c5cccb74bfcc8e9a130">More...</a><br /></td></tr>
<tr class="separator:a56d11028d3d26c5cccb74bfcc8e9a130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc7bff8e942284836b0568956a46f96"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#aefc7bff8e942284836b0568956a46f96">verifyMemoryOpIndexing</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, AffineMapAttr mapAttr, <a class="el" href="classmlir_1_1Operation.html#a8fc63f3d33e11994ab3330eb6e8990b9">Operation::operand_range</a> mapOperands, MemRefType memrefType, unsigned numIndexOperands)</td></tr>
<tr class="memdesc:aefc7bff8e942284836b0568956a46f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify common indexing invariants of affine.load, affine.store, affine.vector_load and affine.vector_store.  <a href="AffineOps_8cpp.html#aefc7bff8e942284836b0568956a46f96">More...</a><br /></td></tr>
<tr class="separator:aefc7bff8e942284836b0568956a46f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0fa7df47a2dd4686dfd19868542977a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae0fa7df47a2dd4686dfd19868542977a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#ae0fa7df47a2dd4686dfd19868542977a">verifyAffineMinMaxOp</a> (T op)</td></tr>
<tr class="separator:ae0fa7df47a2dd4686dfd19868542977a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc66ae957af7e80fc8e9101d997a109"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0bc66ae957af7e80fc8e9101d997a109"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a0bc66ae957af7e80fc8e9101d997a109">printAffineMinMaxOp</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, T op)</td></tr>
<tr class="separator:a0bc66ae957af7e80fc8e9101d997a109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b90328357d17ae6c877a3e306f88360"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6b90328357d17ae6c877a3e306f88360"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a6b90328357d17ae6c877a3e306f88360">parseAffineMinMaxOp</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result)</td></tr>
<tr class="separator:a6b90328357d17ae6c877a3e306f88360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239b29451081bbe685157a5388f032ca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a239b29451081bbe685157a5388f032ca"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a239b29451081bbe685157a5388f032ca">foldMinMaxOp</a> (T op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands)</td></tr>
<tr class="memdesc:a239b29451081bbe685157a5388f032ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold an affine min or max operation with the given operands.  <a href="AffineOps_8cpp.html#a239b29451081bbe685157a5388f032ca">More...</a><br /></td></tr>
<tr class="separator:a239b29451081bbe685157a5388f032ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2906e3ab99c40d772adeef8e53417d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#aff2906e3ab99c40d772adeef8e53417d">canonicalizeMapExprAndTermOrder</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;map)</td></tr>
<tr class="memdesc:aff2906e3ab99c40d772adeef8e53417d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize the result expression order of an affine map and return success if the order changed.  <a href="AffineOps_8cpp.html#aff2906e3ab99c40d772adeef8e53417d">More...</a><br /></td></tr>
<tr class="separator:aff2906e3ab99c40d772adeef8e53417d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c2749d394c9d62ad34650fed76d26d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a45c2749d394c9d62ad34650fed76d26d">canonicalizeLoopBounds</a> (AffineParallelOp op)</td></tr>
<tr class="memdesc:a45c2749d394c9d62ad34650fed76d26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize the bounds of the given loop.  <a href="AffineOps_8cpp.html#a45c2749d394c9d62ad34650fed76d26d">More...</a><br /></td></tr>
<tr class="separator:a45c2749d394c9d62ad34650fed76d26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fef8d134535c158ca70408a89d5f54e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a0fef8d134535c158ca70408a89d5f54e">printMinMaxBound</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, AffineMapAttr mapAttr, <a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a> group, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands, StringRef keyword)</td></tr>
<tr class="memdesc:a0fef8d134535c158ca70408a89d5f54e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a lower(upper) bound of an affine parallel loop with max(min) conditions in it.  <a href="AffineOps_8cpp.html#a0fef8d134535c158ca70408a89d5f54e">More...</a><br /></td></tr>
<tr class="separator:a0fef8d134535c158ca70408a89d5f54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65c3bf6127907b60e2e625d6520af2a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#ac65c3bf6127907b60e2e625d6520af2a">deduplicateAndResolveOperands</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">OpAsmParser::UnresolvedOperand</a> &gt;&gt; operands, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;uniqueOperands, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &amp;replacements, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133">AffineExprKind</a> kind)</td></tr>
<tr class="memdesc:ac65c3bf6127907b60e2e625d6520af2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of lists of parsed operands, populates <code>uniqueOperands</code> with unique operands.  <a href="AffineOps_8cpp.html#ac65c3bf6127907b60e2e625d6520af2a">More...</a><br /></td></tr>
<tr class="separator:ac65c3bf6127907b60e2e625d6520af2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afe1ec9e8058baa1d0329155fe863cf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a7afe1ec9e8058baa1d0329155fe863cf">parseAffineMapWithMinMax</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result, MinMaxKind kind)</td></tr>
<tr class="memdesc:a7afe1ec9e8058baa1d0329155fe863cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses an affine map that can contain a min/max for groups of its results, e.g., max(expr-1, expr-2), expr-3, max(expr-4, expr-5, expr-6).  <a href="AffineOps_8cpp.html#a7afe1ec9e8058baa1d0329155fe863cf">More...</a><br /></td></tr>
<tr class="separator:a7afe1ec9e8058baa1d0329155fe863cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669ae7d5e51e45da0b7f33d95e846a8b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a669ae7d5e51e45da0b7f33d95e846a8b">verifyVectorMemoryOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, MemRefType memrefType, VectorType vectorType)</td></tr>
<tr class="memdesc:a669ae7d5e51e45da0b7f33d95e846a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify common invariants of affine.vector_load and affine.vector_store.  <a href="AffineOps_8cpp.html#a669ae7d5e51e45da0b7f33d95e846a8b">More...</a><br /></td></tr>
<tr class="separator:a669ae7d5e51e45da0b7f33d95e846a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&nbsp;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;affine-analysis&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00028">28</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

</div>
</div>
<a id="a52c883a38e577b8b12282ff70c95a16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c883a38e577b8b12282ff70c95a16d">&#9670;&nbsp;</a></span>GET_OP_CLASSES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GET_OP_CLASSES</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l04207">4207</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

</div>
</div>
<a id="aeb4eeb99d83d4a53327f3c7a9574ad6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4eeb99d83d4a53327f3c7a9574ad6f">&#9670;&nbsp;</a></span>GET_OP_LIST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GET_OP_LIST</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a000ad2f44506c1fbce68e3f31a6aa2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000ad2f44506c1fbce68e3f31a6aa2b5">&#9670;&nbsp;</a></span>buildAffineLoopFromConstants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static AffineForOp buildAffineLoopFromConstants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp::BodyBuilderFn&#160;</td>
          <td class="paramname"><em>bodyBuilderFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an affine loop from the bounds known to be constants. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02358">2358</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l02367">buildAffineLoopFromValues()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02380">mlir::buildAffineLoopNest()</a>.</p>

</div>
</div>
<a id="a834861d11a6a7baca945d6ffbc3a8ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834861d11a6a7baca945d6ffbc3a8ed2">&#9670;&nbsp;</a></span>buildAffineLoopFromValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static AffineForOp buildAffineLoopFromValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp::BodyBuilderFn&#160;</td>
          <td class="paramname"><em>bodyBuilderFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an affine loop from the bounds that may or may not be constants. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02367">2367</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l02358">buildAffineLoopFromConstants()</a>, <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, and <a class="el" href="Builders_8cpp_source.html#l00346">mlir::Builder::getDimIdentityMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l02388">mlir::buildAffineLoopNest()</a>.</p>

</div>
</div>
<a id="a9db09c19adc76e23ac2943fef4a17051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db09c19adc76e23ac2943fef4a17051">&#9670;&nbsp;</a></span>buildAffineLoopNestImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BoundListTy , typename LoopCreatorTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buildAffineLoopNestImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BoundListTy&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BoundListTy&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;&#160;</td>
          <td class="paramname"><em>bodyBuilderFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LoopCreatorTy &amp;&amp;&#160;</td>
          <td class="paramname"><em>loopCreatorFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds an affine loop nest, using "loopCreatorFn" to create individual loop operations. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02317">2317</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, and <a class="el" href="Builders_8h_source.html#l00383">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l02380">mlir::buildAffineLoopNest()</a>.</p>

</div>
</div>
<a id="a2e08e1a0a3c19566aeaa94fbfc188ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e08e1a0a3c19566aeaa94fbfc188ddb">&#9670;&nbsp;</a></span>canonicalizeLoopBounds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> canonicalizeLoopBounds </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Canonicalize the bounds of the given loop. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01970">1970</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01225">mlir::canonicalizeMapAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00798">composeAffineMapAndOperands()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00656">mlir::removeDuplicateExprs()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="a45c2749d394c9d62ad34650fed76d26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c2749d394c9d62ad34650fed76d26d">&#9670;&nbsp;</a></span>canonicalizeLoopBounds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> canonicalizeLoopBounds </td>
          <td>(</td>
          <td class="paramtype">AffineParallelOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Canonicalize the bounds of the given loop. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l03637">3637</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l03626">mlir::AffineValueMap::canonicalize()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00100">mlir::AffineValueMap::getAffineMap()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00096">mlir::AffineValueMap::getOperands()</a>, <a class="el" href="LogicalResult_8h_source.html#l00068">mlir::succeeded()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="aff2906e3ab99c40d772adeef8e53417d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2906e3ab99c40d772adeef8e53417d">&#9670;&nbsp;</a></span>canonicalizeMapExprAndTermOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> canonicalizeMapExprAndTermOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Canonicalize the result expression order of an affine map and return success if the order changed. </p>
<p>The function flattens the map's affine expressions to coefficient arrays and sorts them in lexicographic order. A coefficient array contains a multiplier for every dimension/symbol and a constant term. The canonicalization fails if a result expression is not pure or if the flattening requires local variables that, unlike dimensions and symbols, have no global order. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l03146">3146</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00306">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00314">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00310">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00319">mlir::AffineMap::getResults()</a>, <a class="el" href="AffineExprVisitor_8h_source.html#l00256">mlir::SimpleAffineExprFlattener::operandExprStack</a>, and <a class="el" href="AffineExprVisitor_8h_source.html#l00075">mlir::AffineExprVisitor&lt; SubClass, RetTy &gt;::walkPostOrder()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l03201">CanonicalizeAffineMinMaxOpExprAndTermOrder&lt; T &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a43a13ffbd2aefb7089f0b7a1e5411b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a13ffbd2aefb7089f0b7a1e5411b11">&#9670;&nbsp;</a></span>canonicalizeMapOrSetAndOperands()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapOrSet &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void canonicalizeMapOrSetAndOperands </td>
          <td>(</td>
          <td class="paramtype">MapOrSet *&#160;</td>
          <td class="paramname"><em>mapOrSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01149">1149</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00281">mlir::AffineExpr::dyn_cast()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00513">mlir::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00488">mlir::getAffineDimExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00498">mlir::getAffineSymbolExpr()</a>, <a class="el" href="Matchers_8h_source.html#l00255">mlir::m_Constant()</a>, <a class="el" href="Matchers_8h_source.html#l00329">mlir::matchPattern()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00160">value</a>.</p>

</div>
</div>
<a id="a622cab33387384a309422bb2c690772f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622cab33387384a309422bb2c690772f">&#9670;&nbsp;</a></span>canonicalizePromotedSymbols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapOrSet &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void canonicalizePromotedSymbols </td>
          <td>(</td>
          <td class="paramtype">MapOrSet *&#160;</td>
          <td class="paramname"><em>mapOrSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01106">1106</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00488">mlir::getAffineDimExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00498">mlir::getAffineSymbolExpr()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00356">mlir::isValidSymbol()</a>.</p>

</div>
</div>
<a id="a4ac2b143b9e950ff18a9c6e949699a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac2b143b9e950ff18a9c6e949699a98">&#9670;&nbsp;</a></span>composeAffineMapAndOperands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void composeAffineMapAndOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over <code>operands</code> and fold away all those produced by an AffineApplyOp iteratively. </p>
<p>Perform canonicalization of map and operands as well as AffineMap simplification. <code>map</code> and <code>operands</code> are mutated in place. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00798">798</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01225">mlir::canonicalizeMapAndOperands()</a>, <a class="el" href="Matchers_8h_source.html#l00230">mlir::detail::enumerate()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00513">mlir::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00488">mlir::getAffineDimExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00498">mlir::getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00265">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00306">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00314">mlir::AffineMap::getNumResults()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00174">mlir::AffineMap::isFunctionOfDim()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00181">mlir::AffineMap::isFunctionOfSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00755">replaceDimOrSym()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00404">mlir::AffineMap::replaceDimsAndSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00646">mlir::simplifyAffineMap()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00068">mlir::succeeded()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l03626">mlir::AffineValueMap::canonicalize()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01970">canonicalizeLoopBounds()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02659">composeSetAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00860">mlir::fullyComposeAffineMapAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00957">mlir::makeComposedAffineApply()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01005">mlir::makeComposedFoldedAffineApply()</a>.</p>

</div>
</div>
<a id="a0230f8255abc6b40272f16c3bb8e8e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0230f8255abc6b40272f16c3bb8e8e94">&#9670;&nbsp;</a></span>composeMultiResultAffineMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void composeMultiResultAffineMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes the given affine map with the given list of operands, pulling in the maps from any affine.apply operations that supply the operands. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00976">976</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01225">mlir::canonicalizeMapAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00860">mlir::fullyComposeAffineMapAndOperands()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01043">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00265">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00306">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00314">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00323">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00526">mlir::AffineMap::getSubMap()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00220">mlir::AffineMap::shiftDims()</a>, and <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00233">mlir::AffineMap::shiftSymbols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01040">mlir::makeComposedAffineMin()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01048">makeComposedFoldedMinMax()</a>.</p>

</div>
</div>
<a id="a56d11028d3d26c5cccb74bfcc8e9a130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d11028d3d26c5cccb74bfcc8e9a130">&#9670;&nbsp;</a></span>composeSetAndOperands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void composeSetAndOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compose any affine.apply ops feeding into <code>operands</code> of the integer set <code>set</code> by composing the maps of such affine.apply ops with the integer set constraints. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02659">2659</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00798">composeAffineMapAndOperands()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01043">mlir::AffineMap::get()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01069">mlir::IntegerSet::get()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00041">mlir::IntegerSet::getConstraints()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00057">mlir::IntegerSet::getContext()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00051">mlir::IntegerSet::getEqFlags()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00306">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00015">mlir::IntegerSet::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00310">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00016">mlir::IntegerSet::getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00319">mlir::AffineMap::getResults()</a>.</p>

</div>
</div>
<a id="a2e66c6a798856c89d951e1955e40b73b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e66c6a798856c89d951e1955e40b73b">&#9670;&nbsp;</a></span>createFoldedComposedAffineApply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Value.html">Value</a> createFoldedComposedAffineApply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operandsRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fully compose map with operands and canonicalize the result. </p>
<p>Return the <code>createOrFold</code>'ed AffineApply op. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01079">1079</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01225">mlir::canonicalizeMapAndOperands()</a>, <a class="el" href="Builders_8h_source.html#l00472">mlir::OpBuilder::createOrFold()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00860">mlir::fullyComposeAffineMapAndOperands()</a>.</p>

</div>
</div>
<a id="a858e28031d26c8a1095d59f0b269a9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a858e28031d26c8a1095d59f0b269a9d2">&#9670;&nbsp;</a></span>createOrFold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if_t&lt;OpTy::template hasTrait&lt;<a class="el" href="classmlir_1_1OpTrait_1_1OneResult.html">OpTrait::OneResult</a>&gt;), <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt; createOrFold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>leadingArguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an operation of the type provided as template argument and attempt to fold it immediately. </p>
<p>The operation is expected to have a builder taking arbitrary <code>leadingArguments</code>, followed by a list of Value-typed <code>operands</code>. The operation is also expected to always produce a single result. Return an <code>OpFoldResult</code> containing the Attribute representing the folded constant if complete folding was possible and a Value produced by the created operation otherwise. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00913">913</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00422">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8h_source.html#l00272">mlir::OpBuilder::getListener()</a>, <a class="el" href="Matchers_8h_source.html#l00255">mlir::m_Constant()</a>, <a class="el" href="Matchers_8h_source.html#l00329">mlir::matchPattern()</a>, <a class="el" href="Builders_8h_source.html#l00260">mlir::OpBuilder::Listener::notifyOperationInserted()</a>, <a class="el" href="Builders_8h_source.html#l00268">mlir::OpBuilder::setListener()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00068">mlir::succeeded()</a>.</p>

</div>
</div>
<a id="ac65c3bf6127907b60e2e625d6520af2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac65c3bf6127907b60e2e625d6520af2a">&#9670;&nbsp;</a></span>deduplicateAndResolveOperands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> deduplicateAndResolveOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">OpAsmParser::UnresolvedOperand</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>uniqueOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>replacements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133">AffineExprKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a list of lists of parsed operands, populates <code>uniqueOperands</code> with unique operands. </p>
<p>Also populates <code>replacements with affine expressions of </code>kind<code>that can be used to update affine maps previously accepting a </code>operands<code>to accept</code>uniqueOperands` instead. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l03734">3734</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

</div>
</div>
<a id="a9e1b5f51edb6d5cd35b45da7063f72a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1b5f51edb6d5cd35b45da7063f72a2">&#9670;&nbsp;</a></span>foldLoopBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> foldLoopBounds </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fold the constant bounds of a loop. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01924">1924</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00343">mlir::AffineMap::constantFold()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00314">mlir::AffineMap::getNumResults()</a>, <a class="el" href="Matchers_8h_source.html#l00255">mlir::m_Constant()</a>, <a class="el" href="Matchers_8h_source.html#l00329">mlir::matchPattern()</a>, <a class="el" href="LogicalResult_8h_source.html#l00068">mlir::succeeded()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="a239b29451081bbe685157a5388f032ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239b29451081bbe685157a5388f032ca">&#9670;&nbsp;</a></span>foldMinMaxOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> foldMinMaxOp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fold an affine min or max operation with the given operands. </p>
<p>The operand list may contain nulls, which are interpreted as the operand not being a constant. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02986">2986</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="InterfaceSupport_8h_source.html#l00160">value</a>.</p>

</div>
</div>
<a id="a9113c24d7d445c3728e0d7945c064421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9113c24d7d445c3728e0d7945c064421">&#9670;&nbsp;</a></span>getLargestKnownDivisor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int64_t getLargestKnownDivisor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the largest known divisor of <code>e</code>. </p>
<p>Exploits information from the values in <code>operands</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00584">584</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00281">mlir::AffineExpr::dyn_cast()</a>, <a class="el" href="MPInt_8h_source.html#l00399">mlir::presburger::gcd()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02294">mlir::getForInductionVarOwner()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00219">mlir::AffineExpr::getLargestKnownDivisor()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00650">isQTimesDPlusR()</a>.</p>

</div>
</div>
<a id="a021d91d70aa35c1c72efff729a5d296a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021d91d70aa35c1c72efff729a5d296a">&#9670;&nbsp;</a></span>hasTrivialZeroTripCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hasTrivialZeroTripCount </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the affine.for has zero iterations in trivial cases. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02120">2120</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

</div>
</div>
<a id="abb7f0f42fc1a8809ab9d7ae95aac496a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7f0f42fc1a8809ab9d7ae95aac496a">&#9670;&nbsp;</a></span>isDimOpValidSymbol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isDimOpValidSymbol </td>
          <td>(</td>
          <td class="paramtype">ShapedDimOpInterface&#160;</td>
          <td class="paramname"><em>dimOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the result of the dim op is a valid symbol for <code>region</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00326">326</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00096">mlir::getConstantIntValue()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00313">isMemRefSizeValidSymbol()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00232">mlir::isTopLevelValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00385">mlir::isValidSymbol()</a>.</p>

</div>
</div>
<a id="a6db62c4fe9a0af0edf33f735e7450913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db62c4fe9a0af0edf33f735e7450913">&#9670;&nbsp;</a></span>isMemRefSizeValidSymbol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AnyMemRefDefOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isMemRefSizeValidSymbol </td>
          <td>(</td>
          <td class="paramtype">AnyMemRefDefOp&#160;</td>
          <td class="paramname"><em>memrefDefOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the 'index' dimension of the <code>memref</code> defined by <code>memrefDefOp</code> is a statically shaped one or defined using a valid symbol for <code>region</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00313">313</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00356">mlir::isValidSymbol()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00326">isDimOpValidSymbol()</a>.</p>

</div>
</div>
<a id="a764b24362c096adadc31e0db757b0bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764b24362c096adadc31e0db757b0bbc">&#9670;&nbsp;</a></span>isNonNegativeBoundedBy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isNonNegativeBoundedBy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <code>e</code> is known to be: 0 &lt;= <code>e</code> &lt; <code>k</code>. </p>
<p>Handles the simple cases of <code>e</code> being an affine dim expression or a constant. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00622">622</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00281">mlir::AffineExpr::dyn_cast()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02294">mlir::getForInductionVarOwner()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00650">isQTimesDPlusR()</a>.</p>

</div>
</div>
<a id="ac607329b2b966b06fe88ec201119aea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac607329b2b966b06fe88ec201119aea3">&#9670;&nbsp;</a></span>isQTimesDPlusR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isQTimesDPlusR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>div</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>quotientTimesDiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>rem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if expression <code>e</code> is of the form d*e_1 + e_2 where 0 &lt;= e_2 &lt; d. </p>
<p>Set <code>div</code> to <code>d</code>, <code>quotientTimesDiv</code> to e_1 and <code>rem</code> to e_2 if the expression is in that form. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00650">650</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133aec211f7c20af43e742bf2570c3cb84f9">mlir::Add</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00281">mlir::AffineExpr::dyn_cast()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00584">getLargestKnownDivisor()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00622">isNonNegativeBoundedBy()</a>.</p>

</div>
</div>
<a id="a40425801875310c2151577ce17a33acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40425801875310c2151577ce17a33acd">&#9670;&nbsp;</a></span>isValidAffineIndexOperand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isValidAffineIndexOperand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00430">430</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00262">mlir::isValidDim()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00356">mlir::isValidSymbol()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00160">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01453">mlir::AffineDmaStartOp::verifyInvariantsImpl()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01556">mlir::AffineDmaWaitOp::verifyInvariantsImpl()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02766">verifyMemoryOpIndexing()</a>.</p>

</div>
</div>
<a id="aaf870053b51991e5999a553ab45e4819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf870053b51991e5999a553ab45e4819">&#9670;&nbsp;</a></span>makeComposedFoldedMinMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> makeComposedFoldedMinMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01048">1048</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00976">composeMultiResultAffineMap()</a>, <a class="el" href="Builders_8cpp_source.html#l00056">mlir::Builder::getIndexType()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00876">materializeConstants()</a>.</p>

</div>
</div>
<a id="a01f080fa5377f31fd9ba465ad2789ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f080fa5377f31fd9ba465ad2789ef1">&#9670;&nbsp;</a></span>materializeConstants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void materializeConstants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>actualValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a list of <code>OpFoldResult</code>, build the necessary operations to populate <code>actualValues</code> with values produced by operations. </p>
<p>In particular, for any attribute-typed element in <code>values</code>, call the constant materializer associated with the Affine dialect to produce an operation. Do NOT notify the builder listener about the constant ops being created as they are intended to be removed after being folded into affine constructs; this is not suitable for use beyond the Affine dialect. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00876">876</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Attributes_8h_source.html#l00137">mlir::Attribute::cast()</a>, <a class="el" href="Builders_8h_source.html#l00054">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00109">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00056">mlir::Builder::getIndexType()</a>, <a class="el" href="Builders_8h_source.html#l00272">mlir::OpBuilder::getListener()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00399">mlir::MLIRContext::getLoadedDialect()</a>, <a class="el" href="Builders_8h_source.html#l00268">mlir::OpBuilder::setListener()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00160">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01005">mlir::makeComposedFoldedAffineApply()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01048">makeComposedFoldedMinMax()</a>.</p>

</div>
</div>
<a id="a7afe1ec9e8058baa1d0329155fe863cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7afe1ec9e8058baa1d0329155fe863cf">&#9670;&nbsp;</a></span>parseAffineMapWithMinMax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> parseAffineMapWithMinMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MinMaxKind&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses an affine map that can contain a min/max for groups of its results, e.g., max(expr-1, expr-2), expr-3, max(expr-4, expr-5, expr-6). </p>
<p>Populates <code>result</code> attributes with the map (flat list of expressions) and the grouping (list of integers that specify how many expressions to put into each min/max) attributes. Deduplicates repeated operands.</p>
<p>parallel-bound ::= <code>(</code> parallel-group-list <code>)</code> parallel-group-list ::= parallel-group (<code>,</code> parallel-group-list)? parallel-group ::= simple-group | min-max-group simple-group ::= expr-of-ssa-ids min-max-group ::= ( <code>min</code> | <code>max</code> ) <code>(</code> expr-of-ssa-ids-list <code>)</code> expr-of-ssa-ids-list ::= expr-of-ssa-ids (<code>,</code> expr-of-ssa-id-list)?</p>
<p>Examples: (%0, min(%1 + %2, %3), %4, min(%5 floordiv 32, %6)) (%0, max(%1 - 2 * %2)) </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l03781">3781</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

</div>
</div>
<a id="a6b90328357d17ae6c877a3e306f88360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b90328357d17ae6c877a3e306f88360">&#9670;&nbsp;</a></span>parseAffineMinMaxOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> parseAffineMinMaxOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02963">2963</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="OpImplementation_8h_source.html#l01194">mlir::AsmParser::addTypeToList()</a>, <a class="el" href="OperationSupport_8h_source.html#l00634">mlir::OperationState::attributes</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2bf38020e304fa596401f15d1eb30e1d">mlir::AsmParser::getBuilder()</a>, <a class="el" href="Builders_8cpp_source.html#l00056">mlir::Builder::getIndexType()</a>, <a class="el" href="OperationSupport_8h_source.html#l00631">mlir::OperationState::operands</a>, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95bae4e85fd5ca8927b9be287e34162aab21">mlir::AsmParser::OptionalSquare</a>, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95ba3f5a1b4ee2e68aebee8e1fa43e0eed27">mlir::AsmParser::Paren</a>, <a class="el" href="classmlir_1_1AsmParser.html#afc30172e59d0a9e4a28d8ba7ddf1ac42">mlir::AsmParser::parseAttribute()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#af16d3e3ef46bd2bd45b4e8db657c221a">mlir::OpAsmParser::parseOperandList()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2bf4b8149e630797ac1ac90d8e118c4b">mlir::AsmParser::parseOptionalAttrDict()</a>, <a class="el" href="OpImplementation_8h_source.html#l01388">mlir::OpAsmParser::resolveOperands()</a>, and <a class="el" href="OperationSupport_8h_source.html#l00633">mlir::OperationState::types</a>.</p>

</div>
</div>
<a id="a4de10d06704729af9438e5f4ae91bdec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de10d06704729af9438e5f4ae91bdec">&#9670;&nbsp;</a></span>parseBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> parseBound </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a for operation loop bounds. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01679">1679</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8h_source.html#l00665">mlir::OperationState::addAttribute()</a>, <a class="el" href="OperationSupport_8h_source.html#l00634">mlir::OperationState::attributes</a>, <a class="el" href="IR_2Attributes_8h_source.html#l00127">mlir::Attribute::dyn_cast()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a33803273c4fc1a660d73cb91aceac30b">mlir::AsmParser::emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2bf38020e304fa596401f15d1eb30e1d">mlir::AsmParser::getBuilder()</a>, <a class="el" href="Builders_8cpp_source.html#l00341">mlir::Builder::getConstantAffineMap()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a7850fe0a2961f835384adb372758d58b">mlir::AsmParser::getCurrentLocation()</a>, <a class="el" href="Builders_8cpp_source.html#l00056">mlir::Builder::getIndexType()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a8d00f93debeb1567ae8f7bbb76cdea37">mlir::AsmParser::getNameLoc()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00306">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00314">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00310">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="Builders_8cpp_source.html#l00359">mlir::Builder::getSymbolIdentityMap()</a>, <a class="el" href="OperationSupport_8h_source.html#l00631">mlir::OperationState::operands</a>, <a class="el" href="classmlir_1_1AsmParser.html#afc30172e59d0a9e4a28d8ba7ddf1ac42">mlir::AsmParser::parseAttribute()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00445">mlir::parseDimAndSymbolList()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#af16d3e3ef46bd2bd45b4e8db657c221a">mlir::OpAsmParser::parseOperandList()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a305f6334c61eb92a164bd865851f55f4">mlir::AsmParser::parseOptionalKeyword()</a>, <a class="el" href="OperationSupport_8h_source.html#l00554">mlir::NamedAttrList::pop_back()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a8c583b0d425ac93c7f8a867f5546db6a">mlir::OpAsmParser::resolveOperand()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="a0bc66ae957af7e80fc8e9101d997a109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc66ae957af7e80fc8e9101d997a109">&#9670;&nbsp;</a></span>printAffineMinMaxOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void printAffineMinMaxOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02950">2950</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1OpAsmPrinter.html#a681280bde1406e824e1d4626fe257e1b">mlir::OpAsmPrinter::printOptionalAttrDict()</a>.</p>

</div>
</div>
<a id="ae2978fd47e940232657b5ae684d7ccce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2978fd47e940232657b5ae684d7ccce">&#9670;&nbsp;</a></span>printBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void printBound </td>
          <td>(</td>
          <td class="paramtype">AffineMapAttr&#160;</td>
          <td class="paramname"><em>boundMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html#a8fc63f3d33e11994ab3330eb6e8990b9">Operation::operand_range</a>&#160;</td>
          <td class="paramname"><em>boundOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01841">1841</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00281">mlir::AffineExpr::dyn_cast()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00306">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00314">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00310">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00323">mlir::AffineMap::getResult()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00435">printDimAndSymbolList()</a>, and <a class="el" href="classmlir_1_1OpAsmPrinter.html#acddd5eb143c94fa8528920c75799e3ba">mlir::OpAsmPrinter::printOperand()</a>.</p>

</div>
</div>
<a id="a909b810a734e0872e03164db8d7fa7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909b810a734e0872e03164db8d7fa7f8">&#9670;&nbsp;</a></span>printDimAndSymbolList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void printDimAndSymbolList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html#ae9f435d73bdd799ad9f8ace519293a45">Operation::operand_iterator</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html#ae9f435d73bdd799ad9f8ace519293a45">Operation::operand_iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>printer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints dimension and symbol list. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00435">435</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01841">printBound()</a>.</p>

</div>
</div>
<a id="a0fef8d134535c158ca70408a89d5f54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fef8d134535c158ca70408a89d5f54e">&#9670;&nbsp;</a></span>printMinMaxBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void printMinMaxBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineMapAttr&#160;</td>
          <td class="paramname"><em>mapAttr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a>&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>keyword</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints a lower(upper) bound of an affine parallel loop with max(min) conditions in it. </p>
<p><code>mapAttr</code> is a flat list of affine expressions and <code>group</code> identifies which of the those expressions form max/min groups. <code>operands</code> are the SSA values of dimensions and symbols and <code>keyword</code> is either "min" or "max". </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l03666">3666</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00306">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00323">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00534">mlir::AffineMap::getSliceMap()</a>, <a class="el" href="classmlir_1_1OpAsmPrinter.html#a92e834f0b1924f751616f89def818263">mlir::OpAsmPrinter::printAffineExprOfSSAIds()</a>, and <a class="el" href="classmlir_1_1OpAsmPrinter.html#aa04de9fec0531cddf28646b119a770af">mlir::OpAsmPrinter::printAffineMapOfSSAIds()</a>.</p>

</div>
</div>
<a id="aff9087c9020dc5397a2edf1feda93d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff9087c9020dc5397a2edf1feda93d79">&#9670;&nbsp;</a></span>remainsLegalAfterInline() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool LLVM_ATTRIBUTE_UNUSED remainsLegalAfterInline </td>
          <td>(</td>
          <td class="paramtype">AffineApplyOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1BlockAndValueMapping.html">BlockAndValueMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an affine apply operation remains legal after inlining from <code>src</code> to <code>dest</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00115">115</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00262">mlir::isValidDim()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00356">mlir::isValidSymbol()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00048">remainsLegalAfterInline()</a>.</p>

</div>
</div>
<a id="a1c87dc72c15957a6eb37f2814302209f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c87dc72c15957a6eb37f2814302209f">&#9670;&nbsp;</a></span>remainsLegalAfterInline() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool remainsLegalAfterInline </td>
          <td>(</td>
          <td class="paramtype">OpTy&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1BlockAndValueMapping.html">BlockAndValueMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if an affine read or write operation remains legal after inlining from <code>src</code> to <code>dest</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00088">88</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00306">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00310">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00262">mlir::isValidDim()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00356">mlir::isValidSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00048">remainsLegalAfterInline()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00160">value</a>.</p>

</div>
</div>
<a id="afb70e7e08d963e3f8338d11301fc4004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb70e7e08d963e3f8338d11301fc4004">&#9670;&nbsp;</a></span>remainsLegalAfterInline() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool remainsLegalAfterInline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1BlockAndValueMapping.html">BlockAndValueMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;&#160;</td>
          <td class="paramname"><em>legalityCheck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>value</code> known to be a legal affine dimension or symbol in <code>src</code> region remains legal if the operation that uses it is inlined into <code>dest</code> with the given value mapping. </p>
<p><code>legalityCheck</code> is either <code>isValidDim</code> or <code>isValidSymbol</code>, depending on the value being required to remain a valid dimension or symbol. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00048">48</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00232">mlir::isTopLevelValue()</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00066">mlir::BlockAndValueMapping::lookup()</a>, <a class="el" href="Matchers_8h_source.html#l00255">mlir::m_Constant()</a>, <a class="el" href="Matchers_8h_source.html#l00329">mlir::matchPattern()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00160">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00077">remainsLegalAfterInline()</a>.</p>

</div>
</div>
<a id="ab5aed3481d2961b1b02ddcf67b7b6993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5aed3481d2961b1b02ddcf67b7b6993">&#9670;&nbsp;</a></span>remainsLegalAfterInline() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool remainsLegalAfterInline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1BlockAndValueMapping.html">BlockAndValueMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;&#160;</td>
          <td class="paramname"><em>legalityCheck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if all values known to be legal affine dimensions or symbols in <code>src</code> remain so if their respective users are inlined into <code>dest</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00077">77</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00048">remainsLegalAfterInline()</a>.</p>

</div>
</div>
<a id="a583a996043dd655d70f175b01cfe19cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583a996043dd655d70f175b01cfe19cd">&#9670;&nbsp;</a></span>replaceDimOrSym()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> replaceDimOrSym </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dimOrSymbolPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>syms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace all occurrences of AffineExpr at position <code>pos</code> in <code>map</code> by the defining AffineApplyOp expression and operands. </p>
<p>When <code>dimOrSymbolPosition &lt; dims.size()</code>, AffineDimExpr@[pos] is replaced. When <code>dimOrSymbolPosition &gt;= dims.size()</code>, AffineSymbolExpr@[pos - dims.size()] is replaced. Mutate <code>map</code>,<code>dims</code> and <code>syms</code> in place as follows:</p><ol type="1">
<li><code>dims</code> and <code>syms</code> are only appended to.</li>
<li><code>map</code> dim and symbols are gradually shifted to higher positions.</li>
<li>Old <code>dim</code> and <code>sym</code> entries are replaced by nullptr This avoids the need for any bookkeeping. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00755">755</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00488">mlir::getAffineDimExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00498">mlir::getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00265">mlir::AffineMap::getContext()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00306">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00314">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00310">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00323">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00419">mlir::AffineMap::replace()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00220">mlir::AffineMap::shiftDims()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00233">mlir::AffineMap::shiftSymbols()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00798">composeAffineMapAndOperands()</a>.</p>

</div>
</div>
<a id="ac25dd93649ca1f6b8b66a800b4cb38af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25dd93649ca1f6b8b66a800b4cb38af">&#9670;&nbsp;</a></span>simplifyExprAndOperands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void simplifyExprAndOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplify <code>expr</code> while exploiting information from the values in <code>operands</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00674">674</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00281">mlir::AffineExpr::dyn_cast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00733">simplifyMapWithOperands()</a>.</p>

</div>
</div>
<a id="a15c002a789228f4f6ca08ecf5d775ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c002a789228f4f6ca08ecf5d775ef3">&#9670;&nbsp;</a></span>simplifyMapWithOperands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void LLVM_ATTRIBUTE_UNUSED simplifyMapWithOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplify the map while exploiting information on the values in <code>operands</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00733">733</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01043">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00265">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00306">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00315">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00314">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00310">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00319">mlir::AffineMap::getResults()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00674">simplifyExprAndOperands()</a>.</p>

</div>
</div>
<a id="ae0fa7df47a2dd4686dfd19868542977a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0fa7df47a2dd4686dfd19868542977a">&#9670;&nbsp;</a></span>verifyAffineMinMaxOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> verifyAffineMinMaxOp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02940">2940</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="aaf19ea7311ad162852c482c8523b7120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf19ea7311ad162852c482c8523b7120">&#9670;&nbsp;</a></span>verifyDimAndSymbolIdentifiers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> verifyDimAndSymbolIdentifiers </td>
          <td>(</td>
          <td class="paramtype">OpTy &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html#a8fc63f3d33e11994ab3330eb6e8990b9">Operation::operand_range</a>&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to verify that a set of operands are valid dimension and symbol identifiers. </p>
<p>The operands should be laid out such that the dimension operands are before the symbol operands. This function returns failure if there was an invalid operand. An operation is provided to emit any necessary errors. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00468">468</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00247">mlir::getAffineScope()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00262">mlir::isValidDim()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00356">mlir::isValidSymbol()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="aefc7bff8e942284836b0568956a46f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc7bff8e942284836b0568956a46f96">&#9670;&nbsp;</a></span>verifyMemoryOpIndexing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> verifyMemoryOpIndexing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineMapAttr&#160;</td>
          <td class="paramname"><em>mapAttr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html#a8fc63f3d33e11994ab3330eb6e8990b9">Operation::operand_range</a>&#160;</td>
          <td class="paramname"><em>mapOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>memrefType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numIndexOperands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify common indexing invariants of affine.load, affine.store, affine.vector_load and affine.vector_store. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02766">2766</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00512">mlir::Operation::emitOpError()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00247">mlir::getAffineScope()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00315">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00314">mlir::AffineMap::getNumResults()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00430">isValidAffineIndexOperand()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="a669ae7d5e51e45da0b7f33d95e846a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669ae7d5e51e45da0b7f33d95e846a8b">&#9670;&nbsp;</a></span>verifyVectorMemoryOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> verifyVectorMemoryOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>memrefType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType&#160;</td>
          <td class="paramname"><em>vectorType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify common invariants of affine.vector_load and affine.vector_store. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l04070">4070</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00512">mlir::Operation::emitOpError()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 17 2022 20:37:46 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
